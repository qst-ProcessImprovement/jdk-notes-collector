<!-- 
RSS generated by JIRA (9.12.27#9120027-sha1:edc4490121e366e9e7bd2213d532dbe7e028fc5d) at Tue Sep 30 10:03:09 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>Java Bug System</title>
    <link>https://bugs.openjdk.org</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-us</language>    <build-info>
        <version>9.12.27</version>
        <build-number>9120027</build-number>
        <build-date>02-09-2025</build-date>
    </build-info>


<item>
            <title>[JDK-8312174] missing JVMTI events from vthreads parked during JVMTI attach</title>
                <link>https://bugs.openjdk.org/browse/JDK-8312174</link>
                <project id="10100" key="JDK">JDK</project>
                    <description>ADDITIONAL SYSTEM INFORMATION :&lt;br/&gt;
Ubunu 22.10 x86_64 &lt;br/&gt;
&lt;br/&gt;
openjdk version &amp;quot;22-ea&amp;quot; 2024-03-19&lt;br/&gt;
OpenJDK Runtime Environment (build 22-ea+6-393)&lt;br/&gt;
OpenJDK 64-Bit Server VM (build 22-ea+6-393, mixed mode, sharing)&lt;br/&gt;
&lt;br/&gt;
openjdk version &amp;quot;21-ea&amp;quot; 2023-09-19&lt;br/&gt;
OpenJDK Runtime Environment (build 21-ea+31-2444)&lt;br/&gt;
OpenJDK 64-Bit Server VM (build 21-ea+31-2444, mixed mode, sharing)&lt;br/&gt;
&lt;br/&gt;
commit 81c4e8f916a04582698907291b6505d4484cf9c2&lt;br/&gt;
from &lt;a href=&quot;https://github.com/openjdk/jdk.git&quot;&gt;https://github.com/openjdk/jdk.git&lt;/a&gt;&lt;br/&gt;
&lt;br/&gt;
A DESCRIPTION OF THE PROBLEM :&lt;br/&gt;
VirtualThreadEnd events are not posted for virtual threads that were parked while an agent was loaded into a running JVM. This also applied to the mount/unmount extension events.&lt;br/&gt;
&lt;br/&gt;
These events are posted for virtual threads that were mounted during attach. In the builds mentioned above, events for mounted vhtreads were incomplete, but with the fix for &lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8311556&quot; title=&quot;GetThreadLocalStorage not working for vthreads mounted during JVMTI attach&quot; class=&quot;issue-link&quot; data-issue-key=&quot;JDK-8311556&quot;&gt;&lt;strike&gt;JDK-8311556&lt;/strike&gt;&lt;/a&gt;, all events seem to be posted for vthreads mounted during attach.&lt;br/&gt;
&lt;br/&gt;
STEPS TO FOLLOW TO REPRODUCE THE PROBLEM :&lt;br/&gt;
With the attached sample and JAVA_HOME set to a JDK 21 or 22: &lt;br/&gt;
&lt;br/&gt;
g++ -std=c++11 -shared -I$JAVA_HOME/include -I$JAVA_HOME/include/linux -fPIC VThreadEventTest.cpp -o libVThreadEventTest.so&lt;br/&gt;
&lt;br/&gt;
$JAVA_HOME/bin/javac VThreadEventTest.java&lt;br/&gt;
&lt;br/&gt;
LD_LIBRARY_PATH=. $JAVA_HOME/bin/java  -Djdk.attach.allowAttachSelf=true -XX:+EnableDynamicAgentLoading VThreadEventTest&lt;br/&gt;
&lt;br/&gt;
EXPECTED VERSUS ACTUAL BEHAVIOR :&lt;br/&gt;
EXPECTED -&lt;br/&gt;
Process exits with 0. &lt;br/&gt;
ACTUAL -&lt;br/&gt;
Process exits with 1 and prints  &lt;br/&gt;
&lt;br/&gt;
end: 4 (exp: 17), unmount: 7 (exp: 20), mount: 0 (exp: 13)&lt;br/&gt;
unexpected count&lt;br/&gt;
&lt;br/&gt;
for the builds mentioned above and &lt;br/&gt;
&lt;br/&gt;
end: 7 (exp: 17), unmount: 10 (exp: 20), mount: 3 (exp: 13)&lt;br/&gt;
unexpected count&lt;br/&gt;
&lt;br/&gt;
with a build from the repo at the commit mentioned above.&lt;br/&gt;
&lt;br/&gt;
---------- BEGIN SOURCE ----------&lt;br/&gt;
-- VThreadEventTest.java ----------------------------------------------------------- &lt;br/&gt;
import com.sun.tools.attach.VirtualMachine;&lt;br/&gt;
&lt;br/&gt;
import java.util.concurrent.ExecutorService;&lt;br/&gt;
import java.util.concurrent.Executors;&lt;br/&gt;
import java.util.concurrent.locks.LockSupport;&lt;br/&gt;
&lt;br/&gt;
public class VThreadEventTest {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;private static native int getEndCount();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;private static native int getMountCount();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;private static native int getUnmountCount();&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;private static volatile boolean attached;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public static void main(String[] args) throws Exception {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if (Runtime.getRuntime().availableProcessors() &amp;lt; 8) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.println(&amp;quot;WARNING: test expects at least 8 processors.&amp;quot;);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;try (ExecutorService executorService = Executors.newVirtualThreadPerTaskExecutor()) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;for (int threadCount = 0; threadCount &amp;lt; 10; threadCount++) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;executorService.execute(() -&amp;gt; {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;LockSupport.parkNanos(1_000_000L * 7_000);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;});&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;for (int threadCount = 0; threadCount &amp;lt; 4; threadCount++) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;executorService.execute(() -&amp;gt; {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;while (!attached) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// keep mounted&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;});&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;for (int threadCount = 0; threadCount &amp;lt; 3; threadCount++) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;executorService.execute(() -&amp;gt; {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;while (!attached) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// keep mounted&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;LockSupport.parkNanos(1_000_000L * 100);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;});&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Thread.sleep(2_000);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;VirtualMachine vm = VirtualMachine.attach(String.valueOf(ProcessHandle.current().pid()));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;vm.loadAgentLibrary(&amp;quot;VThreadEventTest&amp;quot;);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Thread.sleep(500);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;attached = true;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;int endCount = getEndCount();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;int unmountCount = getUnmountCount();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;int mountCount = getMountCount();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;int endExpected = 10 + 4 + 3;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;int unmountExpected = 10 + 4 + 3 * 2;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;int mountExpected = 10 + 3;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.println(&amp;quot;end: &amp;quot; + endCount + &amp;quot; (exp: &amp;quot; + endExpected + &amp;quot;), unmount: &amp;quot; + unmountCount +&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;quot; (exp: &amp;quot; + unmountExpected + &amp;quot;), mount: &amp;quot; + mountCount + &amp;quot; (exp: &amp;quot; + mountExpected + &amp;quot;)&amp;quot;);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if (endCount != endExpected || unmountCount != unmountExpected || mountCount != mountExpected) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.println(&amp;quot;unexpected count&amp;quot;);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.exit(1);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
}&lt;br/&gt;
------------------------------------------------------------------------------------&lt;br/&gt;
-- VThreadEventTest.java -----------------------------------------------------------&lt;br/&gt;
#include &amp;lt;jvmti.h&amp;gt;&lt;br/&gt;
#include &amp;lt;cstring&amp;gt;&lt;br/&gt;
#include &amp;lt;mutex&amp;gt;&lt;br/&gt;
&lt;br/&gt;
#ifdef _WIN32&lt;br/&gt;
#define VARIADICJNI __cdecl&lt;br/&gt;
#else&lt;br/&gt;
#define VARIADICJNI JNICALL&lt;br/&gt;
#endif&lt;br/&gt;
&lt;br/&gt;
namespace {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;jvmtiEnv *jvmti = nullptr;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;std::mutex lock;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;int endCount = 0;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;int unmountCount = 0;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;int mountCount = 0;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;void checkJvmti(int code, const char* message) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if (code != JVMTI_ERROR_NONE) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;printf(&amp;quot;Error %s: %d\n&amp;quot;, message, code);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;abort();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;void JNICALL vthreadEnd(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread virtual_thread) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;std::lock_guard&amp;lt;std::mutex&amp;gt; lockGuard(lock);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;endCount++;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;void VARIADICJNI vthreadUnmount(jvmtiEnv* jvmti_env, ...) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;std::lock_guard&amp;lt;std::mutex&amp;gt; lockGuard(lock);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;unmountCount++;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;void VARIADICJNI vthreadMount(jvmtiEnv* jvmti_env, ...) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;std::lock_guard&amp;lt;std::mutex&amp;gt; lockGuard(lock);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;mountCount++;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
extern &amp;quot;C&amp;quot; JNIEXPORT jint JNICALL Java_VThreadEventTest_getEndCount(JNIEnv* jni_env, jclass clazz) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;std::lock_guard&amp;lt;std::mutex&amp;gt; lockGuard(lock);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return endCount;&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
extern &amp;quot;C&amp;quot; JNIEXPORT jint JNICALL Java_VThreadEventTest_getMountCount(JNIEnv* jni_env, jclass clazz) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;std::lock_guard&amp;lt;std::mutex&amp;gt; lockGuard(lock);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return mountCount;&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
extern &amp;quot;C&amp;quot; JNIEXPORT jint JNICALL Java_VThreadEventTest_getUnmountCount(JNIEnv* jni_env, jclass clazz) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;std::lock_guard&amp;lt;std::mutex&amp;gt; lockGuard(lock);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return unmountCount;&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
extern &amp;quot;C&amp;quot; JNIEXPORT jint JNICALL Agent_OnAttach(JavaVM *vm, char *options, void *reserved) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;printf(&amp;quot;attached\n&amp;quot;);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if (vm-&amp;gt;GetEnv(reinterpret_cast&amp;lt;void **&amp;gt;(&amp;amp;jvmti), JVMTI_VERSION) != JNI_OK || !jvmti) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;printf(&amp;quot;Could not initialize JVMTI\n&amp;quot;);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;abort();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;jvmtiCapabilities capabilities;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;memset(&amp;amp;capabilities, 0, sizeof(capabilities));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;capabilities.can_support_virtual_threads = 1;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;checkJvmti(jvmti-&amp;gt;AddCapabilities(&amp;amp;capabilities), &amp;quot;adding capabilities&amp;quot;);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;jvmtiEventCallbacks callbacks;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;memset(&amp;amp;callbacks, 0, sizeof(callbacks));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;callbacks.VirtualThreadEnd = &amp;amp;vthreadEnd;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;checkJvmti(jvmti-&amp;gt;SetEventCallbacks(&amp;amp;callbacks, (jint)sizeof(callbacks)), &amp;quot;setting callbacks&amp;quot;);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;checkJvmti(jvmti-&amp;gt;SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VIRTUAL_THREAD_END, nullptr), &amp;quot;enabling vthread end event&amp;quot;);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;jint extensionCount = 0;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;jvmtiExtensionEventInfo* extensions;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;checkJvmti(jvmti-&amp;gt;GetExtensionEvents(&amp;amp;extensionCount, &amp;amp;extensions), &amp;quot;getting extension events&amp;quot;);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;jint unmountIndex = -1;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;jint mountIndex = -1;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;for (int exIndex = 0; exIndex &amp;lt; extensionCount; exIndex++) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;jvmtiExtensionEventInfo &amp;amp;eventInfo = extensions[exIndex];&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if (strcmp(eventInfo.id, &amp;quot;com.sun.hotspot.events.VirtualThreadUnmount&amp;quot;) == 0) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;unmountIndex = eventInfo.extension_event_index;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;} else if (strcmp(eventInfo.id, &amp;quot;com.sun.hotspot.events.VirtualThreadMount&amp;quot;) == 0) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;mountIndex = eventInfo.extension_event_index;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if (unmountIndex == -1 || mountIndex == -1) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;printf(&amp;quot;extension events not found.&amp;quot;);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;abort();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;checkJvmti(jvmti-&amp;gt;SetExtensionEventCallback(unmountIndex, vthreadUnmount), &amp;quot;setting extension callback&amp;quot;);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;checkJvmti(jvmti-&amp;gt;SetEventNotificationMode(JVMTI_ENABLE, static_cast&amp;lt;jvmtiEvent&amp;gt;(unmountIndex), nullptr), &amp;quot;enabling extension event&amp;quot;);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;checkJvmti(jvmti-&amp;gt;SetExtensionEventCallback(mountIndex, vthreadMount), &amp;quot;setting extension callback&amp;quot;);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;checkJvmti(jvmti-&amp;gt;SetEventNotificationMode(JVMTI_ENABLE, static_cast&amp;lt;jvmtiEvent&amp;gt;(mountIndex), nullptr), &amp;quot;enabling extension event&amp;quot;);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;printf(&amp;quot;vthread events enabled\n&amp;quot;);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return JVMTI_ERROR_NONE;&lt;br/&gt;
}&lt;br/&gt;
------------------------------------------------------------------------------------&lt;br/&gt;
&lt;br/&gt;
---------- END SOURCE ----------&lt;br/&gt;
&lt;br/&gt;
FREQUENCY : always&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
</description>
                <environment></environment>
        <key id="5105599">JDK-8312174</key>
            <summary>missing JVMTI events from vthreads parked during JVMTI attach</summary>
                <type id="1" iconUrl="https://bugs.openjdk.org/secure/viewavatar?size=xsmall&amp;avatarId=14703&amp;avatarType=issuetype">Bug</type>
                                            <priority id="4" iconUrl="https://bugs.openjdk.org/images/jbsImages/p4.png">P4</priority>
                        <status id="5" iconUrl="https://bugs.openjdk.org/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="success"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="sspitsyn">Serguei Spitsyn</assignee>
                                    <reporter username="webbuggrp">Webbug Group</reporter>
                        <labels>
                            <label>amazon-interest</label>
                            <label>capbug</label>
                            <label>google-interest</label>
                            <label>jdk21u-fix-SQE-ok</label>
                            <label>jdk21u-fix-request</label>
                            <label>jdk21u-fix-yes</label>
                            <label>loom</label>
                    </labels>
                <created>Mon, 17 Jul 2023 03:14:20 -0700</created>
                <updated>Thu, 1 Feb 2024 21:41:30 -0800</updated>
                            <resolved>Mon, 11 Sep 2023 19:50:15 -0700</resolved>
                                    <version>21</version>
                                    <fixVersion>22</fixVersion>
                                    <component>hotspot</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>8</watches>
                                                                                                                <comments>
                            <comment id="14628519" author="sspitsyn" created="Wed, 22 Nov 2023 11:42:22 -0800"  >Okay, thanks.</comment>
                            <comment id="14628272" author="manc" created="Tue, 21 Nov 2023 17:17:06 -0800"  >So far we have only observed the problem when an application attaches native threads. &lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8319935&quot; title=&quot;Ensure only one JvmtiThreadState is created for one JavaThread associated with attached native thread&quot; class=&quot;issue-link&quot; data-issue-key=&quot;JDK-8319935&quot;&gt;&lt;strike&gt;JDK-8319935&lt;/strike&gt;&lt;/a&gt; is also targeting the case of attaching native threads.&lt;br/&gt;
&lt;br/&gt;
In my opinion, after the proposed fix in &lt;a href=&quot;https://github.com/openjdk/jdk/pull/16642&quot;&gt;https://github.com/openjdk/jdk/pull/16642&lt;/a&gt; , JvmtiThreadState::state_for_while_locked() still has the possibility of creating multiple instances of JvmtiThreadState pointing to the same platform thread. However, I have not seen it happening in practice.</comment>
                            <comment id="14628270" author="sspitsyn" created="Tue, 21 Nov 2023 16:58:07 -0800"  >Also, thank you for filing the follow up bug &lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8319935&quot; title=&quot;Ensure only one JvmtiThreadState is created for one JavaThread associated with attached native thread&quot; class=&quot;issue-link&quot; data-issue-key=&quot;JDK-8319935&quot;&gt;&lt;strike&gt;JDK-8319935&lt;/strike&gt;&lt;/a&gt;.&lt;br/&gt;
I&amp;#39;m trying to catch up now. Is this issue observable for attaching native threads only or it is more general?</comment>
                            <comment id="14628269" author="manc" created="Tue, 21 Nov 2023 16:51:54 -0800"  >No worries. Yes, it has already been backported to 21u.</comment>
                            <comment id="14628267" author="sspitsyn" created="Tue, 21 Nov 2023 16:37:53 -0800"  >&amp;gt; ~sspitsyn, any concern for backporting this to 21u? &lt;br/&gt;
[~manc] Sorry for being late. It seems you have already back ported this to 21u, right? Thank you a lot for this! In fact, I had to do it myself.</comment>
                            <comment id="14625570" author="jiangli" created="Fri, 10 Nov 2023 18:03:28 -0800"  >Filed &lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8319935&quot; title=&quot;Ensure only one JvmtiThreadState is created for one JavaThread associated with attached native thread&quot; class=&quot;issue-link&quot; data-issue-key=&quot;JDK-8319935&quot;&gt;&lt;strike&gt;JDK-8319935&lt;/strike&gt;&lt;/a&gt;.</comment>
                            <comment id="14625567" author="jiangli" created="Fri, 10 Nov 2023 15:46:33 -0800"  >I looked further into this today. David, as you commented above, the &amp;#39;fix&amp;#39; is indeed lucky coincidence.&lt;br/&gt;
&lt;br/&gt;
The two JvmtiThreadStates for one JavaThread issue that we have observed particularly happens for attached native thread. The first creation of a JvmtiThreadState occurs during JvmtiEventControllerPrivate::thread_started when a thread is being attached and it&amp;#39;s creating the Java instance of the Thread. The created JvmtiThreadState has a null _thread_oop_h.&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;* frame #0: 0x00007f88791948aa libjvm.so`JvmtiThreadState::JvmtiThreadState(JavaThread*, oopDesc*) [inlined] OopHandle::OopHandle(this=0x00005602b76eb810) at oopHandle.hpp:46:17&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;frame #1: 0x00007f88791948aa libjvm.so`JvmtiThreadState::JvmtiThreadState(this=0x00005602b76eb800, thread=0x00005602b7769c10, thread_oop=0x0000000000000000) at jvmtiThreadState.cpp:56:19&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;frame #2: 0x00007f8879176d83 libjvm.so`JvmtiEventCollector::setup_jvmti_thread_state() [inlined] JvmtiThreadState::state_for_while_locked(thread=&amp;lt;unavailable&amp;gt;, thread_oop=&amp;lt;unavailable&amp;gt;) at jvmtiThreadState.inline.hpp:98:19&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;frame #3: 0x00007f8879176cec libjvm.so`JvmtiEventCollector::setup_jvmti_thread_state() at jvmtiThreadState.inline.hpp:111:13&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;frame #4: 0x00007f8879176cc4 libjvm.so`JvmtiEventCollector::setup_jvmti_thread_state(this=0x00007ffcbf7bee98) at jvmtiExport.cpp:2953:29&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;frame #5: 0x00007f88791773ee libjvm.so`JvmtiSampledObjectAllocEventCollector::start(this=0x00007ffcbf7bee98) at jvmtiExport.cpp:3146:5&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;frame #6: 0x00007f887928a549 libjvm.so`MemAllocator::Allocation::notify_allocation_jvmti_sampler() [inlined] JvmtiSampledObjectAllocEventCollector::JvmtiSampledObjectAllocEventCollector(this=0x00007ffcbf7bee98, should_start=true) at jvmtiExport.hpp:560:5&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;frame #7: 0x00007f887928a52b libjvm.so`MemAllocator::Allocation::notify_allocation_jvmti_sampler(this=0x00007ffcbf7bef40) at memAllocator.cpp:185:43&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;frame #8: 0x00007f887928a94a libjvm.so`MemAllocator::Allocation::notify_allocation(this=&amp;lt;unavailable&amp;gt;, thread=&amp;lt;unavailable&amp;gt;) at memAllocator.cpp:235:3 [artificial]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;frame #9: 0x00007f887928aec9 libjvm.so`MemAllocator::allocate() const [inlined] MemAllocator::Allocation::~Allocation(this=0x00007ffcbf7bef40) at memAllocator.cpp:85:7&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;frame #10: 0x00007f887928aeb3 libjvm.so`MemAllocator::allocate(this=0x00007ffcbf7bef90) const at memAllocator.cpp:375:3&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;frame #11: 0x00007f8878f2f221 libjvm.so`InstanceKlass::allocate_instance_handle(JavaThread*) [inlined] CollectedHeap::obj_allocate(this=&amp;lt;unavailable&amp;gt;, klass=&amp;lt;unavailable&amp;gt;, size=&amp;lt;unavailable&amp;gt;, __the_thread__=0x00005602b7769c10) at collectedHeap.inline.hpp:36:20&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;frame #12: 0x00007f8878f2f1fd libjvm.so`InstanceKlass::allocate_instance_handle(JavaThread*) [inlined] InstanceKlass::allocate_instance(this=&amp;lt;unavailable&amp;gt;, __the_thread__=0x00005602b7769c10) at instanceKlass.cpp:1442:38&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;frame #13: 0x00007f8878f2f1ee libjvm.so`InstanceKlass::allocate_instance_handle(this=&amp;lt;unavailable&amp;gt;, __the_thread__=&amp;lt;unavailable&amp;gt;) at instanceKlass.cpp:1462:33&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;frame #14: 0x00007f8878f6bff9 libjvm.so`JavaThread::allocate_threadObj(this=0x00005602b7769c10, thread_group=Handle @ r13, thread_name=&amp;lt;unavailable&amp;gt;, daemon=false, __the_thread__=&amp;lt;unavailable&amp;gt;) at javaThread.cpp:222:35&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;frame #15: 0x00007f8879000020 libjvm.so`attach_current_thread(vm=&amp;lt;unavailable&amp;gt;, penv=0x00007ffcbf7bf1c0, _args=&amp;lt;unavailable&amp;gt;, daemon=&amp;lt;unavailable&amp;gt;) at jni.cpp:3819:13&lt;br/&gt;
...&lt;br/&gt;
&lt;br/&gt;
The second creation of JvmtiThreadState for the same JavaThread (for the attaching native thread) occurs during JvmtiExport::post_thread_start when attach:&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;* frame #0: 0x00007f88791948aa libjvm.so`JvmtiThreadState::JvmtiThreadState(JavaThread*, oopDesc*) [inlined] OopHandle::OopHandle(this=0x00005602b76eb910) at oopHandle.hpp:46:17&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;frame #1: 0x00007f88791948aa libjvm.so`JvmtiThreadState::JvmtiThreadState(this=0x00005602b76eb900, thread=0x00005602b7769c10, thread_oop=0x0000000116000000) at jvmtiThreadState.cpp:56:19&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;frame #2: 0x00007f8879166936 libjvm.so`JvmtiEventControllerPrivate::thread_started(JavaThread*) [inlined] JvmtiThreadState::state_for_while_locked(thread=0x00005602b7769c10, thread_oop=&amp;lt;unavailable&amp;gt;) at jvmtiThreadState.inline.hpp:98:19&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;frame #3: 0x00007f88791668b3 libjvm.so`JvmtiEventControllerPrivate::thread_started(thread=0x00005602b7769c10) at jvmtiEventController.cpp:744:31&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;frame #4: 0x00007f887916c1f4 libjvm.so`JvmtiExport::post_thread_start(thread=0x00005602b7769c10) at jvmtiExport.cpp:1476:3&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;frame #5: 0x00007f88790000af libjvm.so`attach_current_thread(vm=&amp;lt;unavailable&amp;gt;, penv=0x00007ffcbf7bf1c0, _args=&amp;lt;unavailable&amp;gt;, daemon=&amp;lt;unavailable&amp;gt;) at jni.cpp:3849:5&lt;br/&gt;
...&lt;br/&gt;
&lt;br/&gt;
Before the &lt;a href=&quot;https://git.openjdk.org/jdk/commit/fda142ff6cfefa12ec1ea4d4eb48b3c1b285bc04&quot;&gt;https://git.openjdk.org/jdk/commit/fda142ff6cfefa12ec1ea4d4eb48b3c1b285bc04&lt;/a&gt; change, JvmtiEventControllerPrivate::thread_started calls JvmtiThreadState::state_for_while_locked directly, which actually finds the already created JvmtiThreadState from the JavaThread. However the &amp;#39;if (state == nullptr || state-&amp;gt;get_thread_oop() != thread_oop)&amp;#39; check fails since the thread_oop from the state is null and is not the same as the actual thread_oop. Since the check fails, it decides to create a new JvmtiThreadState for the JavaThread.&lt;br/&gt;
&lt;br/&gt;
&lt;a href=&quot;https://git.openjdk.org/jdk/commit/fda142ff6cfefa12ec1ea4d4eb48b3c1b285bc04&quot;&gt;https://git.openjdk.org/jdk/commit/fda142ff6cfefa12ec1ea4d4eb48b3c1b285bc04&lt;/a&gt; changed to call JvmtiThreadState::state_for(thread) in JvmtiEventControllerPrivate::thread_started. JvmtiThreadState::state_for(thread) gets the JvmtiThreadState from the JavaThread and just returns. Hence there&amp;#39;s no additional state being created here.&lt;br/&gt;
&lt;br/&gt;
So the issue of non-1:1 JvmtiThreadStand and JavaThread turns out to be relatively simple. Although &lt;a href=&quot;https://git.openjdk.org/jdk/commit/fda142ff6cfefa12ec1ea4d4eb48b3c1b285bc04&quot;&gt;https://git.openjdk.org/jdk/commit/fda142ff6cfefa12ec1ea4d4eb48b3c1b285bc04&lt;/a&gt; resolved the issue by luck, I think we should put additional reinforcement. I&amp;#39;ll create a follow up bug. </comment>
                            <comment id="14625081" author="dholmes" created="Wed, 8 Nov 2023 18:53:49 -0800"  >Given this change adds missing thread-state objects, the fact it cleaned up &amp;quot;duplicate&amp;quot; ones seems a somewhat lucky coincidence and I think the original issue with having multiple thread-states per thread needs to be investigated further to see if the problem is still present in some form.</comment>
                            <comment id="14625080" author="jiangli" created="Wed, 8 Nov 2023 18:27:20 -0800"  >Here are some details and clarifications on the various crashes (as described by Man Cao above) we encountered:&lt;br/&gt;
&lt;br/&gt;
The crashes are always due to a bad JavaThread pointer in the current stable ThreadsList::_threads array. Depending on when the corrupted pointer is visited by the VM, it exhibits various different crashes during SafepointSynchronize::synchronize_threads, or ThreadsSMRSupport::free_list, etc. The crashes are latent symptoms caused by random (but not completely random) memory corruption originated from JvmtiEventControllerPrivate::recompute_thread_enabled due to a stale JavaThead (is already exited) referenced in a JvmtiThreadState. For a particular test that I debugged with, the memory corruption always&amp;#xA0;occurs at the 193-th element (a 64-bit word) in the ThreadsList::_threads. All other JavaThread pointers in the array are intact.&lt;br/&gt;
&lt;br/&gt;
In one of the failed instances that I investigated, the memory address being trashed was 0x00007f9dbc0018b8. The bogus value contained in the memory location was 0x00000000e00f4df0. The debugging information showed there was a JavaThread allocated at 0x00007f9dbc0012b0 earlier during the test execution. The thread later exited and was destroyed. There were two different JvmtiThreadStates were created as associated with this JavaThread. Since the JavaThread was bound to two different JvmtiThreadStates and only one was destroyed during the thread exit. The remaining JvmtiThreadState then contains an invalid pointer (to 0x00007f9dbc0012b0) after the thread exited. At a later point, an array of JavaThread* ( ThreadsList::_threads) was allocated at 0x00007f9dbc0012b0. 0x00007f9dbc0018b8 was a memory location within the array. It appeared that later during JvmtiEventControllerPrivate::recompute_thread_enabled operation, it caused memory trashing at 0x00007f9dbc0018b8 when it encounters the JvmtiThreadState that contains the stale JavaThread* 0x00007f9dbc0012b0.&lt;br/&gt;
&lt;br/&gt;
The fix for this bug appears to make the problem go away. I verified with the fix applied in JDK 21, only one JvmtiThreadState was created for one JavaThread. I haven&amp;#39;t filled the gap on how the fix ensures the 1-1 binding yet. Others more familiar with this area may make the connection more quickly.</comment>
                            <comment id="14624703" author="roboduke" created="Tue, 7 Nov 2023 17:48:27 -0800"  >A pull request was submitted for review.&lt;br/&gt;
URL: &lt;a href=&quot;https://git.openjdk.org/jdk21u/pull/337&quot;&gt;https://git.openjdk.org/jdk21u/pull/337&lt;/a&gt;&lt;br/&gt;
Date: 2023-11-08 01:42:27 +0000</comment>
                            <comment id="14624701" author="manc" created="Tue, 7 Nov 2023 17:43:36 -0800"  >Fix request (21u):&lt;br/&gt;
&lt;br/&gt;
This change mitigates JVM crashes and use-after-free bugs in JDK 21, see my comments above. The change applies cleanly to JDK 21u and passes pre-submit tests.</comment>
                            <comment id="14624672" author="manc" created="Tue, 7 Nov 2023 17:38:35 -0800"  >We have observed several different JVM crashes with 21 even without the variant of AddressSanitizer, and this change mitigates those crashes. Example crashing stack traces:&lt;br/&gt;
&lt;br/&gt;
Stack: [0x00007f3661efc000,0x00007f3662000000],  sp=0x00007f3661ffaf40,  free space=1019k&lt;br/&gt;
Native frames: (J=compiled Java code, j=interpreted, Vv=VM code, C=native code)&lt;br/&gt;
C  [libpthread.so.0+0x11a24]  pthread_sigmask+0x84&lt;br/&gt;
V  [libjvm.so+0x1059af1]  JVM_handle_linux_signal+0x1c1&lt;br/&gt;
C  [libpthread.so.0+0x151c0]&lt;br/&gt;
V  [libjvm.so+0x114fd23]  ThreadsSMRSupport::free_list(ThreadsList*)+0xf3&lt;br/&gt;
V  [libjvm.so+0x11563a8]  Threads::remove(JavaThread*, bool)+0x78&lt;br/&gt;
V  [libjvm.so+0xb6cf6a]  JavaThread::exit(bool, JavaThread::ExitType)+0x68a&lt;br/&gt;
V  [libjvm.so+0xb6c8a2]  JavaThread::post_run()+0x12&lt;br/&gt;
V  [libjvm.so+0x114b56e]  HotspotBaseThread::call_run()+0xae&lt;br/&gt;
V  [libjvm.so+0xf15f59]  thread_native_entry(HotspotBaseThread*)+0x119&lt;br/&gt;
&lt;br/&gt;
Or:&lt;br/&gt;
&lt;br/&gt;
Stack: [0x00007f651cb28000,0x00007f651cc2c000],  sp=0x00007f651cc26d00,  free space=1019k&lt;br/&gt;
Native frames: (J=compiled Java code, j=interpreted, Vv=VM code, C=native code)&lt;br/&gt;
C  [libpthread.so.0+0x11a24]  pthread_sigmask+0x84&lt;br/&gt;
V  [libjvm.so+0x1059af1]  JVM_handle_linux_signal+0x1c1&lt;br/&gt;
C  [libpthread.so.0+0x151c0]&lt;br/&gt;
V  [libjvm.so+0xfb268a]  SafepointSynchronize::begin()+0x17a&lt;br/&gt;
V  [libjvm.so+0x11d65ee]  VMThread::inner_execute(VM_Operation*)+0x19e&lt;br/&gt;
V  [libjvm.so+0x11d5d0a]  VMThread::run()+0xba&lt;br/&gt;
V  [libjvm.so+0x114b565]  HotspotBaseThread::call_run()+0xa5&lt;br/&gt;
V  [libjvm.so+0xf15f59]  thread_native_entry(HotspotBaseThread*)+0x119</comment>
                            <comment id="14623501" author="manc" created="Thu, 2 Nov 2023 16:32:21 -0700"  >I&amp;#39;d like to backport this change to 21u, to avoid the bug mentioned above. I&amp;#39;m not really sure if state_for_while_locked() still needs a fix to avoid creating JvmtiThreadState instances pointing to the same JavaThread*.&lt;br/&gt;
&lt;br/&gt;
~sspitsyn, any concern for backporting this to 21u?</comment>
                            <comment id="14623499" author="manc" created="Thu, 2 Nov 2023 16:25:33 -0700"  >We found that this change also fixed or avoided a bug in JDK 21 that manifests even when virtual thread is not used.&lt;br/&gt;
We run a variant of AddressSanitizer for malloc/free, and it detects a use-after-free bug during JVM shutdown, that JvmtiThreadState::set_should_post_on_exceptions() could access an already-freed JavaThread object from JvmtiThreadState::_thread. The stack trace looks like:&lt;br/&gt;
&lt;br/&gt;
#0	(inlined)	JavaThread::set_should_post_on_exceptions_flag	make/hotspot/src/hotspot/share/runtime/javaThread.hpp:1094&lt;br/&gt;
#1	(inlined)	JvmtiThreadState::set_should_post_on_exceptions	make/hotspot/src/hotspot/share/prims/jvmtiThreadState.inline.hpp:126&lt;br/&gt;
#2	0x7f2de8a81207	JvmtiEventControllerPrivate::recompute_thread_enabled	make/hotspot/src/hotspot/share/prims/jvmtiEventController.cpp:588&lt;br/&gt;
#3	0x557cd03e9d2f	FailureSignalHandler	&lt;br/&gt;
#4	(inlined)	call_chained_handler	make/hotspot/src/hotspot/os/posix/signals_posix.cpp:454&lt;br/&gt;
#5	0x7f2de8d756d4	PosixSignals::chained_handler	make/hotspot/src/hotspot/os/posix/signals_posix.cpp:472&lt;br/&gt;
#6	0x7f2de8d75940	JVM_handle_linux_signal	make/hotspot/src/hotspot/os/posix/signals_posix.cpp:674&lt;br/&gt;
#7	0x7f2dec9e91c0	__restore_rt	&lt;br/&gt;
#8	(inlined)	JavaThread::set_should_post_on_exceptions_flag	make/hotspot/src/hotspot/share/runtime/javaThread.hpp:1094&lt;br/&gt;
#9	(inlined)	JvmtiThreadState::set_should_post_on_exceptions	make/hotspot/src/hotspot/share/prims/jvmtiThreadState.inline.hpp:126&lt;br/&gt;
#10	0x7f2de8a81207	JvmtiEventControllerPrivate::recompute_thread_enabled	make/hotspot/src/hotspot/share/prims/jvmtiEventController.cpp:588&lt;br/&gt;
#11	0x7f2de8a81698	JvmtiEventControllerPrivate::recompute_enabled	make/hotspot/src/hotspot/share/prims/jvmtiEventController.cpp:668&lt;br/&gt;
#12	0x7f2de8a82b43	JvmtiEventController::set_user_enabled	make/hotspot/src/hotspot/share/prims/jvmtiEventController.cpp:1060&lt;br/&gt;
#13	0x7f2de8a6c70b	JvmtiEnv::SetEventNotificationMode	make/hotspot/src/hotspot/share/prims/jvmtiEnv.cpp:586&lt;br/&gt;
#14	0x7f2de8a27642	jvmti_SetEventNotificationMode	/tmp/jdkbuild/build/hotspot/variant-server/gensrc/jvmtifiles/jvmtiEnter.cpp:5321&lt;br/&gt;
#15	0x557cd0ebd366	google::javaprofiler::HeapMonitor::Disable	&lt;br/&gt;
#16	0x557cd0e691f8	OnVMDeath	&lt;br/&gt;
#17	0x7f2de8a84e5d	JvmtiExport::post_vm_death	make/hotspot/src/hotspot/share/prims/jvmtiExport.cpp:762&lt;br/&gt;
#18	0x7f2de886e9dd	before_exit	make/hotspot/src/hotspot/share/runtime/java.cpp:515&lt;br/&gt;
#19	0x7f2de8e72301	Threads::destroy_vm	make/hotspot/src/hotspot/share/runtime/threads.cpp:890&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
My investigation shows that it is due to `JvmtiThreadState::state_for_while_locked()` creating multiple JvmtiThreadState instances pointing to the same JavaThread*. All these instances appear on the JvmtiThreadState::_head linked list. When a JavaThread T exits and calls JvmtiExport::cleanup_thread(), it only deletes one JvmtiThreadState instance on the linked list, leaving other instances pointing to T having a dangling pointer.&lt;br/&gt;
&lt;br/&gt;
It looks like the change in JvmtiEventControllerPrivate::thread_started() that changed JvmtiThreadState::state_for_while_locked() to JvmtiThreadState::state_for() is effective to avoid this bug.</comment>
                            <comment id="14610243" author="dukebot" created="Mon, 11 Sep 2023 19:50:14 -0700"  >Changeset: fda142ff&lt;br/&gt;
Author:    Serguei Spitsyn &amp;lt;&lt;a href=&apos;mailto:sspitsyn@openjdk.org&apos;&gt;sspitsyn@openjdk.org&lt;/a&gt;&amp;gt;&lt;br/&gt;
Date:      2023-09-12 02:46:47 +0000&lt;br/&gt;
URL:       &lt;a href=&quot;https://git.openjdk.org/jdk/commit/fda142ff6cfefa12ec1ea4d4eb48b3c1b285bc04&quot;&gt;https://git.openjdk.org/jdk/commit/fda142ff6cfefa12ec1ea4d4eb48b3c1b285bc04&lt;/a&gt;&lt;br/&gt;
</comment>
                            <comment id="14607308" author="roboduke" created="Tue, 29 Aug 2023 03:15:55 -0700"  >A pull request was submitted for review.&lt;br/&gt;
URL: &lt;a href=&quot;https://git.openjdk.org/jdk/pull/15467&quot;&gt;https://git.openjdk.org/jdk/pull/15467&lt;/a&gt;&lt;br/&gt;
Date: 2023-08-29 10:09:21 +0000</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10200">
                    <name>Backport</name>
                                            <outwardlinks description="backported by">
                                        <issuelink>
            <issuekey id="5114745">JDK-8320109</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="5118518">JDK-8323386</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                            <issuelinktype id="10003">
                    <name>Relates</name>
                                            <outwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="5110319">JDK-8316283</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="5114554">JDK-8319935</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="5110282">JDK-8316250</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                    </issuelinks>
                <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_10000" key="com.atlassian.jira.plugin.system.customfieldtypes:multiselect">
                        <customfieldname>CPU</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="17008"><![CDATA[generic]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_11700" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_10600" key="com.oracle.jira.javabugsystem-jira-plugin:jbs-fixedBackportedCustomfield">
                        <customfieldname>Fixed</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                            <customfield id="customfield_10005" key="com.atlassian.jira.plugin.system.customfieldtypes:multiselect">
                        <customfieldname>OS</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="17010"><![CDATA[generic]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                            <customfield id="customfield_11100" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i32bhf:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_11004" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10006" key="com.atlassian.jira.plugin.system.customfieldtypes:select">
                        <customfieldname>Resolved In Build</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="17352"><![CDATA[b15]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10008" key="com.oracle.jira.jira-subcomponent-plugin:oracle-subComponentField">
                        <customfieldname>Subcomponent</customfieldname>
                        <customfieldvalues>
                             <customfieldvalue key="372"><![CDATA[jvmti]]></customfieldvalue> 
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_10601" key="com.oracle.jira.javabugsystem-jira-plugin:jbs-targetBackportedCustomfield">
                        <customfieldname>Targeted</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    </customfields>
    </item>
</channel>
</rss>