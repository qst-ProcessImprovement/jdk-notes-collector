<!-- 
RSS generated by JIRA (9.12.27#9120027-sha1:edc4490121e366e9e7bd2213d532dbe7e028fc5d) at Tue Sep 30 19:11:29 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>Java Bug System</title>
    <link>https://bugs.openjdk.org</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-us</language>    <build-info>
        <version>9.12.27</version>
        <build-number>9120027</build-number>
        <build-date>02-09-2025</build-date>
    </build-info>


<item>
            <title>[JDK-8307411] Test java/foreign/channels/TestAsyncSocketChannels.java failed: IllegalStateException: Already closed</title>
                <link>https://bugs.openjdk.org/browse/JDK-8307411</link>
                <project id="10100" key="JDK">JDK</project>
                    <description>----------System.out:(16/838)----------&lt;br/&gt;
Seed from RandomFactory = -101903027041002175L&lt;br/&gt;
test TestAsyncSocketChannels.testBasicIOWithSupportedSession(shared arena): success&lt;br/&gt;
testCloseWithOutstandingRead - op&lt;br/&gt;
testCloseWithOutstandingRead - op&lt;br/&gt;
testCloseWithOutstandingRead - op&lt;br/&gt;
testCloseWithOutstandingRead - op&lt;br/&gt;
test TestAsyncSocketChannels.testCloseWithOutstandingRead(shared arena, 0): success&lt;br/&gt;
testCloseWithOutstandingRead - op&lt;br/&gt;
testCloseWithOutstandingRead - op&lt;br/&gt;
testCloseWithOutstandingRead - op&lt;br/&gt;
testCloseWithOutstandingRead - op&lt;br/&gt;
test TestAsyncSocketChannels.testCloseWithOutstandingRead(shared arena, 30): success&lt;br/&gt;
awaitNoFurtherWrites: i=4 , bytesWritten=391968&lt;br/&gt;
awaiting outstanding writes....................................outstanding writes: 0&lt;br/&gt;
test TestAsyncSocketChannels.testCloseWithOutstandingWrite(shared arena, 0): success&lt;br/&gt;
awaitNoFurtherWrites: i=2 , bytesWritten=380668&lt;br/&gt;
----------System.err:(21/1828)----------&lt;br/&gt;
java.lang.IllegalStateException: Already closed&lt;br/&gt;
	at java.base/jdk.internal.foreign.MemorySessionImpl.alreadyClosed(MemorySessionImpl.java:311)&lt;br/&gt;
	at java.base/jdk.internal.misc.ScopedMemoryAccess$ScopedAccessError.newRuntimeException(ScopedMemoryAccess.java:113)&lt;br/&gt;
	at java.base/jdk.internal.foreign.MemorySessionImpl.checkValidState(MemorySessionImpl.java:219)&lt;br/&gt;
	at java.base/jdk.internal.foreign.NativeMemorySegmentImpl.makeNativeSegment(NativeMemorySegmentImpl.java:119)&lt;br/&gt;
	at java.base/jdk.internal.foreign.MemorySessionImpl.allocate(MemorySessionImpl.java:158)&lt;br/&gt;
	at java.base/java.lang.foreign.Arena.allocate(Arena.java:270)&lt;br/&gt;
	at AbstractChannelsTest.segmentBufferOfSize(AbstractChannelsTest.java:71)&lt;br/&gt;
	at AbstractChannelsTest.segmentBuffersOfSize(AbstractChannelsTest.java:81)&lt;br/&gt;
	at TestAsyncSocketChannels$1.completed(TestAsyncSocketChannels.java:268)&lt;br/&gt;
	at TestAsyncSocketChannels$1.completed(TestAsyncSocketChannels.java:263)&lt;br/&gt;
	at java.base/sun.nio.ch.Invoker.invokeUnchecked(Invoker.java:129)&lt;br/&gt;
	at java.base/sun.nio.ch.UnixAsynchronousSocketChannelImpl.finishWrite(UnixAsynchronousSocketChannelImpl.java:647)&lt;br/&gt;
	at java.base/sun.nio.ch.UnixAsynchronousSocketChannelImpl.finish(UnixAsynchronousSocketChannelImpl.java:199)&lt;br/&gt;
	at java.base/sun.nio.ch.UnixAsynchronousSocketChannelImpl.onEvent(UnixAsynchronousSocketChannelImpl.java:217)&lt;br/&gt;
	at java.base/sun.nio.ch.KQueuePort$EventHandlerTask.run(KQueuePort.java:312)&lt;br/&gt;
	at java.base/sun.nio.ch.AsynchronousChannelGroupImpl$1.run(AsynchronousChannelGroupImpl.java:113)&lt;br/&gt;
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)&lt;br/&gt;
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)&lt;br/&gt;
	at java.base/java.lang.Thread.run(Thread.java:1583)&lt;br/&gt;
STATUS:Failed.`main&amp;#39; threw exception: java.lang.IllegalStateException: Already closed</description>
                <environment></environment>
        <key id="5100081">JDK-8307411</key>
            <summary>Test java/foreign/channels/TestAsyncSocketChannels.java failed: IllegalStateException: Already closed</summary>
                <type id="1" iconUrl="https://bugs.openjdk.org/secure/viewavatar?size=xsmall&amp;avatarId=14703&amp;avatarType=issuetype">Bug</type>
                                            <priority id="4" iconUrl="https://bugs.openjdk.org/images/jbsImages/p4.png">P4</priority>
                        <status id="5" iconUrl="https://bugs.openjdk.org/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="success"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="mcimadamore">Maurizio Cimadamore</assignee>
                                    <reporter username="dholmes">David Holmes</reporter>
                        <labels>
                            <label>intermittent</label>
                            <label>jdk17u-fix-request</label>
                            <label>jdk17u-fix-yes</label>
                            <label>noreg-self</label>
                            <label>tier1</label>
                    </labels>
                <created>Wed, 3 May 2023 19:48:24 -0700</created>
                <updated>Thu, 4 Apr 2024 14:00:09 -0700</updated>
                            <resolved>Tue, 9 May 2023 04:15:53 -0700</resolved>
                                    <version>21</version>
                                    <fixVersion>21</fixVersion>
                                    <component>core-libs</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>6</watches>
                                                                                                                <comments>
                            <comment id="14662132" author="roboduke" created="Tue, 2 Apr 2024 07:41:31 -0700"  >A pull request was submitted for review.&lt;br/&gt;
URL: &lt;a href=&quot;https://git.openjdk.org/jdk17u-dev/pull/2360&quot;&gt;https://git.openjdk.org/jdk17u-dev/pull/2360&lt;/a&gt;&lt;br/&gt;
Date: 2024-04-02 14:36:00 +0000</comment>
                            <comment id="14662127" author="goetz" created="Tue, 2 Apr 2024 07:36:18 -0700"  >Fix request [17u]&lt;br/&gt;
&lt;br/&gt;
I backport this for parity with 17.0.12-oracle.&lt;br/&gt;
No risk, only a test change.&lt;br/&gt;
Clean backport.&lt;br/&gt;
Test passes. SAP nightly testing passed.</comment>
                            <comment id="14580160" author="dukebot" created="Tue, 9 May 2023 04:13:49 -0700"  >Changeset: f92d095e&lt;br/&gt;
Author:    Maurizio Cimadamore &amp;lt;&lt;a href=&apos;mailto:mcimadamore@openjdk.org&apos;&gt;mcimadamore@openjdk.org&lt;/a&gt;&amp;gt;&lt;br/&gt;
Date:      2023-05-09 11:11:15 +0000&lt;br/&gt;
URL:       &lt;a href=&quot;https://git.openjdk.org/jdk/commit/f92d095e164bd79b452586e49e166d1ba392632f&quot;&gt;https://git.openjdk.org/jdk/commit/f92d095e164bd79b452586e49e166d1ba392632f&lt;/a&gt;&lt;br/&gt;
</comment>
                            <comment id="14579775" author="roboduke" created="Mon, 8 May 2023 07:17:58 -0700"  >A pull request was submitted for review.&lt;br/&gt;
URL: &lt;a href=&quot;https://git.openjdk.org/jdk/pull/13866&quot;&gt;https://git.openjdk.org/jdk/pull/13866&lt;/a&gt;&lt;br/&gt;
Date: 2023-05-08 13:46:55 +0000</comment>
                            <comment id="14579757" author="mcimadamore" created="Mon, 8 May 2023 06:22:01 -0700"  >I can reproduce the failure by tweaking the &amp;quot;awaitNoFurtherWrites&amp;quot; and lowering the &amp;quot;timeout&amp;quot;.  It seems like the test is very dependent on the fact that, by the time the main thread executes, the writes buffers are full, and we have outstanding writes which cannot be fulfilled by the OS. This will keep the underlying segment alive (as the `drop` arena is kept alive until the write operation succeeds). So, when we check this:&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;assertMessage(expectThrows(ISE, () -&amp;gt; drop.close()), &amp;quot;Session is acquired by&amp;quot;); &lt;br/&gt;
&lt;br/&gt;
This fails as expected, and the test logic continues as designed.&lt;br/&gt;
&lt;br/&gt;
It is possible for the above check to execute when there is no underlying OS write. This can be either artificially, by lowering the timeout, or in a case where the timeout is not sufficient to fill the write buffer. In such cases, there&amp;#39;s nothing to keep the arena alive - meaning that the drop::close will pass. At this point the test will no longer behave as designed: outstanding writes might still see `continueWriting` set to true, but the arena is already closed at this point, so any attempt to perform further allocation will fail. Whether the test report the real failure (e.g. the fact that drop::close passed unexpectedly) or report an exception in one of the failing thread (as they are allocating on a closed arena) it&amp;#39;s matter of execution order.</comment>
                            <comment id="14579418" author="mcimadamore" created="Fri, 5 May 2023 09:26:47 -0700"  >Some synchronization logic in this test looks suspicious:&lt;br/&gt;
&lt;br/&gt;
```&lt;br/&gt;
outstandingWriteOps.getAndIncrement(); // 2&lt;br/&gt;
asc1.write(bba, 0, bba.length, timeout, SECONDS, null,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;(handler = new TestHandler&amp;lt;&amp;gt;() {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public void completed(Long result, Void att) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;super.completed(result, att); // 3&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;bytesWritten.addAndGet(result);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if (continueWriting.get()) { // 1&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;var bba = segmentBuffersOfSize(32, drop, 128);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;outstandingWriteOps.getAndIncrement(); // 2&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;asc1.write(bba, 0, bba.length, timeout, SECONDS, null, this);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;outstandingWriteOps.getAndDecrement();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// give time for socket buffer to fill up.&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;awaitNoFurtherWrites(bytesWritten);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;assertMessage(expectThrows(ISE, () -&amp;gt; drop.close()), &amp;quot;Session is acquired by&amp;quot;);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;assertTrue(drop.scope().isAlive());&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// signal handler to stop further writing&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;continueWriting.set(false); // 1&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// read to allow the outstanding write complete, which will&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// in turn unlock the session and allow it to be closed.&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;readNBytes(asc2, bytesWritten.get());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;assertTrue(drop.scope().isAlive());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;awaitOutstandingWrites(outstandingWriteOps); // 2&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;handler.await(); // 3&lt;br/&gt;
```&lt;br/&gt;
&lt;br/&gt;
Note how there are three distinct mechanism which should, in principle, prevent the arena to be closed before the TestHandler completes. The key mechanism seems &amp;quot;oustandingWriteOps&amp;quot; which is incremented before the test starts. Presumably, this count will always be set to 1 until the last write sees the &amp;quot;continueWriting&amp;quot; to false, in which case the counter is decremented without a corresponding increment (which should cause the count to be at zero).</comment>
                            <comment id="14578944" author="kbarrett" created="Wed, 3 May 2023 22:23:18 -0700"  >One new changeset for the Oracle CI job where this failure occurred - &lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8307147&quot; title=&quot;[x86] Dangling pointer warning for Assembler::_attributes&quot; class=&quot;issue-link&quot; data-issue-key=&quot;JDK-8307147&quot;&gt;&lt;strike&gt;JDK-8307147&lt;/strike&gt;&lt;/a&gt;.  However that change is cpu/x86-specific, while this failure happened on macosx-aarch64.  Also, the next tier1 job was clean, with no changes that seem relevant.  So marking this as intermittent.&lt;br/&gt;
&lt;br/&gt;
</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10200">
                    <name>Backport</name>
                                            <outwardlinks description="backported by">
                                        <issuelink>
            <issuekey id="5123378">JDK-8327442</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="5126235">JDK-8329713</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                    </issuelinks>
                <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_11700" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_10600" key="com.oracle.jira.javabugsystem-jira-plugin:jbs-fixedBackportedCustomfield">
                        <customfieldname>Fixed</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_11100" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i31dm3:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_11004" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10006" key="com.atlassian.jira.plugin.system.customfieldtypes:select">
                        <customfieldname>Resolved In Build</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="17415"><![CDATA[b22]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10008" key="com.oracle.jira.jira-subcomponent-plugin:oracle-subComponentField">
                        <customfieldname>Subcomponent</customfieldname>
                        <customfieldvalues>
                             <customfieldvalue key="2492"><![CDATA[java.lang.foreign]]></customfieldvalue> 
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_10601" key="com.oracle.jira.javabugsystem-jira-plugin:jbs-targetBackportedCustomfield">
                        <customfieldname>Targeted</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    </customfields>
    </item>
</channel>
</rss>