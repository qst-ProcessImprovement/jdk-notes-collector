<!-- 
RSS generated by JIRA (9.12.27#9120027-sha1:edc4490121e366e9e7bd2213d532dbe7e028fc5d) at Tue Sep 30 13:14:41 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>Java Bug System</title>
    <link>https://bugs.openjdk.org</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-us</language>    <build-info>
        <version>9.12.27</version>
        <build-number>9120027</build-number>
        <build-date>02-09-2025</build-date>
    </build-info>


<item>
            <title>[JDK-8335409] Can&apos;t allocate and retain memory from resource area in frame::oops_interpreted_do oop closure after 8329665</title>
                <link>https://bugs.openjdk.org/browse/JDK-8335409</link>
                <project id="10100" key="JDK">JDK</project>
                    <description>In &lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8329665&quot; title=&quot;fatal error: memory leak: allocating without ResourceMark&quot; class=&quot;issue-link&quot; data-issue-key=&quot;JDK-8329665&quot;&gt;&lt;strike&gt;JDK-8329665&lt;/strike&gt;&lt;/a&gt; a ResourceMark was added in frame::oops_interpreted_do() for the case of having to allocate extra memory for the _bit_mask in InterpreterOopMap::resource_copy(). But that prevents code in the closure from allocating and retaining memory from the resource area across the closure, relying on some ResourceMark in scope further up the stack from frame::oops_interpreted_do().&lt;br/&gt;
There is one case in JFR code where this kind of allocation happens: &lt;a href=&quot;https://github.com/openjdk/jdk/blob/d9bcf061450ebfb7fe02b5a50c855db1d9178e5d/src/hotspot/share/jfr/leakprofiler/checkpoint/objectSampleWriter.cpp#L462&quot;&gt;https://github.com/openjdk/jdk/blob/d9bcf061450ebfb7fe02b5a50c855db1d9178e5d/src/hotspot/share/jfr/leakprofiler/checkpoint/objectSampleWriter.cpp#L462&lt;/a&gt;. We allocate for the names of JavaThreads in the closure and then we later retrieve them after traversing all frames from all threads: &lt;a href=&quot;https://github.com/openjdk/jdk/blob/d9bcf061450ebfb7fe02b5a50c855db1d9178e5d/src/hotspot/share/jfr/leakprofiler/checkpoint/objectSampleWriter.cpp#L328&quot;&gt;https://github.com/openjdk/jdk/blob/d9bcf061450ebfb7fe02b5a50c855db1d9178e5d/src/hotspot/share/jfr/leakprofiler/checkpoint/objectSampleWriter.cpp#L328&lt;/a&gt;</description>
                <environment></environment>
        <key id="5133142">JDK-8335409</key>
            <summary>Can&apos;t allocate and retain memory from resource area in frame::oops_interpreted_do oop closure after 8329665</summary>
                <type id="1" iconUrl="https://bugs.openjdk.org/secure/viewavatar?size=xsmall&amp;avatarId=14703&amp;avatarType=issuetype">Bug</type>
                                            <priority id="2" iconUrl="https://bugs.openjdk.org/images/jbsImages/p2.png">P2</priority>
                        <status id="6" iconUrl="https://bugs.openjdk.org/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="success"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="pchilanomate">Patricio Chilano Mateo</assignee>
                                    <reporter username="pchilanomate">Patricio Chilano Mateo</reporter>
                        <labels>
                            <label>amazon-interest</label>
                            <label>hgupdate-sync</label>
                            <label>interpreter</label>
                            <label>jdk21u-fix-request</label>
                            <label>jdk21u-fix-yes</label>
                            <label>noreg-hard</label>
                            <label>redhat-interest</label>
                    </labels>
                <created>Mon, 1 Jul 2024 06:22:36 -0700</created>
                <updated>Fri, 13 Dec 2024 15:16:56 -0800</updated>
                            <resolved>Wed, 10 Jul 2024 13:08:56 -0700</resolved>
                                    <version>21.0.5</version>
                    <version>23</version>
                    <version>24</version>
                                    <fixVersion>24</fixVersion>
                                    <component>hotspot</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>7</watches>
                                                                                                                <comments>
                            <comment id="14700504" author="sgehwolf" created="Mon, 26 Aug 2024 02:01:12 -0700"  >Since &lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8329665&quot; title=&quot;fatal error: memory leak: allocating without ResourceMark&quot; class=&quot;issue-link&quot; data-issue-key=&quot;JDK-8329665&quot;&gt;&lt;strike&gt;JDK-8329665&lt;/strike&gt;&lt;/a&gt; is in OpenJDK 21.0.5, we should get this fix in there too.</comment>
                            <comment id="14700269" author="roboduke" created="Fri, 23 Aug 2024 03:38:59 -0700"  >[jdk21u-fix-request] Approval Request from Aleksey Shipil&amp;#xEB;v&lt;br/&gt;
This fixes the regression introduced by &lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8329665&quot; title=&quot;fatal error: memory leak: allocating without ResourceMark&quot; class=&quot;issue-link&quot; data-issue-key=&quot;JDK-8329665&quot;&gt;&lt;strike&gt;JDK-8329665&lt;/strike&gt;&lt;/a&gt;, which added ResourceMark in frame::oops_interpreted_do. Patch does not apply cleanly to jdk21u-dev, needs more adjustments, see PR. All tests pass. Risk is low-medium: touches a frequent path, was in mainline for 6 weeks, is being released in JDK 23 as well.</comment>
                            <comment id="14700037" author="roboduke" created="Thu, 22 Aug 2024 05:32:53 -0700"  >A pull request was submitted for review.&lt;br/&gt;
Branch: master&lt;br/&gt;
URL: &lt;a href=&quot;https://git.openjdk.org/jdk21u-dev/pull/942&quot;&gt;https://git.openjdk.org/jdk21u-dev/pull/942&lt;/a&gt;&lt;br/&gt;
Date: 2024-08-22 12:27:44 +0000</comment>
                            <comment id="14689882" author="roboduke" created="Mon, 15 Jul 2024 11:35:48 -0700"  >A pull request was submitted for review.&lt;br/&gt;
Branch: jdk23&lt;br/&gt;
URL: &lt;a href=&quot;https://git.openjdk.org/jdk/pull/20185&quot;&gt;https://git.openjdk.org/jdk/pull/20185&lt;/a&gt;&lt;br/&gt;
Date: 2024-07-15 18:13:53 +0000</comment>
                            <comment id="14688762" author="dukebot" created="Wed, 10 Jul 2024 13:08:49 -0700"  >Changeset: 7ab96c74&lt;br/&gt;
Branch: master&lt;br/&gt;
Author:    Patricio Chilano Mateo &amp;lt;&lt;a href=&apos;mailto:pchilanomate@openjdk.org&apos;&gt;pchilanomate@openjdk.org&lt;/a&gt;&amp;gt;&lt;br/&gt;
Date:      2024-07-10 16:26:16 +0000&lt;br/&gt;
URL:       &lt;a href=&quot;https://git.openjdk.org/jdk/commit/7ab96c74e2c39f430a5c2f65a981da7314a2385b&quot;&gt;https://git.openjdk.org/jdk/commit/7ab96c74e2c39f430a5c2f65a981da7314a2385b&lt;/a&gt;&lt;br/&gt;
</comment>
                            <comment id="14688004" author="pchilanomate" created="Mon, 8 Jul 2024 11:19:53 -0700"  >[~stuefe] I agree and see you already looked at the PR. I left the stack-allocated temp object in compute_one_oop_map() out of the PR though to minimize changes and just fix the bug, since this will need to be backported. This could be done in another RFE, although as I found out checking the callers this is mostly used by verification code so in terms of performance we won&amp;#39;t gain much.</comment>
                            <comment id="14687041" author="stuefe" created="Thu, 4 Jul 2024 01:45:01 -0700"  >[~pchilanomate] Many thanks for the thorough investigation.&lt;br/&gt;
&lt;br/&gt;
I think we should just use C-heap for the rare cases this is even needed. &lt;br/&gt;
&lt;br/&gt;
Side Note: I am not convinced that RA is always faster. In fact, I found cases where it is decidedly slower, because RA uses an internal chunk pool that uses synchronized access. If your allocation happens to need another chunk, you incur this cost. C-heap is now a lot better than 20 yrs ago in dealing with multithreaded access. &lt;br/&gt;
Funnily, a close RM will only make it worse, since you will play chunk-ping-pong with the chunk pool. I would love to just remove that pool and have a JBS issue for that open: &lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8333151&quot;&gt;https://bugs.openjdk.org/browse/JDK-8333151&lt;/a&gt; .&lt;br/&gt;
&lt;br/&gt;
What I&amp;#39;d do:&lt;br/&gt;
- use a stack-allocated temp object in compute_oop&lt;br/&gt;
- in copy_resource, always use C heap for copying&lt;br/&gt;
- possibly reuse an existing array if it already exists (but that would require keeping track of capacity as well as map length, so maybe its not worth the trouble&lt;br/&gt;
- delete it in dtor&lt;br/&gt;
&lt;br/&gt;
Does this make sense?</comment>
                            <comment id="14686867" author="roboduke" created="Wed, 3 Jul 2024 09:44:12 -0700"  >A pull request was submitted for review.&lt;br/&gt;
Branch: master&lt;br/&gt;
URL: &lt;a href=&quot;https://git.openjdk.org/jdk/pull/20012&quot;&gt;https://git.openjdk.org/jdk/pull/20012&lt;/a&gt;&lt;br/&gt;
Date: 2024-07-03 16:24:20 +0000</comment>
                            <comment id="14686828" author="pchilanomate" created="Wed, 3 Jul 2024 08:00:21 -0700"  >[~stuefe] I also did a bit of research on the comment in OopMapCache::compute_one_oop_map about being tricky to allocate OopMapCacheEntry in the stack. This code was introduce in 2004. I&amp;#39;m guessing this was about deallocating the _bit_mask if it was indeed allocated in the C heap. But we could had ~OopMapCacheEntry check for that and deallocate. Since we will have ~InterpreterOopMap do that now anyways, we won&amp;#39;t even need to do that. In any case, we call OopMapCache::compute_one_oop_map() when we don&amp;#39;t want to use the cache, and checking the callers, except for ciMethod::live_local_oops_at_bci(), one caller is frame::describe() and all others I can see are part of verification code. So I don&amp;#39;t think this would make much difference.</comment>
                            <comment id="14686810" author="pchilanomate" created="Wed, 3 Jul 2024 07:15:20 -0700"  >I dig up the history of why in case of having to allocate extra space for the _bit_mask we use the resource area, and in particular of the comment about performance (&lt;a href=&quot;https://github.com/openjdk/jdk/blob/d51141e5fc84f9f933e78d0eb25af86e41798ad5/src/hotspot/share/interpreter/oopMapCache.cpp#L426&quot;&gt;https://github.com/openjdk/jdk/blob/d51141e5fc84f9f933e78d0eb25af86e41798ad5/src/hotspot/share/interpreter/oopMapCache.cpp#L426&lt;/a&gt;).&lt;br/&gt;
The allocation of the _bit_mask in the resource area dates back to a changeset in 2002. Before that, it was allocated in the C heap. Now, back then 32 bits processors were still common. Also the N in InterpreterOopMap was defined as 2 (it was later changed to 4 in &lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8013942&quot; title=&quot;JSR 292: assert(type() == T_OBJECT) failed: type check&quot; class=&quot;issue-link&quot; data-issue-key=&quot;JDK-8013942&quot;&gt;&lt;strike&gt;JDK-8013942&lt;/strike&gt;&lt;/a&gt; in 2014). That means the total number of locals/expression stack entries we could have without allocating extra memory was only 32. So it wasn&amp;#39;t, as today, that uncommon to have that allocation. Plus malloc performance was likely much worse back then, so avoiding to allocate in the C heap made more sense. But today, besides of improvements in malloc/free performance, the number of locals/expression stack entries we can have before having to allocate is 128. This is already big enough that we almost never have to allocate. A test run through mach5 tiers1-6 shows only a handful of methods (~ less than 10) that fall into this case, and most are artificial ones created to trigger this condition. So moving the allocation back to the C heap shouldn&amp;#39;t have any performance penalty.&lt;br/&gt;
&lt;br/&gt;
We have two classes: InterpreterOopMap and OopMapCacheEntry(which inherits from InterpreterOopMap). OopMapCacheEntry entries are the ones we add to the OopMapCache, i.e are long-lived, and thus we always allocate extra space for the _bit_mask in the C-heap for those. InterpreterOopMap are not added to the OopMapCache and are short-lived, and for those we allocate in the resource area instead. I played a little bit with the code and we could even make InterpreterOopMap a template on N if we wanted. So that OopMapCacheEntry keeps using the current size (4), and InterpreterOopMap uses a bigger number to reduce even more the probability of having to allocate. But I think this is not worthy given that with the current value of N the likelihood of having to allocate is very low already.&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
Another interesting thing is that shortly after the mentioned commit(2 months difference) a new one added among other things the following code in resource_copy:&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// The expectation is that this InterpreterOopMap is a recently created&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// and empty. It is used to get a copy of a cached entry.&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// If the bit mask has a value, it should be in the&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// resource area.&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;assert(_bit_mask[0] == 0 ||&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Thread::current()-&amp;gt;resource_area()-&amp;gt;contains((void*)_bit_mask[0]),&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;quot;The bit mask should have been allocated from a resource area&amp;quot;);&lt;br/&gt;
&lt;br/&gt;
On one hand the comment says that this object is expected to be empty. But the assert considers that it might not be. Now, we don&amp;#39;t have cases where an InterpreterOopMap object is used more than once, but even if we had the assert looks wrong. Considering the following pattern:&lt;br/&gt;
&lt;br/&gt;
InterpreterOopMap mask;&lt;br/&gt;
OopMapCache::compute_one_oop_map(method1, bci1, &amp;amp;mask);&lt;br/&gt;
// use mask&lt;br/&gt;
OopMapCache::compute_one_oop_map(method2, bci2, &amp;amp;mask);&lt;br/&gt;
// use mask&lt;br/&gt;
&lt;br/&gt;
When we call compute_one_oop_map the second time, the _bit_mask will be set but will not necessarily contain a pointer to memory in the resource area, and it most likely won&amp;#39;t. </comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10200">
                    <name>Backport</name>
                                            <outwardlinks description="backported by">
                                        <issuelink>
            <issuekey id="5133307">JDK-8335557</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="5135370">JDK-8337373</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="5136235">JDK-8337920</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="5137601">JDK-8339073</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="5141373">JDK-8342093</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                            <issuelinktype id="10003">
                    <name>Relates</name>
                                            <outwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="5126182">JDK-8329665</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                    </issuelinks>
                <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_11700" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_10600" key="com.oracle.jira.javabugsystem-jira-plugin:jbs-fixedBackportedCustomfield">
                        <customfieldname>Fixed</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_11100" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i36ynv:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_11004" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10006" key="com.atlassian.jira.plugin.system.customfieldtypes:select">
                        <customfieldname>Resolved In Build</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="17334"><![CDATA[b06]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10008" key="com.oracle.jira.jira-subcomponent-plugin:oracle-subComponentField">
                        <customfieldname>Subcomponent</customfieldname>
                        <customfieldvalues>
                             <customfieldvalue key="192"><![CDATA[runtime]]></customfieldvalue> 
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_10601" key="com.oracle.jira.javabugsystem-jira-plugin:jbs-targetBackportedCustomfield">
                        <customfieldname>Targeted</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_10100" key="com.atlassian.jira.plugin.system.customfieldtypes:radiobuttons">
                        <customfieldname>Verification</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="17001"><![CDATA[Not verified]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                </customfields>
    </item>
</channel>
</rss>