<!-- 
RSS generated by JIRA (9.12.27#9120027-sha1:edc4490121e366e9e7bd2213d532dbe7e028fc5d) at Tue Sep 30 10:25:52 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>Java Bug System</title>
    <link>https://bugs.openjdk.org</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-us</language>    <build-info>
        <version>9.12.27</version>
        <build-number>9120027</build-number>
        <build-date>02-09-2025</build-date>
    </build-info>


<item>
            <title>[JDK-8316746] Top of lock-stack does not match the unlocked object</title>
                <link>https://bugs.openjdk.org/browse/JDK-8316746</link>
                <project id="10100" key="JDK">JDK</project>
                    <description>One additional object sometimes appears on the lock stack while running test &amp;quot;vmTestbase/nsk/jdi/StepEvent/_itself_/stepEvent004/stepEvent004.java&amp;quot;:&lt;br/&gt;
&lt;br/&gt;
LockStack[1]: nsk.share.jdi.EventHandler &lt;br/&gt;
{0x00000000bcc102b8} - klass: &amp;#39;nsk/share/jdi/EventHandler&amp;#39;&lt;br/&gt;
&amp;nbsp;- ---- fields (total size 5 words):&lt;br/&gt;
&amp;nbsp;- private volatile &amp;#39;wasInterrupted&amp;#39; &amp;#39;Z&amp;#39; @12  false (0x00)&lt;br/&gt;
&amp;nbsp;- private &amp;#39;debuggee&amp;#39; &amp;#39;Lnsk/share/jdi/Debugee;&amp;#39; @16  a &amp;#39;nsk/share/jdi/LocalLaunchedDebugee&amp;#39;{0x00000000bcb697f8} (0xbcb697f8)&lt;br/&gt;
&amp;nbsp;- private &amp;#39;log&amp;#39; &amp;#39;Lnsk/share/Log;&amp;#39; @20  a &amp;#39;nsk/share/Log&amp;#39;{0x00000000bcc7e538} (0xbcc7e538)&lt;br/&gt;
&amp;nbsp;- private &amp;#39;vm&amp;#39; &amp;#39;Lcom/sun/jdi/VirtualMachine;&amp;#39; @24  a &amp;#39;com/sun/tools/jdi/VirtualMachineImpl&amp;#39;{0x00000000bccc2d78} (0xbccc2d78)&lt;br/&gt;
&amp;nbsp;- private &amp;#39;requestManager&amp;#39; &amp;#39;Lcom/sun/jdi/request/EventRequestManager;&amp;#39; @28  a &amp;#39;com/sun/tools/jdi/EventRequestManagerImpl&amp;#39;{0x00000000bccc43c8} (0xbccc43c8)&lt;br/&gt;
&amp;nbsp;- private &amp;#39;listenThread&amp;#39; &amp;#39;Ljava/lang/Thread;&amp;#39; @32  a &amp;#39;java/lang/Thread&amp;#39;{0x00000000bcc101a0} (0xbcc101a0)&lt;br/&gt;
LockStack[0]: java.util.Collections$SynchronizedRandomAccessList &lt;br/&gt;
{0x00000000bca24b60} - klass: &amp;#39;java/util/Collections$SynchronizedRandomAccessList&amp;#39;&lt;br/&gt;
&amp;nbsp;- ---- fields (total size 3 words):&lt;br/&gt;
&amp;nbsp;- final &amp;#39;c&amp;#39; &amp;#39;Ljava/util/Collection;&amp;#39; @12  a &amp;#39;java/util/Vector&amp;#39;{0x00000000bca24b78} (0xbca24b78)&lt;br/&gt;
&amp;nbsp;- final &amp;#39;mutex&amp;#39; &amp;#39;Ljava/lang/Object;&amp;#39; @16  a &amp;#39;java/util/Collections$SynchronizedRandomAccessList&amp;#39;{0x00000000bca24b60} (0xbca24b60)&lt;br/&gt;
&amp;nbsp;- final &amp;#39;list&amp;#39; &amp;#39;Ljava/util/List;&amp;#39; @20  a &amp;#39;java/util/Vector&amp;#39;{0x00000000bca24b78} (0xbca24b78)&lt;br/&gt;
&lt;br/&gt;
The obj at LockStack[0] is the one which is expected by the unlocking code in the C2 method:&lt;br/&gt;
J 1490% c2 nsk.share.jdi.EventHandler.run()V (475 bytes) @ 0x00007fff7c67139c [0x00007fff7c670f80+0x000000000000041c]&lt;br/&gt;
j  java.lang.Thread.runWith(Ljava/lang/Object;Ljava/lang/Runnable;)V+5 &lt;a href=&apos;mailto:java.base@22-internal&apos;&gt;java.base@22-internal&lt;/a&gt;&lt;br/&gt;
j  java.lang.Thread.run()V+19 &lt;a href=&apos;mailto:java.base@22-internal&apos;&gt;java.base@22-internal&lt;/a&gt;&lt;br/&gt;
v  ~StubRoutines::call_stub 0x00007fff7bdc084c&lt;br/&gt;
&lt;br/&gt;
Observed on linuxppc64le so far (intermittently). Other platforms may be affected, but were not observed, yet. Seems like there are at least similar or related problems (linked to &lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8315880&quot; title=&quot;Change LockingMode default from LM_LEGACY to LM_LIGHTWEIGHT&quot; class=&quot;issue-link&quot; data-issue-key=&quot;JDK-8315880&quot;&gt;&lt;strike&gt;JDK-8315880&lt;/strike&gt;&lt;/a&gt;).&lt;br/&gt;
&lt;br/&gt;
The platform code for all platforms only supports removing the top of the lock stack. In contrast, ObjectSynchronizer::exit calls LockStack::remove which is able to remove any object.&lt;br/&gt;
&lt;br/&gt;
The issue does no longer show up when using the slow path instead of stop(&amp;quot;Top of lock-stack does not match the unlocked object&amp;quot;).</description>
                <environment></environment>
        <key id="5110854">JDK-8316746</key>
            <summary>Top of lock-stack does not match the unlocked object</summary>
                <type id="1" iconUrl="https://bugs.openjdk.org/secure/viewavatar?size=xsmall&amp;avatarId=14703&amp;avatarType=issuetype">Bug</type>
                                            <priority id="2" iconUrl="https://bugs.openjdk.org/images/jbsImages/p2.png">P2</priority>
                        <status id="6" iconUrl="https://bugs.openjdk.org/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="success"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="mdoerr">Martin Doerr</assignee>
                                    <reporter username="mdoerr">Martin Doerr</reporter>
                        <labels>
                            <label>LM_LIGHTWEIGHT</label>
                            <label>amazon-interest</label>
                            <label>c2</label>
                            <label>intermittent</label>
                            <label>jdk11u-fix-request</label>
                            <label>jdk11u-fix-yes</label>
                            <label>jdk17u-fix-request</label>
                            <label>jdk17u-fix-yes</label>
                            <label>jdk21u-fix-SQE-ok</label>
                            <label>jdk21u-fix-request</label>
                            <label>jdk21u-fix-yes</label>
                            <label>lilliput</label>
                            <label>sync</label>
                            <label>tier4</label>
                    </labels>
                <created>Fri, 22 Sep 2023 08:10:49 -0700</created>
                <updated>Tue, 2 Jan 2024 17:23:54 -0800</updated>
                            <resolved>Thu, 9 Nov 2023 02:15:14 -0800</resolved>
                                    <version>21</version>
                    <version>22</version>
                    <version>repo-lilliput-17</version>
                                    <fixVersion>22</fixVersion>
                                    <component>hotspot</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>13</watches>
                                                                                                                <comments>
                            <comment id="14628632" author="roboduke" created="Thu, 23 Nov 2023 02:50:17 -0800"  >[jdk11u-fix-request] Approval Request from Martin&lt;br/&gt;
C2 OSR compiled methods are wrong on PPC64 in very rare cases without this fix (wrong unlock order). This gets currently only detected by the new lightweight locking, but the bug exists independently. The fix has been tested in jdk head, jdk 21u and the backport in jdk 17u-dev and jdk 11u-dev in our nightly tests. The version for 11 is almost identical to the version for 17 and has been reviewed.</comment>
                            <comment id="14628190" author="roboduke" created="Tue, 21 Nov 2023 09:34:58 -0800"  >A pull request was submitted for review.&lt;br/&gt;
URL: &lt;a href=&quot;https://git.openjdk.org/jdk11u-dev/pull/2288&quot;&gt;https://git.openjdk.org/jdk11u-dev/pull/2288&lt;/a&gt;&lt;br/&gt;
Date: 2023-11-21 17:28:48 +0000</comment>
                            <comment id="14628151" author="roboduke" created="Tue, 21 Nov 2023 07:45:38 -0800"  >[jdk17u-fix-request] Approval Request from Martin&lt;br/&gt;
C2 OSR compiled methods are wrong on PPC64 in very rare cases without this fix (wrong unlock order). This gets currently only detected by the new lightweight locking, but the bug exists independently. The fix has been tested in jdk head, jdk 21u and this backport in jdk 17u-dev in our nightly tests.</comment>
                            <comment id="14627675" author="roboduke" created="Mon, 20 Nov 2023 08:58:43 -0800"  >A pull request was submitted for review.&lt;br/&gt;
URL: &lt;a href=&quot;https://git.openjdk.org/jdk17u-dev/pull/1977&quot;&gt;https://git.openjdk.org/jdk17u-dev/pull/1977&lt;/a&gt;&lt;br/&gt;
Date: 2023-11-20 16:51:57 +0000</comment>
                            <comment id="14626499" author="roboduke" created="Wed, 15 Nov 2023 00:56:23 -0800"  >[jdk21u-fix-request] Approval Request from Martin&lt;br/&gt;
C2 OSR compiled methods are wrong on PPC64 in very rare cases without this fix (wrong unlock order). The fix applies cleanly and has been tested in jdk head and this backport in jdk 21u in our nightly tests. It only changes PPC64 code, removes wrong comments from some other platforms and adds a test which passes on all platforms.</comment>
                            <comment id="14626179" author="roboduke" created="Tue, 14 Nov 2023 06:56:46 -0800"  >A pull request was submitted for review.&lt;br/&gt;
URL: &lt;a href=&quot;https://git.openjdk.org/jdk21u/pull/361&quot;&gt;https://git.openjdk.org/jdk21u/pull/361&lt;/a&gt;&lt;br/&gt;
Date: 2023-11-14 14:46:40 +0000</comment>
                            <comment id="14625163" author="dukebot" created="Thu, 9 Nov 2023 02:15:13 -0800"  >Changeset: 7d8adfa8&lt;br/&gt;
Author:    Martin Doerr &amp;lt;&lt;a href=&apos;mailto:mdoerr@openjdk.org&apos;&gt;mdoerr@openjdk.org&lt;/a&gt;&amp;gt;&lt;br/&gt;
Date:      2023-11-09 10:14:03 +0000&lt;br/&gt;
URL:       &lt;a href=&quot;https://git.openjdk.org/jdk/commit/7d8adfa855e51a90c2f125fc20a06f9a488e6248&quot;&gt;https://git.openjdk.org/jdk/commit/7d8adfa855e51a90c2f125fc20a06f9a488e6248&lt;/a&gt;&lt;br/&gt;
</comment>
                            <comment id="14624999" author="dcubed" created="Wed, 8 Nov 2023 11:31:48 -0800"  >[~mdoerr] - The description note for this bug still says this:&lt;br/&gt;
&lt;br/&gt;
&amp;gt; Observed on linuxppc64le so far (intermittently). Other platforms may be affected, but were not&lt;br/&gt;
&amp;gt; observed, yet. Seems like there are at least similar or related problems (linked to &lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8315880&quot; title=&quot;Change LockingMode default from LM_LEGACY to LM_LIGHTWEIGHT&quot; class=&quot;issue-link&quot; data-issue-key=&quot;JDK-8315880&quot;&gt;&lt;strike&gt;JDK-8315880&lt;/strike&gt;&lt;/a&gt;).&lt;br/&gt;
&lt;br/&gt;
You may want to add an &amp;quot;Update: XXX&amp;quot; note to the description to make it clear&lt;br/&gt;
that this has turned out to be a PPC64 only bug...&lt;br/&gt;
&lt;br/&gt;
Also, thanks for clearing out the errant comments on all the other platforms.</comment>
                            <comment id="14621772" author="roboduke" created="Fri, 27 Oct 2023 12:31:29 -0700"  >A pull request was submitted for review.&lt;br/&gt;
URL: &lt;a href=&quot;https://git.openjdk.org/jdk/pull/16406&quot;&gt;https://git.openjdk.org/jdk/pull/16406&lt;/a&gt;&lt;br/&gt;
Date: 2023-10-27 19:26:54 +0000</comment>
                            <comment id="14621458" author="mdoerr" created="Thu, 26 Oct 2023 13:37:58 -0700"  >I&amp;#39;ve updated the reproducer. Fails only on PPC64. I&amp;#39;ll look into the interpreter.</comment>
                            <comment id="14620929" author="mdoerr" created="Wed, 25 Oct 2023 02:44:34 -0700"  >This PR shows a possible solution, but is not yet complete. I the long term, C2 should be able to run without usage of BoxLock nodes (except for LM_LEGACY).</comment>
                            <comment id="14620573" author="roboduke" created="Tue, 24 Oct 2023 05:26:59 -0700"  >A pull request was submitted for review.&lt;br/&gt;
URL: &lt;a href=&quot;https://git.openjdk.org/jdk/pull/16345&quot;&gt;https://git.openjdk.org/jdk/pull/16345&lt;/a&gt;&lt;br/&gt;
Date: 2023-10-24 12:19:04 +0000</comment>
                            <comment id="14620190" author="mdoerr" created="Mon, 23 Oct 2023 07:50:01 -0700"  >I have a synthetic reproducer:&lt;br/&gt;
- Apply &lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8316746&quot; title=&quot;Top of lock-stack does not match the unlocked object&quot; class=&quot;issue-link&quot; data-issue-key=&quot;JDK-8316746&quot;&gt;&lt;strike&gt;JDK-8316746&lt;/strike&gt;&lt;/a&gt;-reproducer.patch (attached)&lt;br/&gt;
- make run-test TEST=&amp;quot;vmTestbase/nsk/jdi/StepEvent&amp;quot; JTREG=&amp;quot;VM_OPTIONS=-Xbatch&amp;quot;&lt;br/&gt;
&lt;br/&gt;
Note: Only shows that the lock order is not as C2 needs it.&lt;br/&gt;
&lt;br/&gt;
I still don&amp;#39;t know how the monitor order in interpreter frames can be guaranteed. I understand that the bytecode is checked by ciMethod::has_balanced_monitors(), but the actual values in the interpreter frame may be modified when we reach the OSR entry.</comment>
                            <comment id="14615081" author="dlong" created="Fri, 29 Sep 2023 20:16:32 -0700"  >In the PR [~mdoerr] showed how C2 is reversing the order.  I checked C1 and it looks correct, and comments in the code confirm the correct order:&lt;br/&gt;
&lt;br/&gt;
3217    // Similarly with locks. The first lock slot in the osr buffer is the nth lock&lt;br/&gt;
3218    // from the interpreter frame, the nth lock slot in the osr buffer is 0th lock&lt;br/&gt;
3219    // in the interpreter frame (the method lock if a sync method)&lt;br/&gt;
</comment>
                            <comment id="14615059" author="dlong" created="Fri, 29 Sep 2023 13:16:35 -0700"  >I don&amp;#39;t see anything wrong with Parse::load_interpreter_state or how it could do anything different.  It trusts the order it was given from SharedRuntime::OSR_migration_begin, which also seems to be correctly preserving the order from the interpreter frame.</comment>
                            <comment id="14615023" author="mdoerr" created="Fri, 29 Sep 2023 09:49:01 -0700"  >AFAICS C2 doesn&amp;#39;t reorder, but transfer them incorrectly from the interpreter state (Parse::load_interpreter_state) when doing OSR compilation.&lt;br/&gt;
At least the test passes and I couldn&amp;#39;t see any other problem when changing the order there (see comment in PR).&lt;br/&gt;
I was also wondering if jdi/StepEvent somehow messes with the locks, but haven&amp;#39;t found anything, yet.</comment>
                            <comment id="14614859" author="dholmes" created="Thu, 28 Sep 2023 18:23:11 -0700"  >C2 should never reorder unlocks! That would be very broken.</comment>
                            <comment id="14614757" author="rkennke" created="Thu, 28 Sep 2023 09:33:39 -0700"  >It makes me wonder if there is an ordering dependency missing somewhere in the resulting ideal graph, or why else would C2 emit the unlocks in wrong order?</comment>
                            <comment id="14614754" author="rkennke" created="Thu, 28 Sep 2023 09:30:42 -0700"  >Very interesting! Yes, fixing that problem at its root would be best! Thanks for the investigation!</comment>
                            <comment id="14614751" author="mdoerr" created="Thu, 28 Sep 2023 09:19:29 -0700"  >After more investigation, I figured out that the JIT compilers reject methods with unbalanced locks even for OSR (with a conservative approach: if they can&amp;#39;t prove that they are balanced, ciMethod -&amp;gt;has_balanced_monitors()): COMPILE SKIPPED: cannot parse method: not compilable (unbalanced monitors)&lt;br/&gt;
So, seems like you&amp;#39;re right. If so, we should also be able to fix the problem by restoring the correct order in Parse::load_interpreter_state when transferring the locks from the interpreter.</comment>
                            <comment id="14614671" author="mdoerr" created="Thu, 28 Sep 2023 05:22:17 -0700"  >I&amp;#39;ve updated my PR to allow reordering for OSR compilations only. (Currently only for PPC64, but I&amp;#39;ll work on x86_64 and aarch64, too.) Please take a look.</comment>
                            <comment id="14614664" author="rkennke" created="Thu, 28 Sep 2023 05:17:21 -0700"  >Ok, so remove all the checks, maybe add a comment in their places, and that should fix the problem?&lt;br/&gt;
</comment>
                            <comment id="14614656" author="mdoerr" created="Thu, 28 Sep 2023 05:02:49 -0700"  >How should a JIT compiler know when doing OSR? It doesn&amp;#39;t even parse the parts which contain the monitorenter instructions if they happen before the OSR entry point. And it can&amp;#39;t know the path which has been taken to reach the OSR entry point.&lt;br/&gt;
Other locking modes don&amp;#39;t care about the order and that&amp;#39;s why it simply works. So, I guess it&amp;#39;s a pre-existing problem which could get ignored without the new lightweight locking.</comment>
                            <comment id="14614625" author="rkennke" created="Thu, 28 Sep 2023 03:00:20 -0700"  >I&amp;#39;m pretty sure that the JIT compilers should not emit unlocks in the wrong order. If that really happens, then it has nothing to do with lightweight locking and would be a pre-existing problem. Also, I would definitely expect that it would show up on other arches and with the old stack-locking too. That said, I guess there is a chance that old stack-locking would work by chance, simply because it does not check the order (this could be verified by adding such a check, I suppose). If that really is the case, I suppose we could remove the check as well. It would be ugly, though.</comment>
                            <comment id="14614621" author="mdoerr" created="Thu, 28 Sep 2023 02:46:19 -0700"  >C2 OSR: The locks are transferred from the interpreter state in Parse::load_interpreter_state. They have no guaranteed order.&lt;br/&gt;
&lt;br/&gt;
I believe it is generally possible to break the invariant with jasm, too:&lt;br/&gt;
- lock a&lt;br/&gt;
- lock b&lt;br/&gt;
- loop which triggers OSR&lt;br/&gt;
- unlock a&lt;br/&gt;
- unlock b&lt;br/&gt;
&lt;br/&gt;
I think extending &lt;a href=&quot;https://github.com/rkennke/jdk/blob/3f0acba4305cd1e8741586bbb0131cea26e1d10d/test/hotspot/jtreg/runtime/locking/TestUnstructuredLocking.jasm&quot;&gt;https://github.com/rkennke/jdk/blob/3f0acba4305cd1e8741586bbb0131cea26e1d10d/test/hotspot/jtreg/runtime/locking/TestUnstructuredLocking.jasm&lt;/a&gt; like this would be an interesting experiment.&lt;br/&gt;
</comment>
                            <comment id="14614304" author="mdoerr" created="Wed, 27 Sep 2023 03:15:25 -0700"  >I&#8217;ve attached an hs_err file with the disassembled OSR c2 nmethod nsk.share.jdi.EventHandler.run()V.&lt;br/&gt;
I can see two unlock sequences:&lt;br/&gt;
0x00007fff706bda8c: The asm assertion which fires belongs to this one. It tries to unlock object from R18 which is Collections$SynchronizedRandomAccessList. I think it should unlock the EventHandler (see my previous comment).&lt;br/&gt;
0x00007fff706bdb88: Next unlock follows immediately. I think this one should actually unlock the Collections$SynchronizedRandomAccessList object.&lt;br/&gt;
&lt;br/&gt;
Do you know how &amp;quot;strictly nested balanced locking&amp;quot; is ensured for OSR methods? Note that, in general, the interpreter can lock objects which get unlocked in the compiled part of the method.&lt;br/&gt;
&lt;br/&gt;
About CR0 usage: We have changed the locking/unlocking to use only CR0 when implementing the new lightweight locking. The lock/unlock functions still support using other Condition Registers for other locking modes, but that is no longer needed. We want to clean this up when removing support for the old fast locking. It&#8217;s a bit confusing, now. I agree. Note that instructions with &amp;quot;_&amp;quot; suffix (&amp;quot;.&amp;quot; suffix in disassembled code) set CR0.&lt;br/&gt;
&lt;br/&gt;
I&amp;#39;ll try to reproduce it and dump IR graphs when I find more time. That might shed more light into the problem.</comment>
                            <comment id="14614175" author="rkennke" created="Tue, 26 Sep 2023 13:11:18 -0700"  >Can you check the C2 generated code and see the wrong ordering there, too?&lt;br/&gt;
&lt;br/&gt;
If this were a C2 bug, it would certainly show up in other arches too. As long as I don&amp;#39;t see evidence of that, I&amp;#39;m assuming it&amp;#39;s a PPC specific problem. I&amp;#39;ve never seen C2 reorder locks that way.&lt;br/&gt;
&lt;br/&gt;
If I were you, I&amp;#39;d check if every way out of the C2 generated lock and unlock nodes has its condition flags transferred correctly. If the locking or unlocking encounters a failure, but publishes EQ/zero condition flag on the way out, the surrounding code would not call into the runtime to fix it, and leave the object on the stack. I&amp;#39;ve had this symptom a couple of times when I got the conditions wrong. I find the PPC asm code confusing because sometimes it seems to use CCR0 directly, other times it doesn&amp;#39;t (e.g. does the CAS also use/update CCR0?). Also, the MacroAssembler::lightweight_(un)lock() routines seem to implicitely use CCR0, but it&amp;#39;s not passed into them as argument, etc. It&amp;#39;s all not very clear to me.</comment>
                            <comment id="14614169" author="mdoerr" created="Tue, 26 Sep 2023 12:43:25 -0700"  >Thanks for your explanation, Roman!&lt;br/&gt;
About sharedRuntime_ppc.cpp: PPC64 (and s390) use compiler_fast_lock_object (and _unlock_) in shared runtime. So, they reuse the code from C2 which contains the lightweight locking. That looks all correct to me, now.&lt;br/&gt;
&lt;br/&gt;
I&amp;#39;ve taken a closer look at the C2 compiled OSR nmethod: nsk.share.jdi.EventHandler.run()&lt;br/&gt;
It tries to unlock in the wrong order. This is what should happen (in this order):&lt;br/&gt;
EventHandler.java:193 Should unlock EventHandler&lt;br/&gt;
EventHandler.java:194 Should unlock Collections$SynchronizedRandomAccessList&lt;br/&gt;
&lt;br/&gt;
I guess that the &amp;quot;strictly nested balanced locking&amp;quot; is only checked during parsing. However, it seems to be possible that they get reordered somehow. We hit the assert because the nmethod tries to unlock the second one first. Could this be a C2 bug?</comment>
                            <comment id="14614152" author="mseledtsov" created="Tue, 26 Sep 2023 11:15:22 -0700"  >ILW = HML = P2</comment>
                            <comment id="14614037" author="rkennke" created="Tue, 26 Sep 2023 03:22:19 -0700"  >BTW, in the PPC implementation:&lt;br/&gt;
&lt;a href=&quot;https://github.com/openjdk/jdk/pull/14069&quot;&gt;https://github.com/openjdk/jdk/pull/14069&lt;/a&gt;&lt;br/&gt;
&lt;br/&gt;
I don&amp;#39;t see a change to locking in sharedRuntime_ppc.cpp, which matches other arches:&lt;br/&gt;
&lt;a href=&quot;https://github.com/openjdk/jdk/pull/10907/files#diff-524c9e019cb83916aa3db772fb33acbbe3e7465867a8d2f7e6376be3c8260edd&quot;&gt;https://github.com/openjdk/jdk/pull/10907/files#diff-524c9e019cb83916aa3db772fb33acbbe3e7465867a8d2f7e6376be3c8260edd&lt;/a&gt;&lt;br/&gt;
&lt;br/&gt;
Is it not necessary to deal with sync&amp;#39;ed native methods in PPC?</comment>
                            <comment id="14613990" author="rkennke" created="Tue, 26 Sep 2023 01:02:28 -0700"  >C2 (and C1) enforces strictly nested balanced locking. Bytecode that does otherwise will be rejected and not compiled at all (doesn&amp;#39;t happen with javac compiled code, afaik). The spec allows for more relaxed locking bytecode, which is why we check for TOS being different than the unlocked object in the interpreter, and dive into runtime to handle it there, and this is why we have the LockStack::remove() there, instead of simple pop(). As I said, javac doesn&amp;#39;t produce such bytecode, but I have constructed a jtreg testcase which tests that situation, but I just realized that this test hasn&amp;#39;t made it into the final PR: &lt;a href=&quot;https://github.com/rkennke/jdk/blob/3f0acba4305cd1e8741586bbb0131cea26e1d10d/test/hotspot/jtreg/runtime/locking/TestUnstructuredLocking.jasm&quot;&gt;https://github.com/rkennke/jdk/blob/3f0acba4305cd1e8741586bbb0131cea26e1d10d/test/hotspot/jtreg/runtime/locking/TestUnstructuredLocking.jasm&lt;/a&gt;&lt;br/&gt;
&lt;br/&gt;
It might be worth to add it now.</comment>
                            <comment id="14613960" author="dholmes" created="Mon, 25 Sep 2023 23:44:54 -0700"  >Does C2 enforce strictly nested balanced locking i.e. only methods that unlock in the reverse order of locking are compiled? In general the locks/unlocks in a method must be balanced, but they can occur out-of-order (lock A, lock B, unlock A, unlock B) - hence the general unlock case does a remove() not a pop().</comment>
                            <comment id="14613893" author="mdoerr" created="Mon, 25 Sep 2023 13:57:24 -0700"  >The issue can be reproduced with the code which handles ANONYMOUS_OWNER in the C2 monitor unlocking code. That is not the problem. I&amp;#39;m convinced that the slow path handles that correctly.&lt;br/&gt;
The issue only occurs in jdi tests. Seems like they are able to break the invariant that always the top of stack gets unlocked.&lt;br/&gt;
&lt;br/&gt;
Do you know why the slow path uses LockStack::remove (instead of pop) which is able to unlock any object from the stack? Seems like similar problems were resolved there, but not in the fast unlock code.&lt;br/&gt;
</comment>
                            <comment id="14613889" author="mdoerr" created="Mon, 25 Sep 2023 13:18:38 -0700"  >The PPC64 implementation jumps to the slow path if the owner is ANONYMOUS_OWNER because ANONYMOUS_OWNER never matches the current thread. Does the slow path not handle that? Is it required to do it in assembler code?&lt;br/&gt;
I already had code to handle it, but during review it was suggested to remove it: &lt;a href=&quot;https://github.com/openjdk/jdk/pull/14069/commits/8b4c8370c9b953ccee1036c97afa80a1621ae199&quot;&gt;https://github.com/openjdk/jdk/pull/14069/commits/8b4c8370c9b953ccee1036c97afa80a1621ae199&lt;/a&gt; I&amp;#39;ll add it back and try to reproduce the issue.</comment>
                            <comment id="14613646" author="rkennke" created="Mon, 25 Sep 2023 07:19:03 -0700"  >The code-path that handles anonymous owners looks different in PPC vs other aarches. I am not too familiar with PPC asm, but it doesn&amp;#39;t look obviously correct to me. Compare:&lt;br/&gt;
&amp;nbsp;&lt;a href=&quot;https://github.com/openjdk/jdk/blob/0f77d250b67ae0678756f986607eb239641dfb9e/src/hotspot/cpu/aarch64/c2_MacroAssembler_aarch64.cpp#L199&quot;&gt;https://github.com/openjdk/jdk/blob/0f77d250b67ae0678756f986607eb239641dfb9e/src/hotspot/cpu/aarch64/c2_MacroAssembler_aarch64.cpp#L199&lt;/a&gt;&lt;br/&gt;
&lt;br/&gt;
vs.&lt;br/&gt;
&lt;br/&gt;
&lt;a href=&quot;https://github.com/openjdk/jdk/blob/0f77d250b67ae0678756f986607eb239641dfb9e/src/hotspot/cpu/ppc/macroAssembler_ppc.cpp#L2347&quot;&gt;https://github.com/openjdk/jdk/blob/0f77d250b67ae0678756f986607eb239641dfb9e/src/hotspot/cpu/ppc/macroAssembler_ppc.cpp#L2347&lt;/a&gt;&lt;br/&gt;
&lt;br/&gt;
In particular, I don&amp;#39;t see the PPC equivalent of the actual ANONYMOUS_OWNER test which should look like&lt;br/&gt;
tst(tmp2, (uint64_t)ObjectMonitor::ANONYMOUS_OWNER);&lt;br/&gt;
&lt;br/&gt;
IOW, I would expect some sort of test or and instructions with ANONYMOUS_OWNER in it somewhere.</comment>
                            <comment id="14613643" author="roboduke" created="Mon, 25 Sep 2023 07:03:42 -0700"  >A pull request was submitted for review.&lt;br/&gt;
URL: &lt;a href=&quot;https://git.openjdk.org/jdk/pull/15903&quot;&gt;https://git.openjdk.org/jdk/pull/15903&lt;/a&gt;&lt;br/&gt;
Date: 2023-09-25 13:57:26 +0000</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10200">
                    <name>Backport</name>
                                            <outwardlinks description="backported by">
                                        <issuelink>
            <issuekey id="5115276">JDK-8320593</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="5115463">JDK-8320748</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="5115090">JDK-8320422</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                            <issuelinktype id="10003">
                    <name>Relates</name>
                                            <outwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="5080595">JDK-8291555</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="5101377">JDK-8308469</issuekey>
        </issuelink>
                            </outwardlinks>
                                                                <inwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="5109863">JDK-8315880</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="106910" name="JDK-8316746-reproducer-1.patch" size="1225" author="mdoerr" created="Thu, 26 Oct 2023 13:36:43 -0700"/>
                            <attachment id="106604" name="hs_err_pid662334.log" size="767529" author="mdoerr" created="Wed, 27 Sep 2023 02:48:03 -0700"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_10000" key="com.atlassian.jira.plugin.system.customfieldtypes:multiselect">
                        <customfieldname>CPU</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="17024"><![CDATA[ppc]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_11700" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_10600" key="com.oracle.jira.javabugsystem-jira-plugin:jbs-fixedBackportedCustomfield">
                        <customfieldname>Fixed</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_11100" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i337sr:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_11004" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10006" key="com.atlassian.jira.plugin.system.customfieldtypes:select">
                        <customfieldname>Resolved In Build</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="17436"><![CDATA[b24]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10008" key="com.oracle.jira.jira-subcomponent-plugin:oracle-subComponentField">
                        <customfieldname>Subcomponent</customfieldname>
                        <customfieldvalues>
                             <customfieldvalue key="192"><![CDATA[runtime]]></customfieldvalue> 
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_10601" key="com.oracle.jira.javabugsystem-jira-plugin:jbs-targetBackportedCustomfield">
                        <customfieldname>Targeted</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_10100" key="com.atlassian.jira.plugin.system.customfieldtypes:radiobuttons">
                        <customfieldname>Verification</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="17000"><![CDATA[Verified]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                </customfields>
    </item>
</channel>
</rss>