<!-- 
RSS generated by JIRA (9.12.27#9120027-sha1:edc4490121e366e9e7bd2213d532dbe7e028fc5d) at Tue Sep 30 13:50:26 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>Java Bug System</title>
    <link>https://bugs.openjdk.org</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-us</language>    <build-info>
        <version>9.12.27</version>
        <build-number>9120027</build-number>
        <build-date>02-09-2025</build-date>
    </build-info>


<item>
            <title>[JDK-8280113] (dc) DatagramSocket.receive does not always throw when the channel is closed  </title>
                <link>https://bugs.openjdk.org/browse/JDK-8280113</link>
                <project id="10100" key="JDK">JDK</project>
                    <description>ADDITIONAL SYSTEM INFORMATION :&lt;br/&gt;
Linux Xubuntu 21.10 x64 OpenJDK17.0.1&lt;br/&gt;
Linux Xubuntu 21.10 x64 GraalVM CE 21.3.0&lt;br/&gt;
Linux Xubuntu 21.10 x64 BellSoft 17.0.1&lt;br/&gt;
Raspberry Pi OS Bullseye armhf BellSoft 17.0.1&lt;br/&gt;
&lt;br/&gt;
A DESCRIPTION OF THE PROBLEM :&lt;br/&gt;
A DatagramSocket.receive() blocked on receive does not always throw a SocketException when the Socket is closed.  If the Socket has a setSoTimeout set to a positive number and two packets have been received and the socket is closed no exception will be thrown.  Also true for MulticastSockets.&lt;br/&gt;
&lt;br/&gt;
STEPS TO FOLLOW TO REPRODUCE THE PROBLEM :&lt;br/&gt;
Open a DatagramSocket, set Socket timeout to a positive value, receive two DatagramPackets, and then close the Socket.&lt;br/&gt;
&lt;br/&gt;
EXPECTED VERSUS ACTUAL BEHAVIOR :&lt;br/&gt;
EXPECTED -&lt;br/&gt;
It should throw a SocketException.&lt;br/&gt;
ACTUAL -&lt;br/&gt;
Program flow will proceed to the subsequent instruction and no Excpetion will be thrown.&lt;br/&gt;
&lt;br/&gt;
---------- BEGIN SOURCE ----------&lt;br/&gt;
import java.io.*;&lt;br/&gt;
import java.net.*;&lt;br/&gt;
&lt;br/&gt;
public class SocketBug {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;int port = 56789;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Thread rxThread;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Thread txThread;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;DatagramSocket rxSocket;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;volatile boolean runFlag;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public SocketBug() throws IOException {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;rxSocket = new DatagramSocket(port);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// must have a positive value timeout&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;rxSocket.setSoTimeout(5000);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;rxThread = new Thread(() -&amp;gt; {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;byte[] buf = new byte[64];&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;DatagramPacket packet = new DatagramPacket(buf,buf.length);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;try {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;while (runFlag) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;rxSocket.receive(packet);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if (runFlag)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.println(&amp;quot;rxThread: packet received&amp;quot;);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;else&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;throw new IOException(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;quot;should have thrown SocketException&amp;quot;);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;} catch (IOException ioe) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.printf(&amp;quot;rxThread: %s%n&amp;quot;,ioe);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;});&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;txThread = new Thread(() -&amp;gt; {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;byte[] buf = new byte[64];&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;DatagramPacket packet = new DatagramPacket(buf,buf.length,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;new InetSocketAddress(&amp;quot;localhost&amp;quot;,port));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;try (DatagramSocket txSocket = new DatagramSocket()) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// just to make sure rxThread is blocked on receive&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Thread.sleep(200);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// must send two packets&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;txSocket.send(packet);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;txSocket.send(packet);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.println(&amp;quot;txThread: packets sent&amp;quot;);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;} catch (IOException|InterruptedException ex) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.printf(&amp;quot;txThread: %s%n&amp;quot;,ex);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;});&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public void start() {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;runFlag = true;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;rxThread.start();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;txThread.start();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public void stop() {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;runFlag = false;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;rxSocket.close();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public static void main(String[] args) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;try {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;SocketBug bug = new SocketBug();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;bug.start();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Thread.sleep(1000);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;bug.stop();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;} catch (IOException|InterruptedException ex) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.printf(&amp;quot;main: %s%n&amp;quot;,ex);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
---------- END SOURCE ----------&lt;br/&gt;
&lt;br/&gt;
CUSTOMER SUBMITTED WORKAROUND :&lt;br/&gt;
Set a flag before closing the Socket and test that flag after Socket.receive().&lt;br/&gt;
&lt;br/&gt;
FREQUENCY : always&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
</description>
                <environment></environment>
        <key id="5066330">JDK-8280113</key>
            <summary>(dc) DatagramSocket.receive does not always throw when the channel is closed  </summary>
                <type id="1" iconUrl="https://bugs.openjdk.org/secure/viewavatar?size=xsmall&amp;avatarId=14703&amp;avatarType=issuetype">Bug</type>
                                            <priority id="3" iconUrl="https://bugs.openjdk.org/images/jbsImages/p3.png">P3</priority>
                        <status id="6" iconUrl="https://bugs.openjdk.org/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="success"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="alanb">Alan Bateman</assignee>
                                    <reporter username="webbuggrp">Webbug Group</reporter>
                        <labels>
                            <label>dcsaw</label>
                            <label>jdk17u-fix-request</label>
                            <label>jdk17u-fix-yes</label>
                            <label>regression</label>
                            <label>reproducer-yes</label>
                            <label>webbug</label>
                    </labels>
                <created>Sun, 16 Jan 2022 09:09:20 -0800</created>
                <updated>Fri, 10 May 2024 02:22:07 -0700</updated>
                            <resolved>Wed, 22 Feb 2023 00:14:47 -0800</resolved>
                                    <version>17</version>
                    <version>21</version>
                                    <fixVersion>21</fixVersion>
                                    <component>core-libs</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>10</watches>
                                                                                                                <comments>
                            <comment id="14671832" author="goetz" created="Wed, 8 May 2024 01:47:20 -0700"  >Fix request [17u]&lt;br/&gt;
&lt;br/&gt;
I backport this for parity with 17.0.12-oracle.&lt;br/&gt;
Low to medium risk, especially as the test can not be backported. But simple change.&lt;br/&gt;
Clean backport to code, test omitted as it does not work in 17.&lt;br/&gt;
SAP nightly testing passed.&lt;br/&gt;
</comment>
                            <comment id="14671829" author="roboduke" created="Wed, 8 May 2024 01:41:05 -0700"  >A pull request was submitted for review.&lt;br/&gt;
URL: &lt;a href=&quot;https://git.openjdk.org/jdk17u-dev/pull/2445&quot;&gt;https://git.openjdk.org/jdk17u-dev/pull/2445&lt;/a&gt;&lt;br/&gt;
Date: 2024-05-03 14:49:06 +0000</comment>
                            <comment id="14561905" author="dukebot" created="Wed, 22 Feb 2023 00:14:46 -0800"  >Changeset: b6ecca12&lt;br/&gt;
Author:    Alan Bateman &amp;lt;&lt;a href=&apos;mailto:alanb@openjdk.org&apos;&gt;alanb@openjdk.org&lt;/a&gt;&amp;gt;&lt;br/&gt;
Date:      2023-02-22 08:13:06 +0000&lt;br/&gt;
URL:       &lt;a href=&quot;https://git.openjdk.org/jdk/commit/b6ecca126846f9c53d554ff061cfe9b7b20a4d12&quot;&gt;https://git.openjdk.org/jdk/commit/b6ecca126846f9c53d554ff061cfe9b7b20a4d12&lt;/a&gt;&lt;br/&gt;
</comment>
                            <comment id="14561500" author="roboduke" created="Mon, 20 Feb 2023 11:58:40 -0800"  >A pull request was submitted for review.&lt;br/&gt;
URL: &lt;a href=&quot;https://git.openjdk.org/jdk/pull/12674&quot;&gt;https://git.openjdk.org/jdk/pull/12674&lt;/a&gt;&lt;br/&gt;
Date: 2023-02-20 18:09:44 +0000</comment>
                            <comment id="14561378" author="alanb" created="Mon, 20 Feb 2023 02:57:22 -0800"  >Thanks for the updated test, this is an issue with async close receive when the channel has already received more than one datagram. This may go back to JDK 14 when the socket address caches were introduced.</comment>
                            <comment id="14561287" author="tongwan" created="Sun, 19 Feb 2023 22:00:47 -0800"  >Additional information from the submitter&lt;br/&gt;
ADDITIONAL SYSTEM INFORMATION :&lt;br/&gt;
Xubuntu 22.10 x64, OpenJDK 19.0.2, OpenJDK 21ea and Bellsoft Java 19.0.2&lt;br/&gt;
&lt;br/&gt;
Raspberry Pi OS 64bit, OpenJDK 19.0.2, OpenJDK 21ea and Bellsoft Java 19.0.2&lt;br/&gt;
&lt;br/&gt;
A DESCRIPTION OF THE PROBLEM :&lt;br/&gt;
**** THIS IS ONLY A BUG ON LINUX OS, IT WORKS FINE ON WINDOWS ***&lt;br/&gt;
&lt;br/&gt;
When two UDP packetes have been received on a Socket with a timeout is blocked on a receive(), closing the Socket does NOT produce a SocketException but instead falls through to the next instruction.&lt;br/&gt;
&lt;br/&gt;
This is the output of the reproducer when run on Xubuntu 22.10:&lt;br/&gt;
&lt;br/&gt;
java SocketBug.java&lt;br/&gt;
txThread: first packet sent&lt;br/&gt;
rxThread: packet received&lt;br/&gt;
txThread: second packet sent&lt;br/&gt;
rxThread: packet received&lt;br/&gt;
txThread: finished&lt;br/&gt;
rxThread: java.io.IOException: should have thrown SocketException: runFlag=false&lt;br/&gt;
rxThread: finished&lt;br/&gt;
&lt;br/&gt;
This is the output when run on Windows 10:&lt;br/&gt;
&lt;br/&gt;
java SocketBug.java&lt;br/&gt;
txThread: first packet sent&lt;br/&gt;
rxThread: packet received&lt;br/&gt;
txThread: second packet sent&lt;br/&gt;
txThread: finished&lt;br/&gt;
rxThread: packet received&lt;br/&gt;
rxThread: java.net.SocketException: Socket closed: runFlag=false&lt;br/&gt;
rxThread: finished&lt;br/&gt;
&lt;br/&gt;
When I submitted this bug last year it was closed after a test of the reproducer on a Windows machine. This bug is not in Windows Java. It is a Linux Java bug.&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
REGRESSION : Last worked in version 17.0.6&lt;br/&gt;
&lt;br/&gt;
STEPS TO FOLLOW TO REPRODUCE THE PROBLEM :&lt;br/&gt;
Create a DatagramSocket with a timeout and send two DatagramPackets to the Socket, receive those two packets, block on the Socket.receive() method and then close the Socket.&lt;br/&gt;
&lt;br/&gt;
EXPECTED VERSUS ACTUAL BEHAVIOR :&lt;br/&gt;
EXPECTED -&lt;br/&gt;
A SocketException should be thrown when the Socket blocked on receive() is closed.&lt;br/&gt;
ACTUAL -&lt;br/&gt;
No exception will be thrown and the code will proceed to the instruction after the Socket.receive().&lt;br/&gt;
&lt;br/&gt;
---------- BEGIN SOURCE ----------&lt;br/&gt;
import java.io.*;&lt;br/&gt;
import java.net.*;&lt;br/&gt;
&lt;br/&gt;
/**&lt;br/&gt;
&amp;nbsp;* SocketBug demonstrates the bug in OpenJDK 17, 18 and 19 on LINUX where after&lt;br/&gt;
&amp;nbsp;* two UDP packets have been received and the receiving socket is blocked on&lt;br/&gt;
&amp;nbsp;* receive(), closing the socket DOES NOT produce a SocketException but instead&lt;br/&gt;
&amp;nbsp;* falls through to the next instruction. This bug is NOT in the Windows&lt;br/&gt;
&amp;nbsp;* version of OpenJDK 17, 18 or 19.&lt;br/&gt;
&amp;nbsp;*&lt;br/&gt;
&amp;nbsp;* The start() method starts both the rxThread and txThread. The rxThread&lt;br/&gt;
&amp;nbsp;* creates a DatagramSocket for receiving and enters the while(true) loop,&lt;br/&gt;
&amp;nbsp;* blocking on recieve(). The only exit from that loop is via an exception.&lt;br/&gt;
&amp;nbsp;* The txThread creates a DatagramSocket for sending and sends two packets.&lt;br/&gt;
&amp;nbsp;* They are both received by the socket in the rxThread. Since the runFlag is&lt;br/&gt;
&amp;nbsp;* true the &amp;quot;packet received&amp;quot; message is printed. The rxThread is then blocked&lt;br/&gt;
&amp;nbsp;* waiting for more packets or to be closed. The stop method is called after&lt;br/&gt;
&amp;nbsp;* two seconds. This sets the runFlag to false and closes the socket.&lt;br/&gt;
&amp;nbsp;* The rxSocket should throw a SocketException but instead it falls through to&lt;br/&gt;
&amp;nbsp;* the if statement and then prints the message&lt;br/&gt;
&amp;nbsp;* &amp;quot;should have thrown SocketException&amp;quot; because runFlag is now false.&lt;br/&gt;
&amp;nbsp;*/&lt;br/&gt;
public class SocketBug {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;int port = 56789;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Thread rxThread;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Thread txThread;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;DatagramSocket rxSocket;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;volatile boolean runFlag;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public SocketBug() throws IOException {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;rxSocket = new DatagramSocket(port);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// must have a positive value timeout&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// this is longer than the delay in main()&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;rxSocket.setSoTimeout(5000);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;rxThread = new Thread(() -&amp;gt; {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;String threadName = Thread.currentThread().getName();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;byte[] buf = new byte[64];&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;DatagramPacket packet = new DatagramPacket(buf,buf.length);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;try {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// no way out of this loop except an exception&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;while (true) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;rxSocket.receive(packet);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if (runFlag)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.printf(&amp;quot;%s: packet received%n&amp;quot;,threadName);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;else&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;throw new IOException(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;quot;should have thrown SocketException&amp;quot;);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// the only way out of the while loop above is an exception&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;} catch (IOException ioe) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.printf(&amp;quot;%s: %s: runFlag=%b%n&amp;quot;,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;threadName,ioe,runFlag);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.printf(&amp;quot;%s: finished%n&amp;quot;,threadName);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;},&amp;quot;rxThread&amp;quot;);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;txThread = new Thread(() -&amp;gt; {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;String threadName = Thread.currentThread().getName();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;byte[] buf = new byte[64];&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;DatagramPacket packet = new DatagramPacket(buf,buf.length,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;new InetSocketAddress(&amp;quot;localhost&amp;quot;,port));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;try (DatagramSocket txSocket = new DatagramSocket()) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// must send two packets&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;txSocket.send(packet);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.printf(&amp;quot;%s: first packet sent%n&amp;quot;,threadName);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;txSocket.send(packet);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.printf(&amp;quot;%s: second packet sent%n&amp;quot;,threadName);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;} catch (IOException ioe) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.printf(&amp;quot;%s: %s%n&amp;quot;,threadName,ioe);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.printf(&amp;quot;%s: finished%n&amp;quot;,threadName);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;},&amp;quot;txThread&amp;quot;);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public void start() {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;runFlag = true;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;rxThread.start();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;txThread.start();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public void stop() {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;runFlag = false;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;rxSocket.close();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public static void main(String[] args) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;try {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;SocketBug bug = new SocketBug();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;bug.start();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Thread.sleep(2000);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;bug.stop();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;} catch (IOException|InterruptedException ex) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.printf(&amp;quot;main: %s%n&amp;quot;,ex);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
---------- END SOURCE ----------&lt;br/&gt;
&lt;br/&gt;
CUSTOMER SUBMITTED WORKAROUND :&lt;br/&gt;
Set a flag before closing the Socket and test that flag in the code following the Socket.receive() method.&lt;br/&gt;
&lt;br/&gt;
FREQUENCY : always </comment>
                            <comment id="14476716" author="tongwan" created="Sun, 13 Feb 2022 20:08:50 -0800"  >Additional information from the submitter:&lt;br/&gt;
This is only a Linux bug. It works correctly in Windows.  &lt;br/&gt;
&lt;br/&gt;
Here is more explanations about the reproducer:&lt;br/&gt;
&amp;nbsp;* SocketBug demonstrates the bug in OpenJDK 17 on LINUX where after two UDP&lt;br/&gt;
&amp;nbsp;* packets have been received and the receiving socket is blocked on receive(),&lt;br/&gt;
&amp;nbsp;* closing the socket DOES NOT produce a SocketException but instead falls&lt;br/&gt;
&amp;nbsp;* through to the next instruction. This bug is NOT in the Windows version of&lt;br/&gt;
&amp;nbsp;* OpenJDK 17.&lt;br/&gt;
&amp;nbsp;*&lt;br/&gt;
&amp;nbsp;* The start() method starts both the rxThread and txThread. The rxThread&lt;br/&gt;
&amp;nbsp;* creates a DatagramSocket for receiving and enters the while(true) loop,&lt;br/&gt;
&amp;nbsp;* blocking on recieve(). The only exit from that loop is via an exception.&lt;br/&gt;
&amp;nbsp;* The txThread creates a DatagramSocket for sending and sends two packets.&lt;br/&gt;
&amp;nbsp;* They are both received by the socket in the rxThread. Since the runFlag is&lt;br/&gt;
&amp;nbsp;* true the &amp;quot;packet received&amp;quot; message is printed. The rxThread is then blocked&lt;br/&gt;
&amp;nbsp;* waiting for more packets or to be closed. The stop method is called after&lt;br/&gt;
&amp;nbsp;* two seconds. This sets the runFlag to false and closes the socket.&lt;br/&gt;
&amp;nbsp;* The receiving socket should throw a SocketException but instead it falls&lt;br/&gt;
&amp;nbsp;* through to the if statement and then prints the message &amp;quot;should have thrown&lt;br/&gt;
&amp;nbsp;* SocketException&amp;quot; because runFlag is now false. </comment>
                            <comment id="14472993" author="tongwan" created="Fri, 28 Jan 2022 03:59:31 -0800"  >Additional information from the submitter:&lt;br/&gt;
You closed it because you tested it on a Windows machine and Windows Java does NOT have this bug. This is LINUX bug. </comment>
                            <comment id="14470172" author="alanb" created="Tue, 18 Jan 2022 22:52:05 -0800"  >This is an issue with the reproducer (SocketBug.java), not a JDK issue.</comment>
                            <comment id="14470110" author="pnarayanaswa" created="Tue, 18 Jan 2022 20:08:12 -0800"  >Additional Information from submitter:&lt;br/&gt;
============================&lt;br/&gt;
The bug is not in Windows 10 using openjdk-17.0.2 64 bit or BellSoft&amp;#39;s Liberica JDK 17.0.1 64bit.</comment>
                            <comment id="14470097" author="tongwan" created="Tue, 18 Jan 2022 17:44:55 -0800"  >The observations with Linux:&lt;br/&gt;
&lt;a href=&apos;mailto:tongwan@TONGWAN-7080&apos;&gt;tongwan@TONGWAN-7080&lt;/a&gt;:/mnt/c/Users/TONGWAN/Documents/&lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8280113&quot; title=&quot;(dc) DatagramSocket.receive does not always throw when the channel is closed  &quot; class=&quot;issue-link&quot; data-issue-key=&quot;JDK-8280113&quot;&gt;&lt;strike&gt;JI-9072428&lt;/strike&gt;&lt;/a&gt;/src$ cat /etc/os-release&lt;br/&gt;
NAME=&amp;quot;Ubuntu&amp;quot;&lt;br/&gt;
VERSION=&amp;quot;20.04.2 LTS (Focal Fossa)&amp;quot;&lt;br/&gt;
ID=ubuntu&lt;br/&gt;
ID_LIKE=debian&lt;br/&gt;
PRETTY_NAME=&amp;quot;Ubuntu 20.04.2 LTS&amp;quot;&lt;br/&gt;
VERSION_ID=&amp;quot;20.04&amp;quot;&lt;br/&gt;
HOME_URL=&amp;quot;&lt;a href=&quot;https://www.ubuntu.com/&quot;&gt;https://www.ubuntu.com/&lt;/a&gt;&amp;quot;&lt;br/&gt;
SUPPORT_URL=&amp;quot;&lt;a href=&quot;https://help.ubuntu.com/&quot;&gt;https://help.ubuntu.com/&lt;/a&gt;&amp;quot;&lt;br/&gt;
BUG_REPORT_URL=&amp;quot;&lt;a href=&quot;https://bugs.launchpad.net/ubuntu/&quot;&gt;https://bugs.launchpad.net/ubuntu/&lt;/a&gt;&amp;quot;&lt;br/&gt;
PRIVACY_POLICY_URL=&amp;quot;&lt;a href=&quot;https://www.ubuntu.com/legal/terms-and-policies/privacy-policy&quot;&gt;https://www.ubuntu.com/legal/terms-and-policies/privacy-policy&lt;/a&gt;&amp;quot;&lt;br/&gt;
VERSION_CODENAME=focal&lt;br/&gt;
UBUNTU_CODENAME=focal&lt;br/&gt;
&lt;a href=&apos;mailto:tongwan@TONGWAN-7080&apos;&gt;tongwan@TONGWAN-7080&lt;/a&gt;:/mnt/c/Users/TONGWAN/Documents/&lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8280113&quot; title=&quot;(dc) DatagramSocket.receive does not always throw when the channel is closed  &quot; class=&quot;issue-link&quot; data-issue-key=&quot;JDK-8280113&quot;&gt;&lt;strike&gt;JI-9072428&lt;/strike&gt;&lt;/a&gt;/src$ /mnt/c/Users/TONGWAN/Downloads/jdk-17.0.1/bin/java SocketBug&lt;br/&gt;
rxThread: packet received&lt;br/&gt;
txThread: packets sent&lt;br/&gt;
rxThread: packet received&lt;br/&gt;
rxThread: java.io.IOException: should have thrown SocketException&lt;br/&gt;
&lt;br/&gt;
&lt;a href=&apos;mailto:root@730ba8deecc7&apos;&gt;root@730ba8deecc7&lt;/a&gt;:/# cat /etc/os-release&lt;br/&gt;
PRETTY_NAME=&amp;quot;Debian GNU/Linux bookworm/sid&amp;quot;&lt;br/&gt;
NAME=&amp;quot;Debian GNU/Linux&amp;quot;&lt;br/&gt;
ID=debian&lt;br/&gt;
HOME_URL=&amp;quot;&lt;a href=&quot;https://www.debian.org/&quot;&gt;https://www.debian.org/&lt;/a&gt;&amp;quot;&lt;br/&gt;
SUPPORT_URL=&amp;quot;&lt;a href=&quot;https://www.debian.org/support&quot;&gt;https://www.debian.org/support&lt;/a&gt;&amp;quot;&lt;br/&gt;
BUG_REPORT_URL=&amp;quot;&lt;a href=&quot;https://bugs.debian.org/&quot;&gt;https://bugs.debian.org/&lt;/a&gt;&amp;quot;&lt;br/&gt;
&lt;a href=&apos;mailto:root@730ba8deecc7&apos;&gt;root@730ba8deecc7&lt;/a&gt;:/tmp/external/Documents/&lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8280113&quot; title=&quot;(dc) DatagramSocket.receive does not always throw when the channel is closed  &quot; class=&quot;issue-link&quot; data-issue-key=&quot;JDK-8280113&quot;&gt;&lt;strike&gt;JI-9072428&lt;/strike&gt;&lt;/a&gt;/src#  ../../../Downloads/jdk-17.0.1/bin/java SocketBug&lt;br/&gt;
rxThread: packet received&lt;br/&gt;
txThread: packets sent&lt;br/&gt;
rxThread: packet received&lt;br/&gt;
rxThread: java.io.IOException: should have thrown SocketException</comment>
                            <comment id="14470094" author="tongwan" created="Tue, 18 Jan 2022 17:41:08 -0800"  >Additional information from the submitter:&lt;br/&gt;
You tested it with Windows. This bug is NOT in Windows</comment>
                            <comment id="14469787" author="alanb" created="Mon, 17 Jan 2022 23:25:26 -0800"  >This looks like a bug in the reproducer. Setting &amp;quot;runFlag&amp;quot; and closing the socket is not an atomic operation so rxThread may read runFlag as flag after receiving a datagram. If you remove the runFlag from the loop in rxThread then you&amp;#39;ll get the expected SocketException.</comment>
                            <comment id="14469771" author="tongwan" created="Mon, 17 Jan 2022 21:52:30 -0800"  >Observations on Windows 10:&lt;br/&gt;
JDK 17: Passed, a SocketException thrown</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10200">
                    <name>Backport</name>
                                            <outwardlinks description="backported by">
                                        <issuelink>
            <issuekey id="5120019">JDK-8324694</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="5129187">JDK-8332045</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="97650" name="SocketBug.java" size="2280" author="tongwan" created="Mon, 17 Jan 2022 21:55:42 -0800"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_10000" key="com.atlassian.jira.plugin.system.customfieldtypes:multiselect">
                        <customfieldname>CPU</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="17008"><![CDATA[generic]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_11700" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_10600" key="com.oracle.jira.javabugsystem-jira-plugin:jbs-fixedBackportedCustomfield">
                        <customfieldname>Fixed</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                <customfield id="customfield_10004" key="com.atlassian.jira.plugin.system.customfieldtypes:version">
                        <customfieldname>Introduced In Version</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue id="19703">14</customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_10005" key="com.atlassian.jira.plugin.system.customfieldtypes:multiselect">
                        <customfieldname>OS</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="17010"><![CDATA[generic]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                            <customfield id="customfield_11100" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i2vobn:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_11004" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10006" key="com.atlassian.jira.plugin.system.customfieldtypes:select">
                        <customfieldname>Resolved In Build</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="17311"><![CDATA[b11]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10008" key="com.oracle.jira.jira-subcomponent-plugin:oracle-subComponentField">
                        <customfieldname>Subcomponent</customfieldname>
                        <customfieldvalues>
                             <customfieldvalue key="228"><![CDATA[java.nio]]></customfieldvalue> 
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_10601" key="com.oracle.jira.javabugsystem-jira-plugin:jbs-targetBackportedCustomfield">
                        <customfieldname>Targeted</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_10100" key="com.atlassian.jira.plugin.system.customfieldtypes:radiobuttons">
                        <customfieldname>Verification</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="17000"><![CDATA[Verified]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                </customfields>
    </item>
</channel>
</rss>