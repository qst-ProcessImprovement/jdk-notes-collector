<!-- 
RSS generated by JIRA (9.12.27#9120027-sha1:edc4490121e366e9e7bd2213d532dbe7e028fc5d) at Tue Sep 30 13:16:46 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>Java Bug System</title>
    <link>https://bugs.openjdk.org</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-us</language>    <build-info>
        <version>9.12.27</version>
        <build-number>9120027</build-number>
        <build-date>02-09-2025</build-date>
    </build-info>


<item>
            <title>[JDK-8336926] jdk/internal/util/ReferencedKeyTest.java can fail with ConcurrentModificationException</title>
                <link>https://bugs.openjdk.org/browse/JDK-8336926</link>
                <project id="10100" key="JDK">JDK</project>
                    <description>We just started seeing this fail with Graal starting in jdk-24+5 when run with linux-aarch-debug with the arguments &lt;br/&gt;
-Xcomp -ea -esa -XX:CompileThreshold=100 -XX:+UnlockExperimentalVMOptions -server -XX:+TieredCompilation -XX:+VerifyOops -XX:+UnlockExperimentalVMOptions -XX:+UseJVMCICompiler&lt;br/&gt;
&lt;br/&gt;
java.util.ConcurrentModificationException&lt;br/&gt;
	at java.base/java.util.HashMap$KeySpliterator.forEachRemaining(HashMap.java:1721)&lt;br/&gt;
	at java.base/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:570)&lt;br/&gt;
	at java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:560)&lt;br/&gt;
	at java.base/java.util.stream.ReduceOps$ReduceOp.evaluateSequential(ReduceOps.java:921)&lt;br/&gt;
	at java.base/java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:265)&lt;br/&gt;
	at java.base/java.util.stream.ReferencePipeline.collect(ReferencePipeline.java:727)&lt;br/&gt;
	at java.base/jdk.internal.util.ReferencedKeyMap.entrySet(ReferencedKeyMap.java:295)&lt;br/&gt;
	at java.base/jdk.internal.util.ReferencedKeyTest.methods(ReferencedKeyTest.java:101)&lt;br/&gt;
	at java.base/jdk.internal.util.ReferencedKeyTest.mapTest(ReferencedKeyTest.java:75)&lt;br/&gt;
	at java.base/jdk.internal.util.ReferencedKeyTest.main(ReferencedKeyTest.java:49)&lt;br/&gt;
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)&lt;br/&gt;
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)&lt;br/&gt;
	at com.sun.javatest.regtest.agent.MainWrapper$MainTask.run(MainWrapper.java:138)&lt;br/&gt;
	at java.base/java.lang.Thread.run(Thread.java:1575)&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
Looking at ReferencedKeyMap.entrySet:&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;@Override&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public Set&amp;lt;Entry&amp;lt;K, V&amp;gt;&amp;gt; entrySet() {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;removeStaleReferences();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return filterKeySet()&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;.map(k -&amp;gt; new AbstractMap.SimpleEntry&amp;lt;&amp;gt;(k, get(k)))&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;.collect(Collectors.toSet());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&lt;br/&gt;
It seems to me that since the call to get(k) also calls removeStaleReferences(), a concurrent GC could trigger removal while building the set resulting in a ConcurrentModificationException.  Shouldn&amp;#39;t this method be calling map.get(k) directly instead?  I&amp;#39;m unclear why it&amp;#39;s failing with Graal though it might just be a timing a issue.</description>
                <environment></environment>
        <key id="5134864">JDK-8336926</key>
            <summary>jdk/internal/util/ReferencedKeyTest.java can fail with ConcurrentModificationException</summary>
                <type id="1" iconUrl="https://bugs.openjdk.org/secure/viewavatar?size=xsmall&amp;avatarId=14703&amp;avatarType=issuetype">Bug</type>
                                            <priority id="4" iconUrl="https://bugs.openjdk.org/images/jbsImages/p4.png">P4</priority>
                        <status id="6" iconUrl="https://bugs.openjdk.org/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="success"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="rriggs">Roger Riggs</assignee>
                                    <reporter username="never">Tom Rodriguez</reporter>
                        <labels>
                            <label>amazon-interest</label>
                            <label>graal</label>
                            <label>jdk21u-fix-request</label>
                            <label>jdk21u-fix-yes</label>
                            <label>jdk23u-fix-SQE-ok-next</label>
                            <label>jdk23u-fix-request</label>
                            <label>jdk23u-fix-yes</label>
                    </labels>
                <created>Mon, 22 Jul 2024 11:36:08 -0700</created>
                <updated>Wed, 22 Jan 2025 09:38:50 -0800</updated>
                            <resolved>Thu, 8 Aug 2024 09:54:59 -0700</resolved>
                                    <version>21.0.4</version>
                    <version>23</version>
                    <version>24</version>
                                    <fixVersion>24</fixVersion>
                                    <component>core-libs</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>9</watches>
                                                                                                                                                            <comments>
                            <comment id="14697911" author="roboduke" created="Tue, 13 Aug 2024 06:14:37 -0700"  >[jdk23u-fix-request] Approval Request from Aleksey Shipil&amp;#xEB;v&lt;br/&gt;
Clean backport to fix CME in ReferencedKeyMap. Applies cleanly. Tests pass. Risk is on lower side, as the change is pretty simple.</comment>
                            <comment id="14697910" author="roboduke" created="Tue, 13 Aug 2024 06:14:20 -0700"  >[jdk21u-fix-request] Approval Request from Aleksey Shipil&amp;#xEB;v&lt;br/&gt;
Clean backport to fix CME in ReferencedKeyMap. Applies cleanly. Tests pass. Risk is on lower side, as the change is pretty simple.</comment>
                            <comment id="14697878" author="roboduke" created="Tue, 13 Aug 2024 04:11:40 -0700"  >A pull request was submitted for review.&lt;br/&gt;
Branch: master&lt;br/&gt;
URL: &lt;a href=&quot;https://git.openjdk.org/jdk21u-dev/pull/916&quot;&gt;https://git.openjdk.org/jdk21u-dev/pull/916&lt;/a&gt;&lt;br/&gt;
Date: 2024-08-13 11:06:05 +0000</comment>
                            <comment id="14697876" author="roboduke" created="Tue, 13 Aug 2024 04:02:22 -0700"  >A pull request was submitted for review.&lt;br/&gt;
Branch: master&lt;br/&gt;
URL: &lt;a href=&quot;https://git.openjdk.org/jdk23u/pull/66&quot;&gt;https://git.openjdk.org/jdk23u/pull/66&lt;/a&gt;&lt;br/&gt;
Date: 2024-08-13 10:57:03 +0000</comment>
                            <comment id="14696980" author="dukebot" created="Thu, 8 Aug 2024 09:54:58 -0700"  >Changeset: bfb75b96&lt;br/&gt;
Branch: master&lt;br/&gt;
Author:    Roger Riggs &amp;lt;&lt;a href=&apos;mailto:rriggs@openjdk.org&apos;&gt;rriggs@openjdk.org&lt;/a&gt;&amp;gt;&lt;br/&gt;
Date:      2024-08-08 16:53:38 +0000&lt;br/&gt;
URL:       &lt;a href=&quot;https://git.openjdk.org/jdk/commit/bfb75b96266f4c5840e2edea13f9aa2c801518cf&quot;&gt;https://git.openjdk.org/jdk/commit/bfb75b96266f4c5840e2edea13f9aa2c801518cf&lt;/a&gt;&lt;br/&gt;
</comment>
                            <comment id="14696928" author="rriggs" created="Thu, 8 Aug 2024 07:10:29 -0700"  >Thanks for the detail and test suggestions, created 8338060 as a followup.</comment>
                            <comment id="14696805" author="never" created="Wed, 7 Aug 2024 16:47:44 -0700"  >I don&amp;#39;t entirely understand the point of the test myself. It seems like methods functions is assuming that no GC happens to occur during it&amp;#39;s execution and is testing that it operates like a map or a set.  Since it appears a GC can occur during these methods I think it should keep those values strong referenced.  I&amp;#39;m thinking something like this, which I haven&amp;#39;t tested:&lt;br/&gt;
&lt;br/&gt;
diff --git a/test/jdk/jdk/internal/util/ReferencedKeyTest.java b/test/jdk/jdk/internal/util/ReferencedKeyTest.java&lt;br/&gt;
index 75690fa6e25..25d8c5c0438 100644&lt;br/&gt;
--- a/test/jdk/jdk/internal/util/ReferencedKeyTest.java&lt;br/&gt;
+++ b/test/jdk/jdk/internal/util/ReferencedKeyTest.java&lt;br/&gt;
@@ -65,26 +65,30 @@ static void assertTrue(boolean test, String message) {&lt;br/&gt;
&amp;nbsp;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;static void mapTest(boolean isSoft, Supplier&amp;lt;Map&amp;lt;ReferenceKey&amp;lt;Long&amp;gt;, String&amp;gt;&amp;gt; supplier) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Map&amp;lt;Long, String&amp;gt; map = ReferencedKeyMap.create(isSoft, supplier);&lt;br/&gt;
-        populate(map);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if (!isSoft) {&lt;br/&gt;
+            populate(map);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if (!collect(() -&amp;gt; map.isEmpty())) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;throw new RuntimeException(&amp;quot;WeakReference map not collecting!&amp;quot;);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
-        populate(map);&lt;br/&gt;
+        Long[] values = populate(map);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;methods(map);&lt;br/&gt;
+        // Ensure the values are kept alive&lt;br/&gt;
+        Reference.reachabilityFence(values);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;static void setTest(boolean isSoft, Supplier&amp;lt;Map&amp;lt;ReferenceKey&amp;lt;Long&amp;gt;, ReferenceKey&amp;lt;Long&amp;gt;&amp;gt;&amp;gt; supplier) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ReferencedKeySet&amp;lt;Long&amp;gt; set = ReferencedKeySet.create(isSoft, supplier);&lt;br/&gt;
-        populate(set);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if (!isSoft) {&lt;br/&gt;
+            populate(set);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if (!collect(() -&amp;gt; set.isEmpty())) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;throw new RuntimeException(&amp;quot;WeakReference set not collecting!&amp;quot;);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
-        populate(set);&lt;br/&gt;
+        Long[] values = (set);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;methods(set);&lt;br/&gt;
+        // Ensure the values are kept alive&lt;br/&gt;
+        Reference.reachabilityFence(values);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;static void methods(Map&amp;lt;Long, String&amp;gt; map) {&lt;br/&gt;
@@ -164,18 +168,24 @@ static boolean collect(BooleanSupplier booleanSupplier) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return booleanSupplier.getAsBoolean();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&lt;br/&gt;
-    static void populate(Map&amp;lt;Long, String&amp;gt; map) {&lt;br/&gt;
+    static Long[] populate(Map&amp;lt;Long, String&amp;gt; map) {&lt;br/&gt;
+        Long[] values = new Long[26];&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;for (int i = 0; i &amp;lt; 26; i++) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Long key = BASE_KEY + i;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;String value = String.valueOf((char) (&amp;#39;a&amp;#39; + i));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;map.put(key, value);&lt;br/&gt;
+            values[i] = value;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
+        return values;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&lt;br/&gt;
-    static void populate(Set&amp;lt;Long&amp;gt; set) {&lt;br/&gt;
+    static Long[] populate(Set&amp;lt;Long&amp;gt; set) {&lt;br/&gt;
+        Long[] values = new Long[26];&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;for (int i = 0; i &amp;lt; 26; i++) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Long value = BASE_KEY + i;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;set.add(value);&lt;br/&gt;
+            values[i] = value;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
+        return values;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;}&lt;br/&gt;
</comment>
                            <comment id="14696784" author="rriggs" created="Wed, 7 Aug 2024 14:23:15 -0700"  >Which part of the test?&lt;br/&gt;
If the all the keys are strongly referenced, then its just a hashtable; which might be the purpose of the `methods()` methods.&lt;br/&gt;
Those tests don&amp;#39;t expect any memory pressure.&lt;br/&gt;
Only the collect() test method expects gc to occur.&lt;br/&gt;
&lt;br/&gt;
(BTW, the use of Integer as keys is dubious, with Valhalla, they won&amp;#39;t be identity objects, but that&amp;#39;s a different problem).</comment>
                            <comment id="14696773" author="never" created="Wed, 7 Aug 2024 13:12:15 -0700"  >The test itself needs to be updated to keep the keys alive as roots or it will just fail in some other way as a result of the unexpected GC.</comment>
                            <comment id="14696767" author="roboduke" created="Wed, 7 Aug 2024 12:33:26 -0700"  >A pull request was submitted for review.&lt;br/&gt;
Branch: master&lt;br/&gt;
URL: &lt;a href=&quot;https://git.openjdk.org/jdk/pull/20499&quot;&gt;https://git.openjdk.org/jdk/pull/20499&lt;/a&gt;&lt;br/&gt;
Date: 2024-08-07 19:26:59 +0000</comment>
                            <comment id="14696741" author="rriggs" created="Wed, 7 Aug 2024 10:18:27 -0700"  >The creation of the entrySet streams the entries, and while processing each, stale references are removed if cleared by GC.&lt;br/&gt;
This causes the hashset to be observed as modified leading to the exception.&lt;br/&gt;
Its all single threaded, so any concurrency is self imposed. &lt;br/&gt;
Delaying the stale reference checks on every element should avoid the problem.&lt;br/&gt;
</comment>
                            <comment id="14696554" author="dnsimon" created="Wed, 7 Aug 2024 01:17:15 -0700"  >Quoting internal observations from Tom:&lt;br/&gt;
&lt;br/&gt;
It seems like GC behaviour differences with libgraal are the trigger for this. It started failing reliably in jdk-24+4-279 for no obvious reason. I just want to understand what that is and make sure it&amp;#39;s only about how we compile something vs the fact that we&amp;#39;re using libgraal.&lt;br/&gt;
&lt;br/&gt;
ReferencedKeyMap and ReferencedKeySet don&amp;#39;t appear to be careful when calling removeStaleReferences so they can spuriously throw ConcurrentModificationException when calling some of their complex methods like entrySet. The attached ReferencedKeyGCTest.java is trivial reproducer of that problem.&lt;br/&gt;
&lt;br/&gt;
ReferencedKeyTest.java itself doesn&amp;#39;t keep the keys alive as roots so if any GC occurs during execution the test can fail.&lt;br/&gt;
&lt;br/&gt;
The trigger for this appears to be &lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8294960&quot; title=&quot;Convert java.base/java.lang.invoke package to use the Classfile API to generate lambdas and method handles&quot; class=&quot;issue-link&quot; data-issue-key=&quot;JDK-8294960&quot;&gt;&lt;strike&gt;JDK-8294960&lt;/strike&gt;&lt;/a&gt; as the test fails reliably with jdk-24+3-234 but not jdk-24+3-233. So I&amp;#39;m guessing something about this change to the lambda generation is yet again changing when we GC in the when compiled with libgraal. So I think this is just a problem with ReferencedKeyMap being unsafe for concurrent collection and ReferencedKeyTest not keeping alive the GC roots.</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10200">
                    <name>Backport</name>
                                            <outwardlinks description="backported by">
                                        <issuelink>
            <issuekey id="5136996">JDK-8338582</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="5137305">JDK-8338828</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                            <issuelinktype id="10003">
                    <name>Relates</name>
                                            <outwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="5136414">JDK-8338060</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="5104175">JDK-8310913</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="110212" name="ReferencedKeyGCTest.java" size="1209" author="never" created="Wed, 24 Jul 2024 10:47:09 -0700"/>
                    </attachments>
                <subtasks>
                                              <subtask id="5136307">JDK-8337972</subtask>
                                    </subtasks>
                <customfields>
                                                <customfield id="customfield_10000" key="com.atlassian.jira.plugin.system.customfieldtypes:multiselect">
                        <customfieldname>CPU</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="19300"><![CDATA[aarch64]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_11700" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_10600" key="com.oracle.jira.javabugsystem-jira-plugin:jbs-fixedBackportedCustomfield">
                        <customfieldname>Fixed</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                            <customfield id="customfield_10005" key="com.atlassian.jira.plugin.system.customfieldtypes:multiselect">
                        <customfieldname>OS</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="17023"><![CDATA[linux]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                            <customfield id="customfield_11100" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i379aj:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_11004" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10006" key="com.atlassian.jira.plugin.system.customfieldtypes:select">
                        <customfieldname>Resolved In Build</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="17311"><![CDATA[b11]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10008" key="com.oracle.jira.jira-subcomponent-plugin:oracle-subComponentField">
                        <customfieldname>Subcomponent</customfieldname>
                        <customfieldvalues>
                             <customfieldvalue key="216"><![CDATA[java.util]]></customfieldvalue> 
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_10601" key="com.oracle.jira.javabugsystem-jira-plugin:jbs-targetBackportedCustomfield">
                        <customfieldname>Targeted</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_10100" key="com.atlassian.jira.plugin.system.customfieldtypes:radiobuttons">
                        <customfieldname>Verification</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="17000"><![CDATA[Verified]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                </customfields>
    </item>
</channel>
</rss>