<!-- 
RSS generated by JIRA (9.12.27#9120027-sha1:edc4490121e366e9e7bd2213d532dbe7e028fc5d) at Tue Sep 30 18:22:36 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>Java Bug System</title>
    <link>https://bugs.openjdk.org</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-us</language>    <build-info>
        <version>9.12.27</version>
        <build-number>9120027</build-number>
        <build-date>02-09-2025</build-date>
    </build-info>


<item>
            <title>[JDK-8305670] Performance regression in LockSupport.unpark with lots of idle threads</title>
                <link>https://bugs.openjdk.org/browse/JDK-8305670</link>
                <project id="10100" key="JDK">JDK</project>
                    <description>We noticed latency degradation when migrating an app from JDK 8 to JDK 17 or 20. The app has more than 8K threads most of which are idle. Analysis showed a large amount of CPU time spent in ThreadsListHandle::cv_internal_thread_to_JavaThread called from Unsafe_Unpark.&lt;br/&gt;
&lt;br/&gt;
I could reproduce the issue locally with a simple test case - see attached UnparkRegression.java&lt;br/&gt;
&lt;br/&gt;
It creates 10K idle threads that sleep indefinitely and two active threads communicating to each other via CyclicBarrier. The particular synchronization primitive does not matter: any java.util.concurrent class that eventually calls LockSupport.unpark is affected by the issue.&lt;br/&gt;
&lt;br/&gt;
Running the test with JDK 17 or JDK 20 on 4-core ARM64 machine, it does 70K roundtrips per second, while with JDK 8 it does 162K (2.3x more).&lt;br/&gt;
&lt;br/&gt;
The issue appeared in JDK 10 with the introduction of Thread-SMR. The problem is the linear search in ThreadsList::includes called by cv_internal_thread_to_JavaThread:&lt;br/&gt;
&lt;a href=&quot;https://github.com/openjdk/jdk/blob/44f33ad1a9617fc23864c9ba5f063b3fc2f1e18c/src/hotspot/share/runtime/threadSMR.cpp#L829&quot;&gt;https://github.com/openjdk/jdk/blob/44f33ad1a9617fc23864c9ba5f063b3fc2f1e18c/src/hotspot/share/runtime/threadSMR.cpp#L829&lt;/a&gt;&lt;br/&gt;
&lt;br/&gt;
The call to ThreadList::includes is guarded by a diagnostic flag `EnableThreadSMRExtraValidityChecks` which is enabled by default.&lt;br/&gt;
After adding -XX:-EnableThreadSMRExtraValidityChecks, the performance returns back to JDK 8 levels.</description>
                <environment></environment>
        <key id="5097986">JDK-8305670</key>
            <summary>Performance regression in LockSupport.unpark with lots of idle threads</summary>
                <type id="1" iconUrl="https://bugs.openjdk.org/secure/viewavatar?size=xsmall&amp;avatarId=14703&amp;avatarType=issuetype">Bug</type>
                                            <priority id="4" iconUrl="https://bugs.openjdk.org/images/jbsImages/p4.png">P4</priority>
                        <status id="5" iconUrl="https://bugs.openjdk.org/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="success"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="dcubed">Daniel Daugherty</assignee>
                                    <reporter username="apangin">Andrei Pangin</reporter>
                        <labels>
                            <label>Thread-SMR</label>
                            <label>amazon-interest</label>
                            <label>jdk17u-fix-request</label>
                            <label>jdk17u-fix-yes</label>
                            <label>performance</label>
                            <label>regression</label>
                            <label>threads</label>
                    </labels>
                <created>Wed, 5 Apr 2023 10:26:05 -0700</created>
                <updated>Mon, 24 Jul 2023 22:11:20 -0700</updated>
                            <resolved>Sat, 13 May 2023 07:47:18 -0700</resolved>
                                    <version>17</version>
                    <version>21</version>
                                    <fixVersion>21</fixVersion>
                                    <component>hotspot</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>13</watches>
                                                                                                                                                            <comments>
                            <comment id="14597748" author="goetz" created="Thu, 20 Jul 2023 22:31:24 -0700"  >Fix request [17u]&lt;br/&gt;
&lt;br/&gt;
I backport this for parity with 17.0.9-oracle.&lt;br/&gt;
Medium risk&lt;br/&gt;
Trivial resolve needed.&lt;br/&gt;
SAP nightly testing passed. </comment>
                            <comment id="14597579" author="roboduke" created="Thu, 20 Jul 2023 05:27:39 -0700"  >A pull request was submitted for review.&lt;br/&gt;
URL: &lt;a href=&quot;https://git.openjdk.org/jdk17u-dev/pull/1604&quot;&gt;https://git.openjdk.org/jdk17u-dev/pull/1604&lt;/a&gt;&lt;br/&gt;
Date: 2023-07-20 12:22:34 +0000</comment>
                            <comment id="14581360" author="dukebot" created="Sat, 13 May 2023 07:47:17 -0700"  >Changeset: f030937a&lt;br/&gt;
Author:    Daniel D. Daugherty &amp;lt;&lt;a href=&apos;mailto:dcubed@openjdk.org&apos;&gt;dcubed@openjdk.org&lt;/a&gt;&amp;gt;&lt;br/&gt;
Date:      2023-05-13 14:44:57 +0000&lt;br/&gt;
URL:       &lt;a href=&quot;https://git.openjdk.org/jdk/commit/f030937a51b95dde33ce33537ee830153b2c3b56&quot;&gt;https://git.openjdk.org/jdk/commit/f030937a51b95dde33ce33537ee830153b2c3b56&lt;/a&gt;&lt;br/&gt;
</comment>
                            <comment id="14580638" author="dcubed" created="Wed, 10 May 2023 11:49:15 -0700"  >Mach5 test results for the v07 version of the PR which is baselined on jdk-21+20&lt;br/&gt;
and includes the dependent patches for &lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8307067&quot; title=&quot;remove broken EnableThreadSMRExtraValidityChecks option&quot; class=&quot;issue-link&quot; data-issue-key=&quot;JDK-8307067&quot;&gt;&lt;strike&gt;JDK-8307067&lt;/strike&gt;&lt;/a&gt; and &lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8307068&quot; title=&quot;store a JavaThread* in the java.lang.Thread object after the JavaThread* is added to the main ThreadsList&quot; class=&quot;issue-link&quot; data-issue-key=&quot;JDK-8307068&quot;&gt;&lt;strike&gt;JDK-8307068&lt;/strike&gt;&lt;/a&gt;:&lt;br/&gt;
&lt;br/&gt;
Mach5 Tier1:&lt;br/&gt;
- no failures&lt;br/&gt;
&lt;br/&gt;
Mach5 Tier2:&lt;br/&gt;
- no failures&lt;br/&gt;
&lt;br/&gt;
Mach5 Tier3:&lt;br/&gt;
- no failures &lt;br/&gt;
&lt;br/&gt;
I&amp;#39;m about to rebase the group of patches to the latest jdk/jdk repo in&lt;br/&gt;
preparation for possible integration.</comment>
                            <comment id="14578882" author="dcubed" created="Wed, 3 May 2023 13:38:25 -0700"  >This bug fix (&lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8305670&quot; title=&quot;Performance regression in LockSupport.unpark with lots of idle threads&quot; class=&quot;issue-link&quot; data-issue-key=&quot;JDK-8305670&quot;&gt;&lt;strike&gt;JDK-8305670&lt;/strike&gt;&lt;/a&gt;) depends on the following bug fix:&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8307068&quot; title=&quot;store a JavaThread* in the java.lang.Thread object after the JavaThread* is added to the main ThreadsList&quot; class=&quot;issue-link&quot; data-issue-key=&quot;JDK-8307068&quot;&gt;&lt;strike&gt;JDK-8307068&lt;/strike&gt;&lt;/a&gt; store a JavaThread* in the java.lang.Thread object after the JavaThread* is added to the main ThreadsList&lt;br/&gt;
&lt;br/&gt;
in order to function properly. If this bug fix (&lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8305670&quot; title=&quot;Performance regression in LockSupport.unpark with lots of idle threads&quot; class=&quot;issue-link&quot; data-issue-key=&quot;JDK-8305670&quot;&gt;&lt;strike&gt;JDK-8305670&lt;/strike&gt;&lt;/a&gt;) is&lt;br/&gt;
backported, then &lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8307068&quot; title=&quot;store a JavaThread* in the java.lang.Thread object after the JavaThread* is added to the main ThreadsList&quot; class=&quot;issue-link&quot; data-issue-key=&quot;JDK-8307068&quot;&gt;&lt;strike&gt;JDK-8307068&lt;/strike&gt;&lt;/a&gt; must also be backported.</comment>
                            <comment id="14578879" author="dcubed" created="Wed, 3 May 2023 13:33:51 -0700"  >Mach5 test results for the v05 version of the PR which is baselined on jdk-21+20&lt;br/&gt;
and includes the dependent patches for &lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8307067&quot; title=&quot;remove broken EnableThreadSMRExtraValidityChecks option&quot; class=&quot;issue-link&quot; data-issue-key=&quot;JDK-8307067&quot;&gt;&lt;strike&gt;JDK-8307067&lt;/strike&gt;&lt;/a&gt; and &lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8307068&quot; title=&quot;store a JavaThread* in the java.lang.Thread object after the JavaThread* is added to the main ThreadsList&quot; class=&quot;issue-link&quot; data-issue-key=&quot;JDK-8307068&quot;&gt;&lt;strike&gt;JDK-8307068&lt;/strike&gt;&lt;/a&gt;:&lt;br/&gt;
&lt;br/&gt;
Mach5 Tier1&lt;br/&gt;
- no failures&lt;br/&gt;
&lt;br/&gt;
Mach5 Tier2&lt;br/&gt;
- no failures&lt;br/&gt;
&lt;br/&gt;
Mach5 Tier3&lt;br/&gt;
- no failures&lt;br/&gt;
&lt;br/&gt;
Mach5 Tier4&lt;br/&gt;
- no failures&lt;br/&gt;
&lt;br/&gt;
Mach5 Tier5&lt;br/&gt;
- 1 known, unrelated test failure:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;- java/lang/Thread/virtual/HoldsLock.java#id0 failed due to &lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8305919&quot; title=&quot;java/lang/Thread/virtual/HoldsLock.java#id0 failed, ThreadInfo.getLockInfo() return null&quot; class=&quot;issue-link&quot; data-issue-key=&quot;JDK-8305919&quot;&gt;&lt;strike&gt;JDK-8305919&lt;/strike&gt;&lt;/a&gt;&lt;br/&gt;
&lt;br/&gt;
Mach5 Tier6&lt;br/&gt;
- no failures&lt;br/&gt;
&lt;br/&gt;
Mach5 Tier7&lt;br/&gt;
- no failures&lt;br/&gt;
&lt;br/&gt;
Mach5 Tier8&lt;br/&gt;
- 2 known, unrelated test failures:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;- vmTestbase/runtime/jni/LoadTests/LoadTests.java failed due to JDK-8306754&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;- java/lang/Thread/virtual/HoldsLock.java#id0 failed due to &lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8305919&quot; title=&quot;java/lang/Thread/virtual/HoldsLock.java#id0 failed, ThreadInfo.getLockInfo() return null&quot; class=&quot;issue-link&quot; data-issue-key=&quot;JDK-8305919&quot;&gt;&lt;strike&gt;JDK-8305919&lt;/strike&gt;&lt;/a&gt;</comment>
                            <comment id="14575484" author="dcubed" created="Thu, 20 Apr 2023 10:40:10 -0700"  >[~apangin] - Thanks for the info. [~ecaspole]&amp;#39;s reply isn&amp;#39;t visible because it contains&lt;br/&gt;
Oracle internal URLs. The summary is that he&amp;#39;s adapted the sample program into&lt;br/&gt;
a JMH and is doing testing on our performance machines.</comment>
                            <comment id="14575206" author="apangin" created="Wed, 19 Apr 2023 16:02:33 -0700"  >The issue is observed on ARM64 hardware: for instance, Ampere A1 machines in Oracle Cloud.&lt;br/&gt;
&lt;br/&gt;
$ uname -a&lt;br/&gt;
Linux arm1 5.15.0-1033-oracle #39-Ubuntu SMP Mon Apr 3 14:10:58 UTC 2023 aarch64 aarch64 aarch64 GNU/Linux&lt;br/&gt;
&lt;br/&gt;
$ /usr/lib/jvm/java-8-openjdk-arm64/bin/java -version&lt;br/&gt;
openjdk version &amp;quot;1.8.0_362&amp;quot;&lt;br/&gt;
OpenJDK Runtime Environment (build 1.8.0_362-8u362-ga-0ubuntu1~22.04-b09)&lt;br/&gt;
OpenJDK 64-Bit Server VM (build 25.362-b09, mixed mode)&lt;br/&gt;
&lt;br/&gt;
$ jdk-21/bin/java -version&lt;br/&gt;
openjdk version &amp;quot;21-ea&amp;quot; 2023-09-19&lt;br/&gt;
OpenJDK Runtime Environment (build 21-ea+18-1480)&lt;br/&gt;
OpenJDK 64-Bit Server VM (build 21-ea+18-1480, mixed mode, sharing)</comment>
                            <comment id="14575197" author="dcubed" created="Wed, 19 Apr 2023 15:04:29 -0700"  >[~apangin] - We&amp;#39;re having trouble reproducing improvements with the current&lt;br/&gt;
patch in our environments relative to 8u371. Please provide more exact&lt;br/&gt;
version info for JDK8u and JDK21 and for the machines on which you&amp;#39;ve&lt;br/&gt;
seen this issue and the improvement.</comment>
                            <comment id="14574824" author="roboduke" created="Tue, 18 Apr 2023 14:24:06 -0700"  >A pull request was submitted for review.&lt;br/&gt;
URL: &lt;a href=&quot;https://git.openjdk.org/jdk/pull/13519&quot;&gt;https://git.openjdk.org/jdk/pull/13519&lt;/a&gt;&lt;br/&gt;
Date: 2023-04-18 21:09:54 +0000</comment>
                            <comment id="14574014" author="dholmes" created="Sun, 16 Apr 2023 15:48:46 -0700"  >Ah I see my mistake now. The issue Robbin found only becomes a problem if we don&amp;#39;t check includes() inside cv_internal_thread_to_JavaThread. There are a number of other places where the JavaThread is extracted from eetop but they also seem to be correctly protected one way or another.</comment>
                            <comment id="14573988" author="dholmes" created="Sat, 15 Apr 2023 22:56:17 -0700"  >[~dcubed] Robbin has identified a bug with the existing code due to allowing the JavaThread* to escape via eetop before it has been added to the threads-list. That needs fixing independent of the performance issue with checking includes(). As such it would be better to fix it under its own issue.&lt;br/&gt;
&lt;br/&gt;
BTW eetop -&amp;gt; &amp;quot;execution environment top&amp;quot; from classic VM days - JDK 1.0 (and likely earlier). I suspect over the years there have been &amp;quot;tools&amp;quot; that would peek at this field to gain access to the underlying VM object and so renaming it would have been problematic</comment>
                            <comment id="14573894" author="dcubed" created="Fri, 14 Apr 2023 11:11:42 -0700"  >[~dholmes] - Perhaps a split would be useful, but the only reason for making the&lt;br/&gt;
changes to when we save the JavaThread* in the java.lang.Thread object is because&lt;br/&gt;
we want to speed up cv_internal_thread_to_JavaThread(). If we aren&amp;#39;t trying to add&lt;br/&gt;
a quick_mode to cv_internal_thread_to_JavaThread(), then we don&amp;#39;t have to do&lt;br/&gt;
anything to when we save the JavaThread* in the java.lang.Thread object.&lt;br/&gt;
&lt;br/&gt;
I&amp;#39;m wrapping up the merge of my (mostly comments) work with [~rehn]&amp;#39;s quick_mode&lt;br/&gt;
work and then I&amp;#39;m going to do more testing before spinning up a new PR. I&amp;#39;m going to&lt;br/&gt;
withdraw the old PR to avoid confusion.&lt;br/&gt;
&lt;br/&gt;
P.S. Yes, I very much dislike the &amp;quot;eetop&amp;quot; name for the field where we store the&lt;br/&gt;
JavaThread* in the java.lang.Thread object. For some reason, that name has no&lt;br/&gt;
meaning to me at all.</comment>
                            <comment id="14573704" author="dholmes" created="Thu, 13 Apr 2023 15:59:26 -0700"  >I think we perhaps should split out the fix to prevent eetop from exposing a JavaThread that is not on a Threads-list and so cannot be guarded by a TLH. After that we can re-reason about the need for the includes() call in this issue and address that.</comment>
                            <comment id="14573685" author="dcubed" created="Thu, 13 Apr 2023 13:22:24 -0700"  >[~rehn] - I&amp;#39;ve verified that your patch also prevents the following two tests from crashing:&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;runtime/handshake/HandshakeWalkOneExitTest.java&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;runtime/handshake/HandshakeDirectTest.java&lt;br/&gt;
&lt;br/&gt;
I&amp;#39;m going to take a closer look at your patch and merge some of my&lt;br/&gt;
comment changes with your changes (if appropriate).</comment>
                            <comment id="14573647" author="dcubed" created="Thu, 13 Apr 2023 11:02:53 -0700"  >I&amp;#39;m having API indigestion with the idea that we need to add a check for&lt;br/&gt;
the JavaThread&amp;#39;s thread state not being &amp;quot;NEW&amp;quot; before we create a&lt;br/&gt;
ThreadsListHandle. That&amp;#39;s just down right ugly... :-)&lt;br/&gt;
&lt;br/&gt;
Here&amp;#39;s our description of the Thread-SMR API from:&lt;br/&gt;
&lt;br/&gt;
src/hotspot/share/runtime/threadSMR.hpp:&lt;br/&gt;
&lt;br/&gt;
// Thread Safe Memory Reclamation (Thread-SMR) support.&lt;br/&gt;
//&lt;br/&gt;
// ThreadsListHandles are used to safely perform operations on one or more&lt;br/&gt;
// threads without the risk of the thread or threads exiting during the&lt;br/&gt;
// operation. It is no longer necessary to hold the Threads_lock to safely&lt;br/&gt;
// perform an operation on a target thread.&lt;br/&gt;
//&lt;br/&gt;
// There are several different ways to refer to java.lang.Thread objects&lt;br/&gt;
// so we have a few ways to get a protected JavaThread *:&lt;br/&gt;
//&lt;br/&gt;
// JNI jobject example:&lt;br/&gt;
//   jobject jthread = ...;&lt;br/&gt;
//   :&lt;br/&gt;
//   ThreadsListHandle tlh;&lt;br/&gt;
//   JavaThread* jt = nullptr;&lt;br/&gt;
//   bool is_alive = tlh.cv_internal_thread_to_JavaThread(jthread, &amp;amp;jt, nullptr);&lt;br/&gt;
//   if (is_alive) {&lt;br/&gt;
//     :  // do stuff with &amp;#39;jt&amp;#39;...&lt;br/&gt;
//   }&lt;br/&gt;
//&lt;br/&gt;
// JVM/TI jthread example:&lt;br/&gt;
//   jthread thread = ...;&lt;br/&gt;
//   :&lt;br/&gt;
//   JavaThread* jt = nullptr;&lt;br/&gt;
//   ThreadsListHandle tlh;&lt;br/&gt;
//   jvmtiError err = JvmtiExport::cv_external_thread_to_JavaThread(tlh.list(), thread, &amp;amp;jt, nullptr);&lt;br/&gt;
//   if (err != JVMTI_ERROR_NONE) {&lt;br/&gt;
//     return err;&lt;br/&gt;
//   }&lt;br/&gt;
//   :  // do stuff with &amp;#39;jt&amp;#39;...&lt;br/&gt;
//&lt;br/&gt;
// JVM/TI oop example (this one should be very rare):&lt;br/&gt;
//   oop thread_obj = ...;&lt;br/&gt;
//   :&lt;br/&gt;
//   JavaThread *jt = nullptr;&lt;br/&gt;
//   ThreadsListHandle tlh;&lt;br/&gt;
//   jvmtiError err = JvmtiExport::cv_oop_to_JavaThread(tlh.list(), thread_obj, &amp;amp;jt);&lt;br/&gt;
//   if (err != JVMTI_ERROR_NONE) {&lt;br/&gt;
//     return err;&lt;br/&gt;
//   }&lt;br/&gt;
//   :  // do stuff with &amp;#39;jt&amp;#39;...&lt;br/&gt;
//&lt;br/&gt;
// A JavaThread * that is included in the ThreadsList that is held by&lt;br/&gt;
// a ThreadsListHandle is protected as long as the ThreadsListHandle&lt;br/&gt;
// remains in scope. The target JavaThread * may have logically exited,&lt;br/&gt;
// but that target JavaThread * will not be deleted until it is no&lt;br/&gt;
// longer protected by a ThreadsListHandle.&lt;br/&gt;
&lt;br/&gt;
[~rehn] - Thanks for changeset! I will check it out in a few minutes.</comment>
                            <comment id="14573562" author="rehn" created="Thu, 13 Apr 2023 05:41:09 -0700"  >[~dholmes] No my bad, I need to explain better and read more carefully, sorry.</comment>
                            <comment id="14573556" author="dholmes" created="Thu, 13 Apr 2023 05:26:26 -0700"  >[~rehn] Apologies. I was reading:&lt;br/&gt;
&lt;br/&gt;
java_lang_Thread::set_thread(thread_oop(), this);&lt;br/&gt;
&lt;br/&gt;
as the setting of threadObj (and wrote that 3 times above with no one calling me out for it :( ), but it is the setting of eetop as you note.&lt;br/&gt;
&lt;br/&gt;
I would still be wary of exposing the JavaThread in the Threads-list when the j.l.Thread &amp;lt;-&amp;gt;JavaThread connection is only half in place (though at worst I would anticipate an asertion failure). But you are right that we already similarly expose it via the eetop field in a way that is in fact dangerous as any TLH we create to guard it won&amp;#39;t in fact do so! That is a significant bug in the existing code!</comment>
                            <comment id="14573517" author="rehn" created="Thu, 13 Apr 2023 02:39:18 -0700"  >[~dcubed] &lt;a href=&quot;https://github.com/openjdk/jdk/compare/master...robehn:jdk:double-check?expand=1&quot;&gt;https://github.com/openjdk/jdk/compare/master...robehn:jdk:double-check?expand=1&lt;/a&gt;&lt;br/&gt;
Maybe I missed something again but above seems to work for me.&lt;br/&gt;
Since we know eetop is not null before we create ThreadsList, which means it must still be there if it&amp;#39;s still non null.</comment>
                            <comment id="14573505" author="rehn" created="Thu, 13 Apr 2023 01:18:35 -0700"  >In JNI case we seem to already do it this way, we first create JavaThread and Threads:add(), then we create Thread obj and set eetop.&lt;br/&gt;
So we already have the invariant with JavaThread on ThreadsList, but eetop still NULL.</comment>
                            <comment id="14573497" author="rehn" created="Thu, 13 Apr 2023 00:39:02 -0700"  >1: j.l.Thread is created, eetop = NULL. This is globally visible.&lt;br/&gt;
2: We create a JavaThread to start this Thread.&lt;br/&gt;
3: We store eetop = JavaThread*. JavaThread* is now globally visible via eetop, but still not on ThreadsList. Hence we cannot dereference it.&lt;br/&gt;
4: We add JavaThread to ThreadsList.&lt;br/&gt;
&lt;br/&gt;
If we swap 3&amp;lt;-&amp;gt;4&lt;br/&gt;
&lt;br/&gt;
3: We add JavaThread to ThreadsList. JavaThread* is now globally visible via ThreadsList, but not via eetop. We can deference it since it is on ThreadsList.&lt;br/&gt;
4: We store eetop = JavaThread*.&lt;br/&gt;
&lt;br/&gt;
Publishing a pointer which cannot be validated is not so nice. Adding to ThreadsList before publishing seem safer and nicer.&lt;br/&gt;
And there is no change in visibility, both cases gets publish in step 3, but via Thread obj vs ThreadsList.&lt;br/&gt;
&lt;br/&gt;
That is what I mean.&lt;br/&gt;
</comment>
                            <comment id="14573430" author="dholmes" created="Wed, 12 Apr 2023 14:54:29 -0700"  >&amp;gt; Be move is from just above Threads::add(this); to under it, so exposure is the same.&lt;br/&gt;
&lt;br/&gt;
I don&amp;#39;t know what you mean by this. There is no exposure with the current code. As soon as you publish the thread via Threads:add it can be found by other logic which can then see a null threadObj. This is a risky change and not necessary.</comment>
                            <comment id="14573422" author="dcubed" created="Wed, 12 Apr 2023 14:07:43 -0700"  >When I did the experiment to move &amp;quot;java_lang_Thread::set_thread()&amp;quot;&lt;br/&gt;
after &amp;quot;Threads::add()&amp;quot;, it had to be done in two places:&lt;br/&gt;
&lt;br/&gt;
--- a/src/hotspot/share/runtime/javaThread.cpp&lt;br/&gt;
+++ b/src/hotspot/share/runtime/javaThread.cpp&lt;br/&gt;
@@ -1656,7 +1656,6 @@ void JavaThread::prepare(jobject jni_thread, ThreadPriority prio) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;assert(InstanceKlass::cast(thread_oop-&amp;gt;klass())-&amp;gt;is_linked(),&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;quot;must be initialized&amp;quot;);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;set_threadOopHandles(thread_oop());&lt;br/&gt;
-  java_lang_Thread::set_thread(thread_oop(), this);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;if (prio == NoPriority) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;prio = java_lang_Thread::priority(thread_oop());&lt;br/&gt;
@@ -1672,6 +1671,9 @@ void JavaThread::prepare(jobject jni_thread, ThreadPriority prio) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;// added to the Threads list for if a GC happens, then the java_thread oop&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;// will not be visited by GC.&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;Threads::add(this);&lt;br/&gt;
+  // Publish the JavaThread* in java.lang.Thread after the JavaThread* is&lt;br/&gt;
+  // on a ThreadsList.&lt;br/&gt;
+  java_lang_Thread::set_thread(thread_oop(), this);&lt;br/&gt;
&amp;nbsp;}&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;oop JavaThread::current_park_blocker() {&lt;br/&gt;
@@ -2094,10 +2096,6 @@ void JavaThread::start_internal_daemon(JavaThread* current, JavaThread* target,&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;MutexLocker mu(current, Threads_lock);&lt;br/&gt;
&lt;br/&gt;
-  // Initialize the fields of the thread_oop first.&lt;br/&gt;
-&lt;br/&gt;
-  java_lang_Thread::set_thread(thread_oop(), target); // isAlive == true now&lt;br/&gt;
-&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;if (prio != NoPriority) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;java_lang_Thread::set_priority(thread_oop(), prio);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// Note: we don&amp;#39;t call os::set_priority here. Possibly we should,&lt;br/&gt;
@@ -2110,6 +2108,9 @@ void JavaThread::start_internal_daemon(JavaThread* current, JavaThread* target,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;target-&amp;gt;set_threadOopHandles(thread_oop());&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;Threads::add(target); // target is now visible for safepoint/handshake&lt;br/&gt;
+  // Publish the JavaThread* in java.lang.Thread after the JavaThread* is&lt;br/&gt;
+  // on a ThreadsList.&lt;br/&gt;
+  java_lang_Thread::set_thread(thread_oop(), target); // isAlive == true now&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;Thread::start(target);&lt;br/&gt;
&amp;nbsp;}&lt;br/&gt;
&lt;br/&gt;
And I didn&amp;#39;t play with this patch a whole lot because it didn&amp;#39;t fix the&lt;br/&gt;
racing issue. I&amp;#39;ll take a look the 11 comments posted since I last touched&lt;br/&gt;
this bug last night and see how I want to proceed.&lt;br/&gt;
&lt;br/&gt;
My current gut feel is that we (me included) are mulling on adding even more&lt;br/&gt;
brittle logic to potentially solve a performance issue. Hoops and checks and&lt;br/&gt;
complicated comments to explain it all. I&amp;#39;m starting to wonder if I should just&lt;br/&gt;
bite the bullet and write the code to speed up ThreadsListHandle.contains()...</comment>
                            <comment id="14573313" author="rehn" created="Wed, 12 Apr 2023 06:39:56 -0700"  >If we remove the j.l.Thread.State, the internal VM works just fine. There no code at all inside the VM which uses that state to take any action.&lt;br/&gt;
&lt;br/&gt;
Be move is from just above Threads::add(this); to under it, so exposure is the same.&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
</comment>
                            <comment id="14573306" author="dholmes" created="Wed, 12 Apr 2023 05:45:56 -0700"  >I totally disagree sorry - the state of a j.l.Thread and its associated JavaThread are tightly interwined. The thread startup process is not something that fluctuates or is likely to change.&lt;br/&gt;
&lt;br/&gt;
The reorder is potentially bad because it can expose a JavaThread that has a null threadObj and that is something that is only expected in very specific circumstances (primarily JNI attaching threads).</comment>
                            <comment id="14573285" author="rehn" created="Wed, 12 Apr 2023 03:49:39 -0700"  >j.l.Thread.State represent the state a of thread in the Java virtual machine.&lt;br/&gt;
This have no direct relationship with the lifetime of JavaThread* and ThreadsList.&lt;br/&gt;
&lt;br/&gt;
The point of &amp;quot;once a Thread moves out of the NEW&amp;quot; can be at anytime from a ThreadsList/JavaThread* POV, it just happen to be correct at the moment.&lt;br/&gt;
&lt;br/&gt;
If we use it, we involve yet another variable in the thread lifecycle, we already have to many.&lt;br/&gt;
Therefore I prefer using those we already have.&lt;br/&gt;
&lt;br/&gt;
EDIT:&lt;br/&gt;
If we need we could do SENTINEL =&amp;gt; JavaThread* =&amp;gt; NULL, but yes that involves the reorder.&lt;br/&gt;
I don&amp;#39;t see directly why that is a bad idea?&lt;br/&gt;
&lt;br/&gt;
Anyhow that is a double read of eetop, one before TLH and one after.&lt;br/&gt;
&lt;br/&gt;
(boolean alive() could check TERMINATED instead.)&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
</comment>
                            <comment id="14573267" author="dholmes" created="Wed, 12 Apr 2023 02:14:49 -0700"  >&amp;gt; I don&amp;#39;t think it&amp;#39;s a good idea to use a Java (j.l.Thread.State) level state to determine if a JavaThread* is on a ThreadsList without walking it.&lt;br/&gt;
&lt;br/&gt;
What are you concerned about? We know that once a Thread moves out of the NEW state then it&amp;#39;s JavaThread has been added to the main threads-list, so any TLH created thereafter will capture that JavaThread unless it has terminated - which is also determined by examining the state of the j.l.Thread (just a different bit of state).&lt;br/&gt;
&lt;br/&gt;
I don&amp;#39;t think it is a good idea to reorder Threads::add and set_thread() as noted above.</comment>
                            <comment id="14573228" author="rehn" created="Tue, 11 Apr 2023 23:30:51 -0700"  >I don&amp;#39;t think it&amp;#39;s a good idea to use a Java (j.l.Thread.State) level state to determine if a JavaThread* is on a ThreadsList without walking it.&lt;br/&gt;
&lt;br/&gt;
I rather do the double read of eetop.&lt;br/&gt;
&lt;br/&gt;
</comment>
                            <comment id="14573198" author="apangin" created="Tue, 11 Apr 2023 19:11:52 -0700"  >[~dholmes] Seems you are right. Checking thread status before TLH should work then.</comment>
                            <comment id="14573197" author="dholmes" created="Tue, 11 Apr 2023 18:50:52 -0700"  >But thinking more. Thread::start is called after prepare() which means after Threads:add(). So if we see the target thread is RUNNABLE it must be on the main threads-list, so if we create the TLH after that then we must still be guaranteed to capture the newly started JavaThread.</comment>
                            <comment id="14573196" author="dholmes" created="Tue, 11 Apr 2023 18:45:20 -0700"  >I could have sworn the thread set its own state to RUNNABLE - drat! I can&amp;#39;t immediately see why it can&amp;#39;t set its own state in JavaThread::run ??&lt;br/&gt;
&lt;br/&gt;
I&amp;#39;m very wary about changing the order of Threads::add and set_thread() as I think it would expose a partially initialized JavaThread that would then require all the native thread processing code to always have to watch for a null threadObj. I think it would take a long time for bugs to show up there.</comment>
                            <comment id="14573193" author="apangin" created="Tue, 11 Apr 2023 18:11:21 -0700"  >I had a similar idea, but realized it will not work with a naive implementation, since the thread status is set to RUNNABLE before the thread actually starts:&lt;br/&gt;
&lt;br/&gt;
void Thread::start(Thread* thread) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;// Start is different from resume in that its safety is guaranteed by context or&lt;br/&gt;
&amp;nbsp;&amp;nbsp;// being called from a Java method synchronized on the Thread object.&lt;br/&gt;
&amp;nbsp;&amp;nbsp;if (thread-&amp;gt;is_Java_thread()) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// Initialize the thread state to RUNNABLE before starting this thread.&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// Can not set it after the thread started because we do not know the&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// exact thread state at that time. It could be in MONITOR_WAIT or&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// in SLEEPING or some other state.&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;java_lang_Thread::set_thread_status(JavaThread::cast(thread)-&amp;gt;threadObj(),&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;JavaThreadStatus::RUNNABLE);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;os::start_thread(thread);&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
Alternatively, we could check &amp;#39;eetop&amp;#39; field twice: the first time before TLH creation, and the second time afterwards. This requires changing the order of Threads::add() and java_lang_Thread::set_thread() calls as [~rehn] suggested above. However, I&amp;#39;m not sure this change is correct - need to check carefully if this breaks some other invariant.</comment>
                            <comment id="14573189" author="dholmes" created="Tue, 11 Apr 2023 17:34:57 -0700"  >I think we may be able to address the startup issue by checking the state of the j.l.Thread before we create the TLH. If the Thread is in threadStatus state NEW then it is unstarted; otherwise we create the TLH and then extract the JavaThread from eetop, now guaranteed that the JavaThread had to be captured by the TLH. Unfortunately this means all callers of cv_internal_thread_to_JavaThread have to perform this check (and cv_internal_thread_to_JavaThread should assert threadStatus != NEW). This really messes up the intent to have all such logic encapsulated by the TLH, but I don&amp;#39;t see any other way (other than continue to check tlh.includes()).</comment>
                            <comment id="14573179" author="dholmes" created="Tue, 11 Apr 2023 15:30:45 -0700"  >Right got it. If the thread was already started then it can&amp;#39;t have terminated but it is possible to find a newly starting thread that is not in the TLH. &lt;br/&gt;
&lt;br/&gt;
So suppose this newly starting thread is short-lived and runs to completion, it could in fact terminate and be deleted while the code with the TLH tries to operate on it!</comment>
                            <comment id="14573178" author="dcubed" created="Tue, 11 Apr 2023 15:19:19 -0700"  >An observer can create a ThreadsListHandle that does not include a newly started&lt;br/&gt;
thread that hasn&amp;#39;t been added to the system ThreadsList yet. However, by the time&lt;br/&gt;
that the observer code gets to cv_internal_thread_to_JavaThread(), the newly created&lt;br/&gt;
JavaThread has passed all the conditions that we can check inside that function to see&lt;br/&gt;
that the java_thread we&amp;#39;re trying to convert is/was new. So if the observer thread&amp;#39;s call&lt;br/&gt;
into cv_internal_thread_to_JavaThread() tries to assert that the newly started thread is&lt;br/&gt;
on &amp;quot;this&amp;quot; ThreadsList, that will fail because it does not contain the newly created&lt;br/&gt;
JavaThread because the ThreadsList was created before that JavaThread got going...</comment>
                            <comment id="14573176" author="dholmes" created="Tue, 11 Apr 2023 15:07:43 -0700"  >I&amp;#39;m trying to read between the lines here but am struggling a bit. What exactly is the problematic scenario for thread startup?&lt;br/&gt;
&lt;br/&gt;
The JavaThread &amp;lt;-&amp;gt; j.l.Thread two-way connection should be established before the new JavaThread is published on the threads-list. That ensures it is fully initialized before becoming visible to other code that interacts with threads. Top me this is a desired invariant and not something to mess with.</comment>
                            <comment id="14573172" author="dcubed" created="Tue, 11 Apr 2023 14:36:31 -0700"  >[~rehn] - Sorry the race is still there. The creation of the ThreadsListHandle&lt;br/&gt;
in the observer can be followed by a pause in the observer such that the&lt;br/&gt;
target JavaThread has been added to the system ThreadsList _and_ has&lt;br/&gt;
published its eetop field in the java.lang.Thread so when the observer thread&lt;br/&gt;
resumes, it will see a non-nullptr value from eetop in java.lang.Thread so&lt;br/&gt;
the observer will think that the JavaThread is on the ThreadsList created&lt;br/&gt;
in the caller, but it is not.</comment>
                            <comment id="14573162" author="dcubed" created="Tue, 11 Apr 2023 13:29:34 -0700"  >[~rehn] - Very interesting idea. I&amp;#39;ll take a look...</comment>
                            <comment id="14573160" author="rehn" created="Tue, 11 Apr 2023 13:19:43 -0700"  >Nice one.&lt;br/&gt;
&lt;br/&gt;
eetop may only be non-null while on ThreadsList.&lt;br/&gt;
When we start we set it before we are on it.&lt;br/&gt;
I think this maybe fixes it:&lt;br/&gt;
&lt;br/&gt;
diff --git a/src/hotspot/share/runtime/javaThread.cpp b/src/hotspot/share/runtime/javaThread.cpp&lt;br/&gt;
index 9eee1028c86..7f835065891 100644&lt;br/&gt;
--- a/src/hotspot/share/runtime/javaThread.cpp&lt;br/&gt;
+++ b/src/hotspot/share/runtime/javaThread.cpp&lt;br/&gt;
@@ -1658,3 +1658,2 @@ void JavaThread::prepare(jobject jni_thread, ThreadPriority prio) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;set_threadOopHandles(thread_oop());&lt;br/&gt;
-  java_lang_Thread::set_thread(thread_oop(), this);&lt;br/&gt;
&amp;nbsp;&lt;br/&gt;
@@ -1674,2 +1673,3 @@ void JavaThread::prepare(jobject jni_thread, ThreadPriority prio) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;Threads::add(this);&lt;br/&gt;
+  java_lang_Thread::set_thread(thread_oop(), this);&lt;br/&gt;
&amp;nbsp;}&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
Writer do:&lt;br/&gt;
Add JavaThread to ThreadsList&lt;br/&gt;
Publish by setting eetop to JavaThread&lt;br/&gt;
...&lt;br/&gt;
De-publish by setting eetop to NULL (ensure_join())&lt;br/&gt;
Remove JavaThread from ThreadsList&lt;br/&gt;
&lt;br/&gt;
Reader do:&lt;br/&gt;
Take a ThreadsList&lt;br/&gt;
Read eetop, if non-null it should be on that list</comment>
                            <comment id="14573158" author="dcubed" created="Tue, 11 Apr 2023 12:59:29 -0700"  >So I&amp;#39;ve taken a close look at the starting JavaThread case and I agree that&lt;br/&gt;
is the case that explains my race observations with the new assert() in the&lt;br/&gt;
comments above. [~apangin] - thanks for sending me down the proper path.&lt;br/&gt;
&lt;br/&gt;
So there is no way to definitively distinguish that we&amp;#39;re in the newly starting&lt;br/&gt;
JavaThread case and thereby keep the new assertion (with a bail out for the&lt;br/&gt;
newly starting JavaThread case). So while I think we&amp;#39;ve adequately proven&lt;br/&gt;
that the exiting JavaThread case doesn&amp;#39;t require the ThreadsList search, we&lt;br/&gt;
have to do the search for the newly starting JavaThread case.&lt;br/&gt;
&lt;br/&gt;
I&amp;#39;m going to remove the EnableThreadSMRExtraValidityChecks option,&lt;br/&gt;
remove the new assertion and refine and update the comments. I&amp;#39;m also&lt;br/&gt;
going to look at speeding up the &amp;#39;includes()&amp;#39; function. It&amp;#39;ll be a little while&lt;br/&gt;
before I take the PR back out of draft mode.</comment>
                            <comment id="14573111" author="dcubed" created="Tue, 11 Apr 2023 10:10:09 -0700"  >[~apangin] - Interesting idea. I&amp;#39;ve been focused on the JavaThread exit code paths&lt;br/&gt;
that I hadn&amp;#39;t much thought about the JavaThread start code paths. Here&amp;#39;s [~rehn]&amp;#39;s&lt;br/&gt;
description for the two tests:&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;* @test HandshakeWalkOneExitTest&lt;br/&gt;
&amp;nbsp;* @summary This test tries to stress the handshakes with new and exiting threads&lt;br/&gt;
&lt;br/&gt;
and&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;* @test HandshakeDirectTest&lt;br/&gt;
&amp;nbsp;* @bug 8240918&lt;br/&gt;
&amp;nbsp;* @summary This test tries to stress direct handshakes between threads while suspending them.&lt;br/&gt;
&lt;br/&gt;
HandshakeWalkOneExitTest is the one that is most reproducible for me...&lt;br/&gt;
&lt;br/&gt;
[~dholmes] - &amp;quot;... then we have a bug somewhere.&amp;quot;&lt;br/&gt;
That&amp;#39;s exactly what I&amp;#39;m trying to figure out. Things are not quite working&lt;br/&gt;
the way I think they should and that&amp;#39;s why the assertion is firing. Of course,&lt;br/&gt;
based on what [~apangin] wrote, that assertion might be invalid for the&lt;br/&gt;
early startup of new threads. I have to investigate from that angle...</comment>
                            <comment id="14572920" author="dholmes" created="Mon, 10 Apr 2023 19:20:01 -0700"  >I really struggled to try and follow that explanation. A JavaThread can&amp;#39;t be recycled until it no longer appears on any threads-list. A thread oop can&amp;#39;t be storing a non-null JavaThread address after the JavaThread has exited/terminated died. If either of those statements is appearing to not be true then we have a bug somewhere.</comment>
                            <comment id="14572897" author="apangin" created="Mon, 10 Apr 2023 15:21:59 -0700"  >I suppose the issue happens not with an exited thread, but with a not-yet-started one.&lt;br/&gt;
&lt;br/&gt;
&amp;#39;hst&amp;#39; thread in the test accesses &amp;#39;threads&amp;#39; array which is recreated from scratch multiple times. At some point it may contain a java.lang.Thread object which is already constructed but not yet started. This thread is started after ThreadListHandle in WB_HandshakeWalkStack is created, but before java_lang_Thread::thread(thread_oop) is called.&lt;br/&gt;
&lt;br/&gt;
Does this sound like a plausible explanation? (I haven&amp;#39;t verified it yet)</comment>
                            <comment id="14572892" author="dcubed" created="Mon, 10 Apr 2023 15:01:37 -0700"  >Hmmm... I had forgotten that we converted the java.lang.Thread oop that&lt;br/&gt;
we&amp;#39;re holding in the JavaThread* into an OopHandle. Those OopHandles&lt;br/&gt;
are queued up on the ServiceThread as part of the JavaThread destructor&lt;br/&gt;
to be cleaned up by the ServiceThread when it gets the chance...&lt;br/&gt;
&lt;br/&gt;
So the java.lang.Thread oop does live longer that the JavaThread* itself&lt;br/&gt;
and I wonder what happens if our observer thread queries one of these&lt;br/&gt;
via its &amp;#39;jthread&amp;#39; -&amp;gt; &amp;#39;thread_oop&amp;#39; connection...</comment>
                            <comment id="14572883" author="dcubed" created="Mon, 10 Apr 2023 14:13:13 -0700"  >Normally we don&amp;#39;t include detailed test failure info for an in progress fix,&lt;br/&gt;
but I&amp;#39;m going to do so in order to explain why this code doesn&amp;#39;t quite&lt;br/&gt;
work the way that we think it does.&lt;br/&gt;
&lt;br/&gt;
First here&amp;#39;s the failing assertion:&lt;br/&gt;
&lt;br/&gt;
#  Internal Error (/work/shared/bug_hunt/8305670_for_jdk21.git/open/src/hotspot/share/runtime/threadSMR.cpp:837), pid=1011815, tid=1011969&lt;br/&gt;
#  assert(is_on_list) failed: java_thread=0x00007fcfd80267f0 is not on ThreadsList(0x00007fcfdc003cc0)&lt;br/&gt;
#&lt;br/&gt;
# JRE version: Java(TM) SE Runtime Environment (21.0) (slowdebug build 21-internal-LTS-2023-04-10-1532144.dcubed...)&lt;br/&gt;
# Java VM: Java HotSpot(TM) 64-Bit Server VM (slowdebug 21-internal-LTS-2023-04-10-1532144.dcubed..., mixed mode, sharing, tiered, compressed oops, compressed class ptrs, g1 gc, linux-amd64)&lt;br/&gt;
# Problematic frame:&lt;br/&gt;
# V  [libjvm.so+0x149b0e3]  ThreadsListHandle::cv_internal_thread_to_JavaThread(_jobject*, JavaThread**, oopDesc**)+0x18d&lt;br/&gt;
&lt;br/&gt;
And here&amp;#39;s the crashing thread&amp;#39;s stack trace:&lt;br/&gt;
&lt;br/&gt;
---------------  T H R E A D  ---------------&lt;br/&gt;
&lt;br/&gt;
Current thread (0x00007fcfd802ac70):  JavaThread &amp;quot;Thread-1&amp;quot; [_thread_in_vm, id=1011969, stack(0x00007fd02a794000,0x00007fd02a895000)] _threads_hazard_ptr=0x00007fcfdc003cc0, _nested_threads_hazard_ptr_cnt=0&lt;br/&gt;
&lt;br/&gt;
Stack: [0x00007fd02a794000,0x00007fd02a895000],  sp=0x00007fd02a893670,  free space=1021k&lt;br/&gt;
Native frames: (J=compiled Java code, j=interpreted, Vv=VM code, C=native code)&lt;br/&gt;
V  [libjvm.so+0x149b0e3]  ThreadsListHandle::cv_internal_thread_to_JavaThread(_jobject*, JavaThread**, oopDesc**)+0x18d  (threadSMR.cpp:837)&lt;br/&gt;
V  [libjvm.so+0x15d1237]  WB_HandshakeWalkStack+0x1a8  (whitebox.cpp:2196)&lt;br/&gt;
J 203  jdk.test.whitebox.WhiteBox.handshakeWalkStack(Ljava/lang/Thread;Z)I (0 bytes) @ 0x00007fd043f93bb5 [0x00007fd043f93ac0+0x00000000000000f5]&lt;br/&gt;
j  HandshakeWalkOneExitTest$1.run()V+27&lt;br/&gt;
j  java.lang.Thread.runWith(Ljava/lang/Object;Ljava/lang/Runnable;)V+5 &lt;a href=&apos;mailto:java.base@21-internal&apos;&gt;java.base@21-internal&lt;/a&gt;&lt;br/&gt;
j  java.lang.Thread.run()V+19 &lt;a href=&apos;mailto:java.base@21-internal&apos;&gt;java.base@21-internal&lt;/a&gt;&lt;br/&gt;
v  ~StubRoutines::call_stub 0x00007fd0437b6d21&lt;br/&gt;
V  [libjvm.so+0xd4ebce]  JavaCalls::call_helper(JavaValue*, methodHandle const&amp;amp;, JavaCallArguments*, JavaThread*)+0x630  (javaCalls.cpp:415)&lt;br/&gt;
V  [libjvm.so+0x1234260]  os::os_exception_wrapper(void (*)(JavaValue*, methodHandle const&amp;amp;, JavaCallArguments*, JavaThread*), JavaValue*, methodHandle const&amp;amp;, JavaCallArguments*, JavaThread*)+0x36  (os_linux.cpp:4833)&lt;br/&gt;
V  [libjvm.so+0xd4e59b]  JavaCalls::call(JavaValue*, methodHandle const&amp;amp;, JavaCallArguments*, JavaThread*)+0x3d  (javaCalls.cpp:329)&lt;br/&gt;
V  [libjvm.so+0xd4d5e0]  JavaCalls::call_virtual(JavaValue*, Klass*, Symbol*, Symbol*, JavaCallArguments*, JavaThread*)+0x1ba  (javaCalls.cpp:185)&lt;br/&gt;
V  [libjvm.so+0xd4d6e9]  JavaCalls::call_virtual(JavaValue*, Handle, Klass*, Symbol*, Symbol*, JavaThread*)+0x95  (javaCalls.cpp:191)&lt;br/&gt;
V  [libjvm.so+0xe77bab]  thread_entry(JavaThread*, JavaThread*)+0x8e  (jvm.cpp:2918)&lt;br/&gt;
V  [libjvm.so+0xd68f6c]  JavaThread::thread_main_inner()+0x168  (javaThread.cpp:717)&lt;br/&gt;
V  [libjvm.so+0xd68e01]  JavaThread::run()+0x1d7  (javaThread.cpp:702)&lt;br/&gt;
V  [libjvm.so+0x1491339]  Thread::call_run()+0x1b9  (thread.cpp:224)&lt;br/&gt;
V  [libjvm.so+0x122a012]  thread_native_entry(Thread*)+0x1ad  (os_linux.cpp:740)&lt;br/&gt;
Java frames: (J=compiled Java code, j=interpreted, Vv=VM code)&lt;br/&gt;
J 203  jdk.test.whitebox.WhiteBox.handshakeWalkStack(Ljava/lang/Thread;Z)I (0 bytes) @ 0x00007fd043f93b42 [0x00007fd043f93ac0+0x0000000000000082]&lt;br/&gt;
j  HandshakeWalkOneExitTest$1.run()V+27&lt;br/&gt;
j  java.lang.Thread.runWith(Ljava/lang/Object;Ljava/lang/Runnable;)V+5 &lt;a href=&apos;mailto:java.base@21-internal&apos;&gt;java.base@21-internal&lt;/a&gt;&lt;br/&gt;
j  java.lang.Thread.run()V+19 &lt;a href=&apos;mailto:java.base@21-internal&apos;&gt;java.base@21-internal&lt;/a&gt;&lt;br/&gt;
v  ~StubRoutines::call_stub 0x00007fd0437b6d21&lt;br/&gt;
&lt;br/&gt;
Our crashing thread (&amp;quot;Thread-1&amp;quot;) is busy abusing the worker threads in&lt;br/&gt;
the runtime/handshake/HandshakeWalkOneExitTest.java test program&lt;br/&gt;
using the WB_HandshakeWalkStack() testing API. WB_HandshakeWalkStack()&lt;br/&gt;
is a whitebox API that takes a jthread, converts the jthread into a JavaThread*,&lt;br/&gt;
and tries to handshake with the JavaThread* and walks the JavaThread&amp;#39;s stack.&lt;br/&gt;
Pretty simple stuff.&lt;br/&gt;
&lt;br/&gt;
WB_HandshakeWalkStack() uses ThreadsListHandle::cv_internal_thread_to_JavaThread()&lt;br/&gt;
to convert the jthread parameter into a JavaThread*. And that&amp;#39;s where we run&lt;br/&gt;
into the new assert().&lt;br/&gt;
&lt;br/&gt;
Let&amp;#39;s repeat that assertion failure:&lt;br/&gt;
&lt;br/&gt;
assert(is_on_list) failed: java_thread=0x00007fcfd80267f0 is not on ThreadsList(0x00007fcfdc003cc0)&lt;br/&gt;
&lt;br/&gt;
so 0x00007fcfd80267f0 isn&amp;#39;t found on the specified ThreadsList.&lt;br/&gt;
Let&amp;#39;s check the hs_err_pid:&lt;br/&gt;
&lt;br/&gt;
Threads class SMR info:&lt;br/&gt;
_java_thread_list=0x00007fcfc4001000, length=17, elements={&lt;br/&gt;
0x00007fd05402df50, 0x00007fd05459a8d0, 0x00007fd05459c0b0, 0x00007fd05459df00,&lt;br/&gt;
0x00007fd05459f630, 0x00007fd0545a0d60, 0x00007fd0545a2ad0, 0x00007fd0545ac330,&lt;br/&gt;
0x00007fcff803e270, 0x00007fcffc06d590, 0x00007fcffc06e940, 0x00007fcffc06fd70,&lt;br/&gt;
0x00007fd054628e90, 0x00007fd054643490, 0x00007fd054675fc0, 0x00007fcfd802ac70,&lt;br/&gt;
0x00007fcfd80267f0&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
The *last* entry in _java_thread_list matches &amp;#39;0x00007fcfd80267f0&amp;#39;!&lt;br/&gt;
What the heck? Oh wait, the assertion also reported the ThreadsList&lt;br/&gt;
address that we searched with a value of: 0x00007fcfdc003cc0&lt;br/&gt;
&lt;br/&gt;
And that ThreadsList doesn&amp;#39;t match the current _java_thread_list&lt;br/&gt;
which is 0x00007fcfc4001000.&lt;br/&gt;
&lt;br/&gt;
So our JavaThread (0x00007fcfd80267f0) is on the current ThreadsList,&lt;br/&gt;
but is NOT on an older ThreadsList. Since 0x00007fcfd80267f0 is in the&lt;br/&gt;
last slot of the current ThreadsList, that indicates that 0x00007fcfd80267f0&lt;br/&gt;
is a new entry added to a new copy of the previous ThreadsList which is&lt;br/&gt;
likely the one that we searched (0x00007fcfdc003cc0). We could check&lt;br/&gt;
the _to_delete_list, but that&amp;#39;s a bit of work that we don&amp;#39;t have to do (yet,&lt;br/&gt;
if at all).&lt;br/&gt;
&lt;br/&gt;
Let&amp;#39;s check the Events in the hs_err_pid file:&lt;br/&gt;
&lt;br/&gt;
Event: 1.089 Thread 0x00007fcfd80267f0 Thread exited: 0x00007fcfd80267f0&lt;br/&gt;
Event: 1.089 Thread 0x00007fcfd80267f0 Thread added: 0x00007fcfd80267f0&lt;br/&gt;
Event: 1.090 Thread 0x00007fcfd80267f0 Thread exited: 0x00007fcfd80267f0&lt;br/&gt;
Event: 1.090 Thread 0x00007fcfd80267f0 Thread added: 0x00007fcfd80267f0&lt;br/&gt;
Event: 1.091 Thread 0x00007fcfd80267f0 Thread exited: 0x00007fcfd80267f0&lt;br/&gt;
Event: 1.091 Thread 0x00007fcfd80267f0 Thread added: 0x00007fcfd80267f0&lt;br/&gt;
&lt;br/&gt;
It looks like our JavaThread (0x00007fcfd80267f0) has been reused quite a&lt;br/&gt;
few times in the last set of events tracked before the VM crashed. It always&lt;br/&gt;
surprises me when I see a JavaThread* being used over and over, but that&amp;#39;s&lt;br/&gt;
pretty normal for malloc&amp;#39;ed and free&amp;#39;ed data structures...&lt;br/&gt;
&lt;br/&gt;
So let&amp;#39;s take a look at what WB_HandshakeWalkStack() is doing:&lt;br/&gt;
&lt;br/&gt;
src/hotspot/share/prims/whitebox.cpp:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;} else if (thread_handle != nullptr) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ThreadsListHandle tlh;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;JavaThread* target = nullptr;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;bool is_alive = tlh.cv_internal_thread_to_JavaThread(thread_handle, &amp;amp;target, nullptr);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if (is_alive) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Handshake::execute(&amp;amp;tsc, &amp;amp;tlh, target);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&lt;br/&gt;
So WB_HandshakeWalkStack() is passed a &amp;#39;thread_handle&amp;#39; that refers&lt;br/&gt;
to a JavaThread and we pass it to cv_internal_thread_to_JavaThread()&lt;br/&gt;
to convert that &amp;#39;thread_handle&amp;#39;  into a JavaThread*. We already created&lt;br/&gt;
the ThreadsListHandle (tlh) that doesn&amp;#39;t include the JavaThread* that we&lt;br/&gt;
think we&amp;#39;re converting, but we don&amp;#39;t know that yet. The JavaThread* is&lt;br/&gt;
not in the list in &amp;#39;tlh&amp;#39; because that JavaThread* has exited. We&amp;#39;re just the&lt;br/&gt;
observer so we don&amp;#39;t know that yet.&lt;br/&gt;
&lt;br/&gt;
So let&amp;#39;s dive into the cv_* function and see the racy details...&lt;br/&gt;
&lt;br/&gt;
bool ThreadsListHandle::cv_internal_thread_to_JavaThread(jobject jthread,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;JavaThread ** jt_pp,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;oop * thread_oop_p) { &lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(this-&amp;gt;list() != nullptr, &amp;quot;must have a ThreadsList&amp;quot;);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;assert(jt_pp != nullptr, &amp;quot;must have a return JavaThread pointer&amp;quot;); &lt;br/&gt;
&amp;nbsp;&amp;nbsp;// thread_oop_p is optional so no assert()&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;// The JVM_* interfaces don&amp;#39;t allow a null thread parameter; JVM/TI&lt;br/&gt;
&amp;nbsp;&amp;nbsp;// allows a null thread parameter to signify &amp;quot;current thread&amp;quot; which&lt;br/&gt;
&amp;nbsp;&amp;nbsp;// allows us to avoid calling cv_external_thread_to_JavaThread().&lt;br/&gt;
&amp;nbsp;&amp;nbsp;// The JVM_* interfaces have no such leeway.&lt;br/&gt;
&lt;br/&gt;
dcubed: We convert our &amp;#39;jthread&amp;#39; into a &amp;#39;thread_oop&amp;#39;... Our &amp;#39;jthread&amp;#39;&lt;br/&gt;
dcubed: refers to a dead JavaThread, but there&amp;#39;s no verification of&lt;br/&gt;
dcubed: the resolution from jthread -&amp;gt; oop.&lt;br/&gt;
&amp;nbsp;&amp;nbsp;oop thread_oop = JNIHandles::resolve_non_null(jthread);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;// Looks like an oop at this point.&lt;br/&gt;
&amp;nbsp;&amp;nbsp;if (thread_oop_p != nullptr) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// Return the oop to the caller; the caller may still want&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// the oop even if this function returns false.&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;*thread_oop_p = thread_oop;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&lt;br/&gt;
dcubed: We use the thread_oop to query the java.lang.Thread&lt;br/&gt;
dcubed: object in Java land and fetch the JavaThread* that&amp;#39;s&lt;br/&gt;
dcubed: stored there. Above I mentioned that our &amp;#39;jthread&amp;#39; and&lt;br/&gt;
dcubed: our &amp;#39;thread_oop&amp;#39; refer to a dead JavaThread so when&lt;br/&gt;
dcubed: ask for the JavaThread* we should get nullptr which was&lt;br/&gt;
dcubed: set by ensure_join() in the JavaThread::exit() code path.&lt;br/&gt;
dcubed: However, we have a newly running JavaThread and it&lt;br/&gt;
dcubed: has set a new JavaThread* value in the java.lang.Thread&lt;br/&gt;
dcubed: object that the thread_oop refers to. In a sense, it appears&lt;br/&gt;
dcubed: that the same JavaThread has been resurrected, but it has&lt;br/&gt;
dcubed: a new thread name so it&amp;#39;s not really the same JavaThread.&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;JavaThread *java_thread = java_lang_Thread::thread(thread_oop);&lt;br/&gt;
&lt;br/&gt;
dcubed: It is this non-nullptr &amp;#39;java_thread&amp;#39; value that allows us to get&lt;br/&gt;
dcubed: to the new assertion which fails because the JavaThread*&lt;br/&gt;
dcubed: is NOT in the ThreadsList that we&amp;#39;re searching.&lt;br/&gt;
&amp;nbsp;&amp;nbsp;if (java_thread == nullptr) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// The java.lang.Thread does not contain a JavaThread * so it has&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// not yet run or it has died.&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return false;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;// Looks like a live JavaThread at this point.&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;if (java_thread != JavaThread::current()) {&lt;br/&gt;
dcubed: So our &amp;#39;java_thread&amp;#39; doesn&amp;#39;t match the current JavaThread so we&lt;br/&gt;
dcubed: head right into the new assertion from here.&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// jthread is not for the current JavaThread so we could verify&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// the JavaThread * against the ThreadsList.&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if (EnableThreadSMRExtraValidityChecks) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// The java.lang.Thread&amp;#39;s JavaThread* value is cleared by ensure_join()&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// in the middle of the JavaThread&amp;#39;s exit() call. The JavaThread removes&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// itself from the ThreadsList at the end of the JavaThread&amp;#39;s exit()&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// call. Since we have a non-nullptr java_thread value here, we know&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// that this ThreadsListHandle is protecting the JavaThread so this&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// is optional verification against future changes. &lt;br/&gt;
dcubed: The reason that the code without the assertion &amp;quot;works&amp;quot; is&lt;br/&gt;
dcubed: because this &amp;#39;includes()&amp;#39; check will return &amp;#39;false&amp;#39; because the&lt;br/&gt;
dcubed: ThreadsList we&amp;#39;re searching doesn&amp;#39;t contain the JavaThread*&lt;br/&gt;
dcubed: so that indicates that the &amp;#39;java_thread&amp;#39; is dead (at least at the&lt;br/&gt;
dcubed: time that the ThreadsList was created).&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;bool is_on_list = includes(java_thread);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;assert(is_on_list, &amp;quot;java_thread=&amp;quot; INTPTR_FORMAT &amp;quot; is not on ThreadsList(&amp;quot;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;INTPTR_FORMAT &amp;quot;)&amp;quot;, p2i(java_thread), p2i(this-&amp;gt;list()));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// Robustness check for non-ASSERT bits:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if (!is_on_list) {&lt;br/&gt;
dcubed: So this return &amp;#39;false&amp;#39; tells the caller that we have a bad &amp;#39;jthread&amp;#39;&lt;br/&gt;
dcubed: because the associated JavaThread has died.&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return false; &lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;// Return a live JavaThread that is &amp;quot;protected&amp;quot; by the&lt;br/&gt;
&amp;nbsp;&amp;nbsp;// ThreadsListHandle in the caller.&lt;br/&gt;
&amp;nbsp;&amp;nbsp;*jt_pp = java_thread;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return true;&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
Okay that was gnarly. There is a part of this I don&amp;#39;t quite grok.&lt;br/&gt;
&lt;br/&gt;
In this code path, we have a &amp;#39;jthread&amp;#39; that got us to a &amp;#39;thread_oop&amp;#39; and&lt;br/&gt;
that &amp;#39;thread_oop&amp;#39; refers to a java.lang.Thread object. On the thread&lt;br/&gt;
creation code path, we have created a new java.lang.Thread object&lt;br/&gt;
and we populated that java.lang.Thread object with a &amp;#39;JavaThread*&amp;#39;&lt;br/&gt;
that happens to be recycled. I can accept that.&lt;br/&gt;
&lt;br/&gt;
What I don&amp;#39;t grok is how our observer thread&amp;#39;s &amp;#39;thread_oop&amp;#39; gets us&lt;br/&gt;
to the new &amp;#39;java.lang.Thread&amp;#39; object where we can pickup the same&lt;br/&gt;
&amp;#39;JavaThread*&amp;#39;. Did the &amp;#39;java.lang.Thread&amp;#39; object also get recycled?&lt;br/&gt;
I don&amp;#39;t know GC algorithms so I don&amp;#39;t know if that is possible or if&lt;br/&gt;
the question even makes sense.</comment>
                            <comment id="14572870" author="dcubed" created="Mon, 10 Apr 2023 13:09:00 -0700"  >The v00 proposed fix in the PR includes a refactoring that adds an assertion:&lt;br/&gt;
&lt;br/&gt;
--- a/src/hotspot/share/runtime/threadSMR.cpp&lt;br/&gt;
+++ b/src/hotspot/share/runtime/threadSMR.cpp&lt;br/&gt;
@@ -824,11 +824,22 @@ bool ThreadsListHandle::cv_internal_thread_to_JavaThread(jobject jthread,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;// Looks like a live JavaThread at this point.&lt;br/&gt;
&amp;nbsp;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;if (java_thread != JavaThread::current()) {&lt;br/&gt;
-    // jthread is not for the current JavaThread so have to verify&lt;br/&gt;
+    // jthread is not for the current JavaThread so we could verify&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// the JavaThread * against the ThreadsList.&lt;br/&gt;
-    if (EnableThreadSMRExtraValidityChecks &amp;amp;&amp;amp; !includes(java_thread)) {&lt;br/&gt;
-      // Not on the JavaThreads list so it is not alive.&lt;br/&gt;
-      return false;&lt;br/&gt;
+    if (EnableThreadSMRExtraValidityChecks) {&lt;br/&gt;
+      // The java.lang.Thread&amp;#39;s JavaThread* value is cleared by ensure_join()&lt;br/&gt;
+      // in the middle of the JavaThread&amp;#39;s exit() call. The JavaThread removes&lt;br/&gt;
+      // itself from the ThreadsList at the end of the JavaThread&amp;#39;s exit()&lt;br/&gt;
+      // call. Since we have a non-nullptr java_thread value here, we know&lt;br/&gt;
+      // that this ThreadsListHandle is protecting the JavaThread so this&lt;br/&gt;
+      // is optional verification against future changes.&lt;br/&gt;
+      bool is_on_list = includes(java_thread);&lt;br/&gt;
+      assert(is_on_list, &amp;quot;java_thread=&amp;quot; INTPTR_FORMAT &amp;quot; is not on ThreadsList(&amp;quot;&lt;br/&gt;
+             INTPTR_FORMAT &amp;quot;)&amp;quot;, p2i(java_thread), p2i(this-&amp;gt;list()));&lt;br/&gt;
+      // Robustness check for non-ASSERT bits:&lt;br/&gt;
+      if (!is_on_list) {&lt;br/&gt;
+        return false;&lt;br/&gt;
+      }&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&lt;br/&gt;
In my Mach5 Tier1 testing, the following tests failed:&lt;br/&gt;
&lt;br/&gt;
- runtime/handshake/HandshakeWalkOneExitTest.java&lt;br/&gt;
&amp;nbsp;&amp;nbsp;- failed on linux-aarch64-debug, linux-x64-debug, macosx-aarch64-debug,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;and macosx-x64-debug&lt;br/&gt;
- runtime/handshake/HandshakeDirectTest.java&lt;br/&gt;
&amp;nbsp;&amp;nbsp;- failed only on linux-aarch64-debug&lt;br/&gt;
&lt;br/&gt;
I was able to reproduce the runtime/handshake/HandshakeWalkOneExitTest.java&lt;br/&gt;
on my macosx-x64 MBP13 and on my linux-x64 server. On linux-x64, I was able&lt;br/&gt;
to reproduce it with both &amp;#39;fastdebug&amp;#39; and &amp;#39;slowdebug&amp;#39; bits.&lt;br/&gt;
&lt;br/&gt;
I&amp;#39;m attaching an example set of logs from a recent slowdebug failure:&lt;br/&gt;
&lt;br/&gt;
$ unzip -l 8305670-new-assert-failure.zip&lt;br/&gt;
Archive:  8305670-new-assert-failure.zip&lt;br/&gt;
&amp;nbsp;&amp;nbsp;Length      Date    Time    Name&lt;br/&gt;
---------  ---------- -----   ----&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;41833  2023-04-10 15:46   test_failures.2023-04-10-154316/HandshakeWalkOneExitTest.jtr.slowdebug&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;212918  2023-04-10 15:59   test_failures.2023-04-10-154316/hs_err_pid1011815.log&lt;br/&gt;
---------                     -------&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;254751                     2 files</comment>
                            <comment id="14572525" author="dcubed" created="Fri, 7 Apr 2023 13:13:54 -0700"  >[~apangin] - Please test the patch in your environment:&lt;br/&gt;
&lt;br/&gt;
&lt;a href=&quot;https://github.com/openjdk/jdk/pull/13393&quot;&gt;https://github.com/openjdk/jdk/pull/13393&lt;/a&gt;&lt;br/&gt;
&lt;br/&gt;
I used the attached test on my X64 MBP13, but I had to limit the thread count to 4000&lt;br/&gt;
or the test would blow up. I saw very little difference between baseline runs and runs&lt;br/&gt;
with &amp;#39;-XX:-EnableThreadSMRExtraValidityChecks&amp;#39;, but that&amp;#39;s probably because of the&lt;br/&gt;
machine I&amp;#39;m using today.&lt;br/&gt;
&lt;br/&gt;
Update: I couple of tests are failing unexpectedly with the current patch:&lt;br/&gt;
&lt;br/&gt;
- runtime/handshake/HandshakeWalkOneExitTest.java&lt;br/&gt;
- runtime/handshake/HandshakeDirectTest.java&lt;br/&gt;
&lt;br/&gt;
Please hold off on testing this patch until I figure out this problem next week.&lt;br/&gt;
</comment>
                            <comment id="14572524" author="roboduke" created="Fri, 7 Apr 2023 13:13:09 -0700"  >A pull request was submitted for review.&lt;br/&gt;
URL: &lt;a href=&quot;https://git.openjdk.org/jdk/pull/13393&quot;&gt;https://git.openjdk.org/jdk/pull/13393&lt;/a&gt;&lt;br/&gt;
Date: 2023-04-07 20:08:11 +0000</comment>
                            <comment id="14572457" author="dcubed" created="Fri, 7 Apr 2023 08:22:03 -0700"  >The EnableThreadSMRExtraValidityChecks first made an appearance in the&lt;br/&gt;
&amp;quot;Thread-SMR (8167108)(phase2) big code review&amp;quot; cycle. The change is credited&lt;br/&gt;
to gthornbr&amp;#39;s CR, but I couldn&amp;#39;t find an email documenting those code review&lt;br/&gt;
comments. I&amp;#39;m going to guess that these comments were made during an in&lt;br/&gt;
person code review at my house in Colorado.&lt;br/&gt;
&lt;br/&gt;
The only other mentions of EnableThreadSMRExtraValidityChecks that I have&lt;br/&gt;
in 900+ emails are comments about the indenting being wrong in the globals.hpp&lt;br/&gt;
file. Those comments were from David Holmes so he at least saw the option in&lt;br/&gt;
its declaration/definition context way, way back in 2017. :-) Of course, that&amp;#39;s just&lt;br/&gt;
one line of code in an XL code review so...&lt;br/&gt;
&lt;br/&gt;
Okay, we added EnableThreadSMRExtraValidityChecks as a diagnostic option&lt;br/&gt;
with a default value of &amp;#39;true&amp;#39;. Typically that means that we intended to change&lt;br/&gt;
the default value from &amp;#39;true&amp;#39; to &amp;#39;false&amp;#39; in a future release. I didn&amp;#39;t find any other&lt;br/&gt;
bugs/RFEs that mention EnableThreadSMRExtraValidityChecks so I didn&amp;#39;t file&lt;br/&gt;
a follow-up bug targeting a later release. That&amp;#39;s an error on my part.&lt;br/&gt;
&lt;br/&gt;
&lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8167108&quot; title=&quot;inconsistent handling of SR_lock can lead to crashes&quot; class=&quot;issue-link&quot; data-issue-key=&quot;JDK-8167108&quot;&gt;&lt;strike&gt;JDK-8167108&lt;/strike&gt;&lt;/a&gt; was integrated in jdk-10+36 (to use the new version style) on&lt;br/&gt;
2017.11.23 so this code has had a very, very long time to bake. I think we can&lt;br/&gt;
change the default of EnableThreadSMRExtraValidityChecks to &amp;#39;false&amp;#39; and we&lt;br/&gt;
can do a little bit more...</comment>
                            <comment id="14572450" author="dcubed" created="Fri, 7 Apr 2023 07:35:52 -0700"  >[~dholmes] - Thanks for your last post. That was what I was writing from my research&lt;br/&gt;
last night. Your post is much more concise than what I was writing (as usual).&lt;br/&gt;
&lt;br/&gt;
I&amp;#39;m still researching the history behind EnableThreadSMRExtraValidityChecks and&lt;br/&gt;
will comment again soon...</comment>
                            <comment id="14572374" author="dholmes" created="Thu, 6 Apr 2023 21:52:39 -0700"  >&amp;gt; Looks to me that thread termination sequence is: detect no SMR conflicts (thread is not on any TLH-protected list) -&amp;gt; do some termination steps -&amp;gt; set set_thread(oop, nullptr) -&amp;gt; proceed with termination. &lt;br/&gt;
&lt;br/&gt;
set_thread(oop, nullptr) happens in ensure_join() which happens before Threads::remove which is where ThreadSMRSupport::remove_thread is called, after which the thread will no longer appear in any created TLH. So if we create the TLH first (which we do) and then ask the oop for the JavaThread and get a non-null result then that JavaThread is guarded by that TLH.</comment>
                            <comment id="14572195" author="shade" created="Thu, 6 Apr 2023 01:28:28 -0700"  >AFAIU the SMR machinery, TLH captures the current alive threads list, and keeps all threads on that list from terminating while TLH is in scope. But that list might not include the thread we ask to unpark? That&amp;#39;s seems to be the whole problem here: we don&amp;#39;t quite know if the asked-to-be-unparked thread is on TLH-protected list or not without explicitly checking for it, except for a few corner cases.&lt;br/&gt;
&lt;br/&gt;
Looks to me that thread termination sequence is: detect no SMR conflicts (thread is not on any TLH-protected list) -&amp;gt; do some termination steps -&amp;gt; set set_thread(oop, nullptr) -&amp;gt; proceed with termination. Which means two cases:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;1. Seen thread(oop) == nullptr: we can argue the thread is dead, since the termination sequence is already past detecting the thread is dead, and there is no point in looking into the list. This is what the first block here does: &lt;a href=&quot;https://github.com/openjdk/jdk/blob/44f33ad1a9617fc23864c9ba5f063b3fc2f1e18c/src/hotspot/share/runtime/threadSMR.cpp#L818-L823&quot;&gt;https://github.com/openjdk/jdk/blob/44f33ad1a9617fc23864c9ba5f063b3fc2f1e18c/src/hotspot/share/runtime/threadSMR.cpp#L818-L823&lt;/a&gt;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;2. Seen thread(oop) != nullptr: the thread *looks* alive, but we might be just unlucky that the thread is currently terminating, and set_thread(oop, nullptr) had not been done yet. If we continue down this path, the termination sequence might delete the JavaThread* under our feet. So, we now need to figure if TLH is guarding this JavaThread* for us, i.e. if it is on its list. The only shortcut is asking for the current thread, which guarantees it is not currently terminating. Which is why we go into the checks here: &lt;a href=&quot;https://github.com/openjdk/jdk/blob/44f33ad1a9617fc23864c9ba5f063b3fc2f1e18c/src/hotspot/share/runtime/threadSMR.cpp#L826-L833&quot;&gt;https://github.com/openjdk/jdk/blob/44f33ad1a9617fc23864c9ba5f063b3fc2f1e18c/src/hotspot/share/runtime/threadSMR.cpp#L826-L833&lt;/a&gt;&lt;br/&gt;
&lt;br/&gt;
Am I completely misreading what is going on here?</comment>
                            <comment id="14572170" author="dholmes" created="Wed, 5 Apr 2023 23:29:58 -0700"  >Hmmm. The TLH either captures the thread and makes it safe to touch, or it doesn&amp;#39;t. If the TLH did not catch the thread then it has already terminated in which case querying the j.l.Thread will return null and the whole thing is as no-op. If the j.l.Thread returns a JavaThread* then that JavaThread must be protected by the TLH.&lt;br/&gt;
&lt;br/&gt;
What am I missing?</comment>
                            <comment id="14572167" author="shade" created="Wed, 5 Apr 2023 23:16:26 -0700"  >Oh yes, I should have asked Dan, sorry!&lt;br/&gt;
&lt;br/&gt;
It looks to me that TLH guarantees no other thread would destroy the unparking thread *if* that thread was on the list. Just having the JavaThread* in hands, when it is not on the current thread list, does not enjoy any protection from TLH. So there is a window where JT* in question is both being unparked *and* already taken off the list and being destroyed, since from the perspective of SMR it is safe to do so. It looks as if EnableThreadSMRExtraValidityChecks = false just restores the old, racy behavior in code that converts thread oop to JT*, like Unsafe_Unpark. If so, it is not just an extra check, it is actually a load-bearing piece for correctness :) Is it?&lt;br/&gt;
&lt;br/&gt;
To solve the regression, we might want to try speeding up the `includes` scan.</comment>
                            <comment id="14572126" author="dholmes" created="Wed, 5 Apr 2023 17:42:45 -0700"  >I&amp;#39;m searched everything I have on the Thread-SMR design (note I wasn&amp;#39;t the designer or implementor) and can&amp;#39;t find anything that specifically discusses the implication of the linear search or why the EnableThreadSMRExtraValidityChecks flag was added and only used in some places. Perhaps [~dcubed] can say more?&lt;br/&gt;
&lt;br/&gt;
A linear search is always going to be a problem with excessive numbers of threads, but 99.9% of the time this is not an issue. The usual alternatives to linear search would apply here - with the usual trade-offs.&lt;br/&gt;
&lt;br/&gt;
Thinking more about this and the use of cv_internal_thread_to_JavaThread though, I&amp;#39;m not sure the search is actually necessary - and perhaps why EnableThreadSMRExtraValidityChecks is just an &amp;quot;extra check&amp;quot;. At the time of the call to cv_internal_thread_to_JavaThread we already have a ThreadsListHandle active and so if the target was alive when the TLH was created it remains safe to access. Inside cv_internal_thread_to_JavaThread we ask the j.l.Thread for its JavaThread. If that is non-null the thread is at least transiently alive but could logically terminate at any time. However we don&amp;#39;t care about that - as long as the JavaThread doesn&amp;#39;t go through it&amp;#39;s destruction process due to it being protected by the TLH then we can continue the unpark operation on it.</comment>
                            <comment id="14572082" author="shade" created="Wed, 5 Apr 2023 13:42:42 -0700"  >The code path in question is added by &lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8167108&quot; title=&quot;inconsistent handling of SR_lock can lead to crashes&quot; class=&quot;issue-link&quot; data-issue-key=&quot;JDK-8167108&quot;&gt;&lt;strike&gt;JDK-8167108&lt;/strike&gt;&lt;/a&gt;. AFAICS, this is the intended use of SMR: the whole thing protects from dealing with a dead (concurrently deleted) `JavaThread*` in `Unsafe_Unpark`, which would -- best case -- crash. So turning off `EnableThreadSMRExtraValidityChecks` is okay for experiments, but looks rather unsafe for production use. (Just in case a casual reader would decide to add this to their JVM flags). &lt;br/&gt;
&lt;br/&gt;
Maybe [~dholmes] would see the ways out of this performance penalty.</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10200">
                    <name>Backport</name>
                                            <outwardlinks description="backported by">
                                        <issuelink>
            <issuekey id="5105642">JDK-8312202</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="5106025">JDK-8312540</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                            <issuelinktype id="10000">
                    <name>Blocks</name>
                                                                <inwardlinks description="is blocked by">
                                        <issuelink>
            <issuekey id="5099693">JDK-8307068</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                            <issuelinktype id="10003">
                    <name>Relates</name>
                                            <outwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="5100771">JDK-8307970</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="4902769">JDK-8167108</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="5100157">JDK-8307483</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="103383" name="8305670-new-assert-failure.zip" size="37834" author="dcubed" created="Mon, 10 Apr 2023 13:08:56 -0700"/>
                            <attachment id="103334" name="UnparkRegression.java" size="1284" author="apangin" created="Wed, 5 Apr 2023 10:25:21 -0700"/>
                    </attachments>
                <subtasks>
                                              <subtask id="5099692">JDK-8307067</subtask>
                                                              <subtask id="5099693">JDK-8307068</subtask>
                                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_11700" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_10600" key="com.oracle.jira.javabugsystem-jira-plugin:jbs-fixedBackportedCustomfield">
                        <customfieldname>Fixed</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_11100" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i3114b:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_11004" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10006" key="com.atlassian.jira.plugin.system.customfieldtypes:select">
                        <customfieldname>Resolved In Build</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="17433"><![CDATA[b23]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10008" key="com.oracle.jira.jira-subcomponent-plugin:oracle-subComponentField">
                        <customfieldname>Subcomponent</customfieldname>
                        <customfieldvalues>
                             <customfieldvalue key="192"><![CDATA[runtime]]></customfieldvalue> 
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_10601" key="com.oracle.jira.javabugsystem-jira-plugin:jbs-targetBackportedCustomfield">
                        <customfieldname>Targeted</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    </customfields>
    </item>
</channel>
</rss>