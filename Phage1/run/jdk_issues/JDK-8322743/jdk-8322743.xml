<!-- 
RSS generated by JIRA (9.12.27#9120027-sha1:edc4490121e366e9e7bd2213d532dbe7e028fc5d) at Tue Sep 30 12:41:18 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>Java Bug System</title>
    <link>https://bugs.openjdk.org</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-us</language>    <build-info>
        <version>9.12.27</version>
        <build-number>9120027</build-number>
        <build-date>02-09-2025</build-date>
    </build-info>


<item>
            <title>[JDK-8322743] C2: prevent lock region elimination in OSR compilation</title>
                <link>https://bugs.openjdk.org/browse/JDK-8322743</link>
                <project id="10100" key="JDK">JDK</project>
                    <description>ADDITIONAL SYSTEM INFORMATION :&lt;br/&gt;
# JRE version: OpenJDK Runtime Environment (22.0) (fastdebug build 22-internal-adhoc.jdk22u)&lt;br/&gt;
# Java VM: OpenJDK 64-Bit Server VM (fastdebug 22-internal-adhoc.jdk22u, compiled mode, tiered, compressed oops, compressed class ptrs, g1 gc, linux-amd64)&lt;br/&gt;
&lt;br/&gt;
A DESCRIPTION OF THE PROBLEM :&lt;br/&gt;
I ran a modified regression test case on JDK 22.0 and found that the JVM crashed with -Xcomp option.&lt;br/&gt;
&lt;br/&gt;
#&lt;br/&gt;
# A fatal error has been detected by the Java Runtime Environment:&lt;br/&gt;
#&lt;br/&gt;
#  Internal Error (/home/repository/jdk22u/src/hotspot/share/runtime/javaThread.cpp:880), pid=25410, tid=25515&lt;br/&gt;
#  assert(held_monitor_count() == jni_monitor_count()) failed: held monitor count should be equal to jni: 1 != 0&lt;br/&gt;
#&lt;br/&gt;
# JRE version: OpenJDK Runtime Environment (22.0) (fastdebug build 22-internal-adhoc.jdk22u)&lt;br/&gt;
# Java VM: OpenJDK 64-Bit Server VM (fastdebug 22-internal-adhoc.jdk22u, compiled mode, tiered, compressed oops, compressed class ptrs, g1 gc, linux-amd64)&lt;br/&gt;
# Problematic frame:&lt;br/&gt;
# V  [libjvm.so+0x3325baf]  JavaThread::exit(bool, JavaThread::ExitType)+0xccf&lt;br/&gt;
#&lt;br/&gt;
# No core dump will be written. Core dumps have been disabled. To enable core dumping, try &amp;quot;ulimit -c unlimited&amp;quot; before starting Java again&lt;br/&gt;
#&lt;br/&gt;
# If you would like to submit a bug report, please visit:&lt;br/&gt;
#   &lt;a href=&quot;https://bugreport.java.com/bugreport/crash.jsp&quot;&gt;https://bugreport.java.com/bugreport/crash.jsp&lt;/a&gt;&lt;br/&gt;
#&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
STEPS TO FOLLOW TO REPRODUCE THE PROBLEM :&lt;br/&gt;
java  -Xcomp -XX:CompileCommand=&amp;quot;compileonly,compiler.c1.Test8267042::write&amp;quot; compiler.c1.Test8267042&lt;br/&gt;
&lt;br/&gt;
ACTUAL -&lt;br/&gt;
CompileCommand: compileonly compiler/c1/Test8267042.write bool compileonly = true&lt;br/&gt;
Starting test&lt;br/&gt;
read() before wait&lt;br/&gt;
read() after wait&lt;br/&gt;
read() before wait&lt;br/&gt;
read() after wait&lt;br/&gt;
read() before wait&lt;br/&gt;
read() after wait&lt;br/&gt;
read() before wait&lt;br/&gt;
read() after wait&lt;br/&gt;
#&lt;br/&gt;
# A fatal error has been detected by the Java Runtime Environment:&lt;br/&gt;
#&lt;br/&gt;
#  Internal Error (/home/repository/jdk22u/src/hotspot/share/runtime/javaThread.cpp:880), pid=25410, tid=25515&lt;br/&gt;
#  assert(held_monitor_count() == jni_monitor_count()) failed: held monitor count should be equal to jni: 1 != 0&lt;br/&gt;
#&lt;br/&gt;
# JRE version: OpenJDK Runtime Environment (22.0) (fastdebug build 22-internal-adhoc.jdk22u)&lt;br/&gt;
# Java VM: OpenJDK 64-Bit Server VM (fastdebug 22-internal-adhoc.jdk22u, compiled mode, tiered, compressed oops, compressed class ptrs, g1 gc, linux-amd64)&lt;br/&gt;
# Problematic frame:&lt;br/&gt;
# V  [libjvm.so+0x3325baf]Test passed&lt;br/&gt;
&amp;nbsp;&amp;nbsp;JavaThread::exit(bool, JavaThread::ExitType)+0xccf&lt;br/&gt;
#&lt;br/&gt;
# No core dump will be written. Core dumps have been disabled. To enable core dumping, try &amp;quot;ulimit -c unlimited&amp;quot; before starting Java again&lt;br/&gt;
#&lt;br/&gt;
# An error report file with more information is saved as:&lt;br/&gt;
# /home/repository/toreport/Test8267042_11_13_22_51_01/hs_err_pid25410.log&lt;br/&gt;
#&lt;br/&gt;
# If you would like to submit a bug report, please visit:&lt;br/&gt;
#   &lt;a href=&quot;https://bugreport.java.com/bugreport/crash.jsp&quot;&gt;https://bugreport.java.com/bugreport/crash.jsp&lt;/a&gt;&lt;br/&gt;
#&lt;br/&gt;
&lt;br/&gt;
---------- BEGIN SOURCE ----------&lt;br/&gt;
The source code file and hs_err file are available at the URL:&lt;br/&gt;
&lt;a href=&quot;https://drive.google.com/file/d/1Ie3NupEt669LfE2DjCi2boFCRq3iXM3v/view?usp=drive_link&quot;&gt;https://drive.google.com/file/d/1Ie3NupEt669LfE2DjCi2boFCRq3iXM3v/view?usp=drive_link&lt;/a&gt;&lt;br/&gt;
&lt;br/&gt;
The modifications I made are in the source code at line 101 through line 113&lt;br/&gt;
---------- END SOURCE ----------&lt;br/&gt;
&lt;br/&gt;
FREQUENCY : always&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
</description>
                <environment></environment>
        <key id="5114625">JDK-8322743</key>
            <summary>C2: prevent lock region elimination in OSR compilation</summary>
                <type id="1" iconUrl="https://bugs.openjdk.org/secure/viewavatar?size=xsmall&amp;avatarId=14703&amp;avatarType=issuetype">Bug</type>
                                            <priority id="3" iconUrl="https://bugs.openjdk.org/images/jbsImages/p3.png">P3</priority>
                        <status id="5" iconUrl="https://bugs.openjdk.org/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="success"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="kvn">Vladimir Kozlov</assignee>
                                    <reporter username="webbuggrp">Webbug Group</reporter>
                        <labels>
                            <label>amazon-interest</label>
                            <label>c2</label>
                            <label>c2-ea</label>
                            <label>dcsrs</label>
                            <label>jdk21u-fix-request</label>
                            <label>jdk21u-fix-yes</label>
                            <label>oracle-triage-23</label>
                            <label>reproducer-yes</label>
                            <label>webbug</label>
                    </labels>
                <created>Mon, 13 Nov 2023 17:23:05 -0800</created>
                <updated>Tue, 18 Jun 2024 02:16:50 -0700</updated>
                            <resolved>Thu, 29 Feb 2024 12:23:47 -0800</resolved>
                                    <version>8</version>
                    <version>11</version>
                    <version>17</version>
                    <version>20</version>
                    <version>21</version>
                    <version>22</version>
                    <version>23</version>
                                    <fixVersion>23</fixVersion>
                                    <component>hotspot</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>13</watches>
                                                                                                                <comments>
                            <comment id="14682464" author="roboduke" created="Mon, 17 Jun 2024 23:42:03 -0700"  >[jdk21u-fix-request] Approval Request from Martin&lt;br/&gt;
Should get backported for parity with 21.0.5-oracle. Applies cleanly and tier 1-4 have passed.</comment>
                            <comment id="14682131" author="roboduke" created="Mon, 17 Jun 2024 08:46:20 -0700"  >A pull request was submitted for review.&lt;br/&gt;
URL: &lt;a href=&quot;https://git.openjdk.org/jdk21u-dev/pull/733&quot;&gt;https://git.openjdk.org/jdk21u-dev/pull/733&lt;/a&gt;&lt;br/&gt;
Date: 2024-06-17 15:38:21 +0000</comment>
                            <comment id="14653634" author="dukebot" created="Thu, 29 Feb 2024 12:23:46 -0800"  >Changeset: 742c776a&lt;br/&gt;
Author:    Vladimir Kozlov &amp;lt;&lt;a href=&apos;mailto:kvn@openjdk.org&apos;&gt;kvn@openjdk.org&lt;/a&gt;&amp;gt;&lt;br/&gt;
Date:      2024-02-29 20:20:46 +0000&lt;br/&gt;
URL:       &lt;a href=&quot;https://git.openjdk.org/jdk/commit/742c776a922bc226a3beaa9e219ff0bd2baf7bc4&quot;&gt;https://git.openjdk.org/jdk/commit/742c776a922bc226a3beaa9e219ff0bd2baf7bc4&lt;/a&gt;&lt;br/&gt;
</comment>
                            <comment id="14638822" author="roboduke" created="Tue, 9 Jan 2024 15:35:12 -0800"  >A pull request was submitted for review.&lt;br/&gt;
URL: &lt;a href=&quot;https://git.openjdk.org/jdk/pull/17331&quot;&gt;https://git.openjdk.org/jdk/pull/17331&lt;/a&gt;&lt;br/&gt;
Date: 2024-01-09 22:57:27 +0000</comment>
                            <comment id="14638653" author="kvn" created="Tue, 9 Jan 2024 10:02:11 -0800"  >I was not able to reproduce the issue with Test8267042 but I see now that submitter modified the test to use local object to synchronize:&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;synchronized void write(char[] data, int offset, int length) throws IOException {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;while (--length &amp;gt;= 0) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// modified code&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;synchronized (new Test8267042()) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;int var1 = 0;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;while (var1 &amp;lt; 100000) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if (var1 == 50000) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;getZeroOnStack(offset);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;var1++;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// original code&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// getZeroOnStack(offset);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;write(data[offset++]);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
</comment>
                            <comment id="14638646" author="kvn" created="Tue, 9 Jan 2024 09:41:55 -0800"  >This problem shown by reproducer test is strange for me. You should not use a local not escaped object for synchronization since other threads can&amp;#39;t access it and synchronization does not work.&lt;br/&gt;
&lt;br/&gt;
I am not sure how [~thartmann] converted `compiler.c1.Test8267042.java` test into reproducer. Test8267042 has synchronization on methods.&lt;br/&gt;
&lt;br/&gt;
If you have normal synchronization on object, that object should be accessed by other threads and as such escaped. Escape Analysis then will keep all locks.&lt;br/&gt;
&lt;br/&gt;
Your example with Object created outside synchronization block indeed will have incorrect locking state after deoptimization. But this local object is short lived.&lt;br/&gt;
&lt;br/&gt;
About deoptimization. From generated code I see 2 safepoints (deoptimization points): one on back edge of internal loop (what is left from it) and an other from external loop. The problem is only internal deoptimization point where the object is still alive. You have very small window to hit it.&lt;br/&gt;
&lt;br/&gt;
But again, since object is local and short lived it should not affect execution (other threads) except some accounting for locks.&lt;br/&gt;
&amp;nbsp;</comment>
                            <comment id="14638434" author="rehn" created="Mon, 8 Jan 2024 23:13:33 -0800"  >I&amp;#39;m trying to figure what symptoms we may have, as we have a couple of bugs with IMSE which we don&amp;#39;t understand.&lt;br/&gt;
If we may throw IMSE when removing the activation it&amp;#39;s good to know. &lt;br/&gt;
</comment>
                            <comment id="14638364" author="kvn" created="Mon, 8 Jan 2024 13:09:01 -0800"  >&amp;gt; 2: We transition to OSR compiled code, where that lock is &amp;#39;eliminated&amp;#39; . &lt;br/&gt;
*This creates the assert as we never unlock this object. &lt;br/&gt;
&lt;br/&gt;
As I said, this is the bug and I am working on fix. Please, wait the fix.</comment>
                            <comment id="14637972" author="rehn" created="Mon, 8 Jan 2024 00:08:46 -0800"  >[~kvn]&lt;br/&gt;
1: We lock the Object in interpreter.&lt;br/&gt;
2: We transition to OSR compiled code, where that lock is &amp;#39;eliminated&amp;#39; .&lt;br/&gt;
*This creates the assert as we never unlock this object.&lt;br/&gt;
3: We deopt on a bytecode after the synchronized block.&lt;br/&gt;
4: We are now in interpreter and the Object must be unlock, but as Tobias says: &amp;quot;The compiled code then never unlocks it.&amp;quot;&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
</comment>
                            <comment id="14637790" author="kvn" created="Fri, 5 Jan 2024 09:56:24 -0800"  >[~rehn] deopting outside synchronized scope will not relock object since there will be no reference for monitor in JVM state and in safepoint data where we deopt. We are fine in such case.</comment>
                            <comment id="14637753" author="thartmann" created="Fri, 5 Jan 2024 07:33:50 -0800"  >Okay, I didn&amp;#39;t hit that assert when running with -XX:LockingMode=0 but maybe the test needs to be tweaked.</comment>
                            <comment id="14637627" author="rehn" created="Thu, 4 Jan 2024 23:29:25 -0800"  >[~thartmann] owner == nullptr is unlocked, so that is what we assert. Hence running your test with -XX:LockingMode=0 could hit this assert.&lt;br/&gt;
&lt;br/&gt;
[~kvn] I mean in the case that object should not be relocked as we deopted outside of the synchronized scope.&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;for (int i = 0; i &amp;lt; 2; ++i) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Object o = new Object();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;synchronized (o) { // monitorenter&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// Trigger OSR compilation&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;for (int j = 0; j &amp;lt; 100_000; ++j) {&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;} // monitorexit&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// deopt happens after monitorexit, o must be unlocked&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
</comment>
                            <comment id="14637624" author="thartmann" created="Thu, 4 Jan 2024 23:15:46 -0800"  >[~rehn], thanks for the additional details, that makes sense to me. &lt;br/&gt;
&lt;br/&gt;
&amp;gt; Looking more closely it seem that we only asserts the owner is NULL.&lt;br/&gt;
&amp;gt; With the call to &amp;quot;set_owner_from(nullptr, DEFLATER_MARKER);&amp;quot;.&lt;br/&gt;
&lt;br/&gt;
So should we have an additional assert there to check that monitors are unlocked when being reclaimed?&lt;br/&gt;
&lt;br/&gt;
&amp;gt; But if the non escaping Object is allocate before the synchronized scope and we deopt after the synchronized scope? Would it give back a lock object ?&lt;br/&gt;
&lt;br/&gt;
I believe that&amp;#39;s not different from the non-OSR case when C2 eliminates locks and should be taken care of by restore_eliminated_locks, as Vladimir mentioned. It&amp;#39;s probably worth double-checking the different cases though.&lt;br/&gt;
&lt;br/&gt;
[~kvn] Thanks for jumping on this! I wanted to bring it up for discussion in next week&amp;#39;s compiler staff but I think you summarized the options that we have.</comment>
                            <comment id="14637561" author="kvn" created="Thu, 4 Jan 2024 16:13:07 -0800"  >[~rehn] We relock objects during deoptimization if locks were eliminated in compiled code:&lt;br/&gt;
&lt;a href=&quot;https://github.com/openjdk/jdk/blob/master/src/hotspot/share/runtime/deoptimization.cpp#L456&quot;&gt;https://github.com/openjdk/jdk/blob/master/src/hotspot/share/runtime/deoptimization.cpp#L456&lt;/a&gt;&lt;br/&gt;
</comment>
                            <comment id="14637551" author="kvn" created="Thu, 4 Jan 2024 14:51:59 -0800"  >The issue here is that Unlock node references (through Phi (1) node) two objects, one from Interpreter and new one allocated. But Lock node only references new allocated object. So C2 decide to eliminate Lock since locally allocated object does not escape (it is not eliminated because it is referenced by Phi (1) which is input to Unlock node).&lt;br/&gt;
When we eliminate Lock we eliminate also all Lock and Unlock which point to the same BoxLock node. Which is not correct - we can&amp;#39;t eliminate locks/unlocks which may reference other objects.&lt;br/&gt;
&lt;br/&gt;
The issue was introduced by &lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-7129618&quot; title=&quot;assert(obj_node-&amp;gt;eqv_uncast(obj),&amp;quot;&amp;quot;);&quot; class=&quot;issue-link&quot; data-issue-key=&quot;JDK-7129618&quot;&gt;&lt;strike&gt;JDK-7129618&lt;/strike&gt;&lt;/a&gt; in JDK8 which relaxed the check in `mark_eliminated_box()`:&lt;br/&gt;
&lt;br/&gt;
&lt;a href=&quot;https://github.com/openjdk/jdk/commit/b9cba282eeeac2d32f0f17bfb64189fb5b46754c#diff-9109dab2601aefca77e5f15150bbef0d83935b71853595ed829a1945f80f6668L1808&quot;&gt;https://github.com/openjdk/jdk/commit/b9cba282eeeac2d32f0f17bfb64189fb5b46754c#diff-9109dab2601aefca77e5f15150bbef0d83935b71853595ed829a1945f80f6668L1808&lt;/a&gt;&lt;br/&gt;
&lt;br/&gt;
So we either need to clone block with Unlock in ciTypeFlow so we would have separate Unlock nodes for such cases referencing different objects. Or don&amp;#39;t eliminate locks/unlocks for such cases which needs to be done carefully to avoid regression. May be only for the case when an other object comes from Interpreter in OSR compilation.&lt;br/&gt;
</comment>
                            <comment id="14637525" author="rehn" created="Thu, 4 Jan 2024 12:49:34 -0800"  >&amp;gt;I don&amp;#39;t think that can happen. OSR will not throw away the locked object (see below) but only omit the locking/unlocking and jstack will trigger deoptimization which will re-create the interpreter state.&lt;br/&gt;
&lt;br/&gt;
Maybe jstack is bad example, there several methods that walk-stack and gather locks held.&lt;br/&gt;
I&amp;#39;d would say something like, if &amp;quot;javaVFrame::locked_monitors()&amp;quot; ever can return the lock it have escaped.&lt;br/&gt;
In this case the &amp;quot;interpretedVFrame::monitors&amp;quot; could have returned the object at one point, thus it have escaped.&lt;br/&gt;
&lt;br/&gt;
&amp;gt;I thought that once the locked object (which is dead) is reclaimed by the GC, the monitor is freed as well but I&amp;#39;m not familiar enough with the implementation details here. Just trying to get a better understanding of the implications.&lt;br/&gt;
&lt;br/&gt;
Yes, but that algorithm assumes those are unlocked. Looking more closely it seem that we only asserts the owner is NULL.&lt;br/&gt;
With the call to &amp;quot;set_owner_from(nullptr, DEFLATER_MARKER);&amp;quot;.&lt;br/&gt;
&lt;br/&gt;
&amp;gt;The object is *not* eliminated, only the locking/unlocking. So there is no need for re-allocation. The C2 compiled code keeps track of the oop of the locked object and will hand it back to the interpreter on deopt if it&amp;#39;s still live.&lt;br/&gt;
&lt;br/&gt;
Ok, good. But if the non escaping Object is allocate before the synchronized scope and we deopt after the synchronized scope? Would it give back a lock object ?</comment>
                            <comment id="14637497" author="kvn" created="Thu, 4 Jan 2024 09:51:25 -0800"  >Based on Tobias example, there are 2 objects in graph during OSR compilation of this method. One is coming from Interpreter (which means it escaped) and an other new allocated object when C2 generated graph for external loop (which does not escape). I admit that that EA may miss check somewhere for objects coming from Interpreter for OSR compilation and it should be fixed.</comment>
                            <comment id="14637443" author="thartmann" created="Thu, 4 Jan 2024 06:59:12 -0800"  >&amp;gt; A i.e. jstack will publish this object as locked. OSR will throw away the locked object. A second jstack, even if happens on the exactly same bytecode without any execution, but after OSR, this object will no longer be visible in jstack.&lt;br/&gt;
&lt;br/&gt;
I don&amp;#39;t think that can happen. OSR will not throw away the locked object (see below) but only omit the locking/unlocking and jstack will trigger deoptimization which will re-create the interpreter state.&lt;br/&gt;
&lt;br/&gt;
&amp;gt; As we have recorded the locking in a monitor, this monitor will never be unlocked thus never freed, so I think that would be leaking object monitors (as no one would clear _owner).&lt;br/&gt;
OM&amp;#39;s are query-able, so this would be seen in a debugger.&lt;br/&gt;
&lt;br/&gt;
I thought that once the locked object (which is dead) is reclaimed by the GC, the monitor is freed as well but I&amp;#39;m not familiar enough with the implementation details here. Just trying to get a better understanding of the implications.&lt;br/&gt;
&lt;br/&gt;
&amp;gt; When we recreate interpreted frames we allocate objects for those eliminated, Deoptimization::realloc_objects().&lt;br/&gt;
&amp;gt; Since this during OSR maybe there are some steps I&amp;#39;m unaware of or so.&lt;br/&gt;
&amp;gt; As far as I understand it, we would create X then synchronize-enter X, throw away X, create Z synchronize-enter Z.&lt;br/&gt;
&lt;br/&gt;
The object is *not* eliminated, only the locking/unlocking. So there is no need for re-allocation. The C2 compiled code keeps track of the oop of the locked object and will hand it back to the interpreter on deopt if it&amp;#39;s still live.</comment>
                            <comment id="14637434" author="rehn" created="Thu, 4 Jan 2024 06:07:05 -0800"  >&amp;gt;&amp;gt; Otherwise debuggers and similar would not be so happy. As the interpreted stack represent the Java frame state, recording the lock there should be viewed as publishing it IMHO.&lt;br/&gt;
&amp;gt;But after the OSR transition, we don&amp;#39;t have an interpreted stack frame anymore and debugging would then trigger deoptimization (and therefore re-creation of the correct interpreter stack frame), right?&lt;br/&gt;
&lt;br/&gt;
A i.e. jstack will publish this object as locked. OSR will throw away the locked object. A second jstack, even if happens on the exactly same bytecode without any execution, but after OSR, this object will no longer be visible in jstack.&lt;br/&gt;
&lt;br/&gt;
&amp;gt;&amp;gt; One other issue seems to be when running with heavy weight monitors, that synchronized would inflate, now it&amp;#39;s very global visible !?&lt;br/&gt;
&amp;gt;Why would using heavy weight monitors make a difference here?&lt;br/&gt;
&lt;br/&gt;
As we have recorded the locking in a monitor, this monitor will never be unlocked thus never freed, so I think that would be leaking object monitors (as no one would clear _owner).&lt;br/&gt;
OM&amp;#39;s are query-able, so this would be seen in a debugger.&lt;br/&gt;
&lt;br/&gt;
&amp;gt;&amp;gt; Secondly, what happens if we deoptimize ? Would we create the object again and lock it again ? That seems bad&lt;br/&gt;
&amp;gt;If we deopt, we would hand over the already locked object to the interpreter (no need to re-allocate) and the interpreter would then unlock the object once we leave the scope of the synchronized block.&lt;br/&gt;
&lt;br/&gt;
When we recreate interpreted frames we allocate objects for those eliminated, Deoptimization::realloc_objects().&lt;br/&gt;
Since this during OSR maybe there are some steps I&amp;#39;m unaware of or so.&lt;br/&gt;
As far as I understand it, we would create X then synchronize-enter X, throw away X, create Z synchronize-enter Z.&lt;br/&gt;
</comment>
                            <comment id="14637403" author="thartmann" created="Thu, 4 Jan 2024 04:16:33 -0800"  >I agree that this should be fixed, I was just defending the optimization from C2&amp;#39;s perspective :)&lt;br/&gt;
&lt;br/&gt;
&amp;gt; Anything done in interpreter should be treated as such.&lt;br/&gt;
&lt;br/&gt;
Sure but the difference here is that C2 &amp;quot;sees&amp;quot; and compiles the entire scope in which the objects are live and determines that they can&amp;#39;t escape. The (incorrect) assumption is then that the object we get from the OSR state can&amp;#39;t be globally visible.&lt;br/&gt;
&lt;br/&gt;
&amp;gt; Otherwise debuggers and similar would not be so happy. As the interpreted stack represent the Java frame state, recording the lock there should be viewed as publishing it IMHO.&lt;br/&gt;
&lt;br/&gt;
But after the OSR transition, we don&amp;#39;t have an interpreted stack frame anymore and debugging would then trigger deoptimization (and therefore re-creation of the correct interpreter stack frame), right?&lt;br/&gt;
&lt;br/&gt;
&amp;gt; One other issue seems to be when running with heavy weight monitors, that synchronized would inflate, now it&amp;#39;s very global visible !?&lt;br/&gt;
&lt;br/&gt;
Why would using heavy weight monitors make a difference here?&lt;br/&gt;
&lt;br/&gt;
&amp;gt; Secondly, what happens if we deoptimize ? Would we create the object again and lock it again ? That seems bad&lt;br/&gt;
&lt;br/&gt;
If we deopt, we would hand over the already locked object to the interpreter (no need to re-allocate) and the interpreter would then unlock the object once we leave the scope of the synchronized block.</comment>
                            <comment id="14637322" author="rehn" created="Wed, 3 Jan 2024 23:32:21 -0800"  >I agree with Tom. Anything done in interpreter should be treated as such. Otherwise debuggers and similar would not be so happy.&lt;br/&gt;
As the interpreted stack represent the Java frame state, recording the lock there should be viewed as publishing it IMHO.&lt;br/&gt;
&lt;br/&gt;
One other issue seems to be when running with heavy weight monitors, that synchronized would inflate, now it&amp;#39;s very global visible !?&lt;br/&gt;
&lt;br/&gt;
Secondly, what happens if we deoptimize ? Would we create the object again and lock it again ? That seems bad.&lt;br/&gt;
&lt;br/&gt;
Hence I agree with Tom.</comment>
                            <comment id="14637305" author="thartmann" created="Wed, 3 Jan 2024 22:05:35 -0800"  >I really didn&amp;#39;t look at this in detail yet but my understanding is that since EA proved that the object is non-escaping, we ignore the object that we get in through the OSR state since it must be non-escaping as well. Yes, it seems like a special case for performance reasons.</comment>
                            <comment id="14637190" author="never" created="Wed, 3 Jan 2024 09:27:27 -0800"  >Isn&amp;#39;t that a bug with EA and OSR though?  Any lock that comes from the OSR state seems like it has already escaped.  Certainly any object from the OSR state is potentially globally visible though maybe the algorithm wants to catch this case for performance reasons?</comment>
                            <comment id="14637143" author="rehn" created="Wed, 3 Jan 2024 06:07:39 -0800"  >Great find!</comment>
                            <comment id="14637140" author="thartmann" created="Wed, 3 Jan 2024 05:50:33 -0800"  >I had a quick look at this and the problem seems to be that when OSR compiling the following loop, C2 completely removes the lock/unlock because &amp;#39;new Object()&amp;#39; is non-escaping:&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;for (int i = 0; i &amp;lt; 2; ++i) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;synchronized (new Object()) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// Trigger OSR compilation&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;for (int j = 0; j &amp;lt; 100_000; ++j) {&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&lt;br/&gt;
But since it&amp;#39;s an OSR compilation we transition from interpreted to compiled on the inner loop back-branch and therefore the Object we get in from the interpreter is already locked. The compiled code then never unlocks it.&lt;br/&gt;
&lt;br/&gt;
We fetch the locked object from the interpreter state here:&lt;br/&gt;
&lt;a href=&quot;https://github.com/openjdk/jdk/blob/6dfb8120c270a76fcba5a5c3c9ad91da3282d5fa/src/hotspot/share/opto/parse1.cpp#L232&quot;&gt;https://github.com/openjdk/jdk/blob/6dfb8120c270a76fcba5a5c3c9ad91da3282d5fa/src/hotspot/share/opto/parse1.cpp#L232&lt;/a&gt;&lt;br/&gt;
&lt;br/&gt;
And Escape Analysis ignores it here:&lt;br/&gt;
&lt;a href=&quot;https://github.com/openjdk/jdk/blob/6dfb8120c270a76fcba5a5c3c9ad91da3282d5fa/src/hotspot/share/opto/escape.cpp#L1306&quot;&gt;https://github.com/openjdk/jdk/blob/6dfb8120c270a76fcba5a5c3c9ad91da3282d5fa/src/hotspot/share/opto/escape.cpp#L1306&lt;/a&gt;&lt;br/&gt;
&lt;br/&gt;
And then marks the lock for removal:&lt;br/&gt;
&lt;a href=&quot;https://github.com/openjdk/jdk/blob/6dfb8120c270a76fcba5a5c3c9ad91da3282d5fa/src/hotspot/share/opto/escape.cpp#L2558&quot;&gt;https://github.com/openjdk/jdk/blob/6dfb8120c270a76fcba5a5c3c9ad91da3282d5fa/src/hotspot/share/opto/escape.cpp#L2558&lt;/a&gt;&lt;br/&gt;
&lt;br/&gt;
This is an old issue existing since &amp;quot;initial load&amp;quot;. Similar to Graal, as [~never] explained in JDK-8320142, C2&amp;#39;s Escape Analysis relies on the assumption that leaving a non-escaping object for reclamation in locked state is fine. This is no longer true after &lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8286957&quot; title=&quot;Held monitor count&quot; class=&quot;issue-link&quot; data-issue-key=&quot;JDK-8286957&quot;&gt;&lt;strike&gt;JDK-8286957&lt;/strike&gt;&lt;/a&gt;.</comment>
                            <comment id="14637119" author="thartmann" created="Wed, 3 Jan 2024 04:51:39 -0800"  >I attached a simple Test.java that triggers the following two asserts (with latest JDK 23):&lt;br/&gt;
&lt;br/&gt;
java -Xcomp -XX:CompileCommand=compileonly,Test*::* -XX:CompileCommand=quiet -XX:+PrintCompilation -XX:-TieredCompilation Test.java&lt;br/&gt;
&lt;br/&gt;
# A fatal error has been detected by the Java Runtime Environment:&lt;br/&gt;
#&lt;br/&gt;
#  Internal Error (workspace/open/src/hotspot/share/runtime/javaThread.cpp:879), pid=3521250, tid=3521267&lt;br/&gt;
#  assert(held_monitor_count() == jni_monitor_count()) failed: held monitor count should be equal to jni: 1 != 0&lt;br/&gt;
#&lt;br/&gt;
# JRE version: Java(TM) SE Runtime Environment (23.0+4) (fastdebug build 23-ea+4-173)&lt;br/&gt;
# Java VM: Java HotSpot(TM) 64-Bit Server VM (fastdebug 23-ea+4-173, compiled mode, sharing, compressed oops, compressed class ptrs, g1 gc, linux-amd64)&lt;br/&gt;
# Problematic frame:&lt;br/&gt;
# V  [libjvm.so+0xec0cc0]  JavaThread::exit(bool, JavaThread::ExitType)+0x870&lt;br/&gt;
&lt;br/&gt;
Stack: [0x00007f86468ff000,0x00007f8646a00000],  sp=0x00007f86469fecd0,  free space=1023k&lt;br/&gt;
Native frames: (J=compiled Java code, j=interpreted, Vv=VM code, C=native code)&lt;br/&gt;
V  [libjvm.so+0xec0cc0]  JavaThread::exit(bool, JavaThread::ExitType)+0x870  (javaThread.cpp:879)&lt;br/&gt;
V  [libjvm.so+0xec1035]  JavaThread::post_run()+0x15&lt;br/&gt;
V  [libjvm.so+0x179ea85]  Thread::call_run()+0xd5&lt;br/&gt;
V  [libjvm.so+0x14a92e7]  thread_native_entry(Thread*)+0x127&lt;br/&gt;
&lt;br/&gt;
# A fatal error has been detected by the Java Runtime Environment:&lt;br/&gt;
#&lt;br/&gt;
#  Internal Error (workspace/open/src/hotspot/share/runtime/synchronizer.cpp:1799), pid=3521217, tid=3521218&lt;br/&gt;
#  assert(current-&amp;gt;held_monitor_count() == 0) failed: Should not be possible&lt;br/&gt;
#&lt;br/&gt;
# JRE version: Java(TM) SE Runtime Environment (23.0+4) (fastdebug build 23-ea+4-173)&lt;br/&gt;
# Java VM: Java HotSpot(TM) 64-Bit Server VM (fastdebug 23-ea+4-173, compiled mode, sharing, compressed oops, compressed class ptrs, g1 gc, linux-amd64)&lt;br/&gt;
# Problematic frame:&lt;br/&gt;
# V  [libjvm.so+0x1737aa9]  ObjectSynchronizer::release_monitors_owned_by_thread(JavaThread*)+0x199&lt;br/&gt;
&lt;br/&gt;
Stack: [0x00007f4e7b439000,0x00007f4e7b53a000],  sp=0x00007f4e7b538c50,  free space=1023k&lt;br/&gt;
Native frames: (J=compiled Java code, j=interpreted, Vv=VM code, C=native code)&lt;br/&gt;
V  [libjvm.so+0x1737aa9]  ObjectSynchronizer::release_monitors_owned_by_thread(JavaThread*)+0x199  (synchronizer.cpp:1799)&lt;br/&gt;
V  [libjvm.so+0xec0c4c]  JavaThread::exit(bool, JavaThread::ExitType)+0x7fc&lt;br/&gt;
V  [libjvm.so+0xf9416a]  jni_DetachCurrentThread+0xda&lt;br/&gt;
C  [libjli.so+0x4a1f]  JavaMain+0xdef&lt;br/&gt;
C  [libjli.so+0x7ca9]  ThreadJavaMain+0x9&lt;br/&gt;
&lt;br/&gt;
Disabling C2&amp;#39;s Escape Analysis via -XX:-DoEscapeAnalysis or lock elimination via -XX:-EliminateLocks serves as a workaround.</comment>
                            <comment id="14637108" author="thartmann" created="Wed, 3 Jan 2024 04:00:42 -0800"  >I can reproduce this since the assert was introduced by &lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8286957&quot; title=&quot;Held monitor count&quot; class=&quot;issue-link&quot; data-issue-key=&quot;JDK-8286957&quot;&gt;&lt;strike&gt;JDK-8286957&lt;/strike&gt;&lt;/a&gt; in JDK 20 b06 and up until latest JDK 23.&lt;br/&gt;
&lt;br/&gt;
ILW = Assert due to unexpected monitor count, reproducible with modified regression test and -Xcomp + compileonly, no known workaround but disable compilation of affected method = HLM = P3</comment>
                            <comment id="14636675" author="dholmes" created="Mon, 1 Jan 2024 14:34:53 -0800"  >This may already be fixed - see JDK-8320142 and &lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8320515&quot; title=&quot;assert(monitor-&amp;gt;object_peek() != nullptr) failed: Owned monitors should not have a dead object&quot; class=&quot;issue-link&quot; data-issue-key=&quot;JDK-8320515&quot;&gt;&lt;strike&gt;JDK-8320515&lt;/strike&gt;&lt;/a&gt;.</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10200">
                    <name>Backport</name>
                                            <outwardlinks description="backported by">
                                        <issuelink>
            <issuekey id="5131752">JDK-8334177</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="5132085">JDK-8334452</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                            <issuelinktype id="10002">
                    <name>Duplicate</name>
                                            <outwardlinks description="duplicates">
                                        <issuelink>
            <issuekey id="5114561">JDK-8323507</issuekey>
        </issuelink>
                            </outwardlinks>
                                                                <inwardlinks description="duplicates">
                                        <issuelink>
            <issuekey id="5118393">JDK-8323686</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                            <issuelinktype id="10003">
                    <name>Relates</name>
                                            <outwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="5115194">JDK-8320515</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="4297737">JDK-7129618</issuekey>
        </issuelink>
                            </outwardlinks>
                                                                <inwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="5123725">JDK-8327743</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="5075178">JDK-8286957</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="5114967">JDK-8320310</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="107784" name="Test.java" size="1274" author="thartmann" created="Wed, 3 Jan 2024 04:52:00 -0800"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_10000" key="com.atlassian.jira.plugin.system.customfieldtypes:multiselect">
                        <customfieldname>CPU</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="19000"><![CDATA[x86_64]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_11700" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_10600" key="com.oracle.jira.javabugsystem-jira-plugin:jbs-fixedBackportedCustomfield">
                        <customfieldname>Fixed</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                            <customfield id="customfield_10005" key="com.atlassian.jira.plugin.system.customfieldtypes:multiselect">
                        <customfieldname>OS</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="17048"><![CDATA[linux_ubuntu]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                            <customfield id="customfield_11100" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i33umz:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_11004" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10006" key="com.atlassian.jira.plugin.system.customfieldtypes:select">
                        <customfieldname>Resolved In Build</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="17339"><![CDATA[b13]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10008" key="com.oracle.jira.jira-subcomponent-plugin:oracle-subComponentField">
                        <customfieldname>Subcomponent</customfieldname>
                        <customfieldvalues>
                             <customfieldvalue key="208"><![CDATA[compiler]]></customfieldvalue> 
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_10601" key="com.oracle.jira.javabugsystem-jira-plugin:jbs-targetBackportedCustomfield">
                        <customfieldname>Targeted</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    </customfields>
    </item>
</channel>
</rss>