<!-- 
RSS generated by JIRA (9.12.27#9120027-sha1:edc4490121e366e9e7bd2213d532dbe7e028fc5d) at Tue Sep 30 14:05:57 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>Java Bug System</title>
    <link>https://bugs.openjdk.org</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-us</language>    <build-info>
        <version>9.12.27</version>
        <build-number>9120027</build-number>
        <build-date>02-09-2025</build-date>
    </build-info>


<item>
            <title>[JDK-8292818] replace 96-bit representation for field metadata with variable-sized streams</title>
                <link>https://bugs.openjdk.org/browse/JDK-8292818</link>
                <project id="10100" key="JDK">JDK</project>
                    <description>Replace 96-bit representation for field metadata with variable-sized streams.&lt;br/&gt;
&lt;br/&gt;
The existing representation for field metadata uses 6 non-optional metadata elements of size 16 bits, for a total non-optional size per field of 96 bits.&lt;br/&gt;
&lt;br/&gt;
Additional optional metadata elements are present for contended group and for generic signature; these are gated by access flag bits.  The logic which locates such fields is very ad hoc and hard to read.  It also does not scale to the next optional.&lt;br/&gt;
&lt;br/&gt;
Luckily, nearly all accesses of field metadata are streaming, so it will be easy to use a variable-sized data structure per field, where access flag bits gate the presence of optional elements.&lt;br/&gt;
&lt;br/&gt;
An updated format should (as today) stream over field elements, and be tolerant of data-dependent sizes.  For example, in the very common case where a field does *not* have a `ConstantValue` initializer attribute, the 16 bits present today (in the 96-bit layout) should be absent altogether.  When the element is present, then a bit (a new bit) in the access flags should announce it, so that the streaming reader can read and/or skip that extra element.&lt;br/&gt;
&lt;br/&gt;
Another problem with the current representation for fields is that the 16 access flag bits are completely used up.  This is easy to fix by increasing the size of the access flags element to 32 bits (like methods and classes).  The cost of this can be paid for by making the constant initializer element almost always absent.&lt;br/&gt;
&lt;br/&gt;
Another problem with the current 16-bit representation is that offsets, which are naturally 32 bits, require two u2 elements, that must be manually packed and unpacked.  This is complicated to read and maintain.  (Actually, the whole thing is complicated to read and maintain, isn&amp;#39;t it??)&lt;br/&gt;
&lt;br/&gt;
By breaking field metadata out of its 96-bit limitations, we will make our VM simpler for existing applications and future-proof for new ones, such as special markings for fields in Leyden and/or Valhalla.&lt;br/&gt;
&lt;br/&gt;
Fixed size metadata allows simple random access, and conversely we will have to give this up.  For an occasional random access to fields, such as &amp;quot;get me the data for field #42&amp;quot;, a linear search through the stream is probably OK.  If not, there are incremental engineering investments in indexing that can reduce or limit the cost of linear search.  These additional investments are not described here, but are easy to design.  (You can associate an index table with the compressed field metadata bundle, so that the Nth field is associated with the place in the bundle where that field&amp;#39;s metadata begins.  And this need not be done for every field, but perhaps for every 8th field, trading speed for space until we are happy.)  But, if you don&amp;#39;t need it, don&amp;#39;t design it.&lt;br/&gt;
&lt;br/&gt;
But wait, there&amp;#39;s more.  Once we embrace variable-sized field metadata, it is almost a no-brainer to encode the individual elements using variable size as well, as long as that variable size encoding is really fast to parse.  And we have this in our source base already, the very good (if I may say so) UNSIGNED5 format from Pack200, using in CompressedStream.  This format is super-fast to unpack, so that GC maps use it, and it does not appear to be a burden to stack walking code.  It will probably also not be a burden to field lookup or other metadata-walking code.&lt;br/&gt;
&lt;br/&gt;
Thus, the unit of field metadata should be a byte (u1) not a short (u2).  Thus, the metadata arrays should be of type Array&amp;lt;u1&amp;gt; not Array&amp;lt;u2&amp;gt;.&lt;br/&gt;
&lt;br/&gt;
So, to sum up, field metadata should be represented in Array&amp;lt;u1&amp;gt; arrays, as compressed bundles of 32-bit ints, representing field descriptions.  The descriptions should have their current elements, of flags, name, signature, initializer (but optional), generic-signature (still optional), offset (now a single item), and contended group (still optional).&lt;br/&gt;
&lt;br/&gt;
A typical field will have just the four elements of flags, name, signature, and offset.  If they were uniformly represented as u4 words, then the format would be 128 bits, which is larger than the current 96 bits.  But if we go a litter further and use UNSIGNED5, then suddenly the typical field will require 1-2 bytes per item (very very few will require more), for a typical field metadata size of 32 bits to 64 bits.  This is a win in footprint.&lt;br/&gt;
&lt;br/&gt;
And it will also be a win in maintainability, since the logical size of each element of field metadata is 32 bits (even if physically it only requires a single byte, or if optional a single bit).  Thus, after a very low-level decompression, algorithms that work on field metadata will be 32-bit clean.  Once you have a foundation you can trust to store 32-bit logical values in a workable physical format (UNSIGNED5) you can forget about that physical format.&lt;br/&gt;
&lt;br/&gt;
This proposal changes only the storage format of metadata.  The layer on top, used by most clients, is the FieldStream types.  These types will change in their internals (since they are coupled to the storage format) but their APIs will not change, so client code will be relatively untouched.&lt;br/&gt;
&lt;br/&gt;
There&amp;#39;s a remaining problem, and that is JVMTI, which uses random access and atomic 16-bit updates to peek and poke field metadata fields to register field watchpoints.  I hope we can agree that using metadata this way is bad.  Metadata should be cleanly read-only, not &amp;quot;sometimes written when JVMTI feels like it&amp;quot;.  Part of this proposed change should move the couple of bits that JVMTI mutates into a separate byte array (or maybe possibly part of the byte array holding the compressed data, if we really don&amp;#39;t care about mixing RO and RW data).  This might seem like a show-stopper, but it&amp;#39;s really just more of the same future-proofing.  Other features (such as Leyden field-initialization tracking) also need a bit or two per field that is mutable.  Such features are best implemented, probably, in the same way as the JVMTI bits, and they can share bit-positions in a common byte array, indexed by field ordinal number.  So, part of this proposed change introduces a second Array&amp;lt;u1&amp;gt;, with mutable contents, indexed by field ordinal, used for JVMTI (2 bits), the rewriter&amp;#39;s anomaly detector (1 bit), and future features (another bit or two).  Lazy finals, if we do them, will need a mutable bit or two to track state.&lt;br/&gt;
&lt;br/&gt;
If we like how this turns out, there are other bits of metadata in HotSpot that can also be cleaned up (made simpler and faster and smaller) in the same way.&lt;br/&gt;
&lt;br/&gt;
One cleanup we can consider connected to the separation of RO metadata from RW control data is to remove the atomic bit-twiddling logic from accessFlags.hpp.  That&amp;#39;s that wrong place to put that stuff, probably, since nearly all access flags are temporary register values, for which atomic updates are crazy overkill, and totally misleading to the casual reader.</description>
                <environment></environment>
        <key id="5082129">JDK-8292818</key>
            <summary>replace 96-bit representation for field metadata with variable-sized streams</summary>
                <type id="7" iconUrl="https://bugs.openjdk.org/secure/viewavatar?size=xsmall&amp;avatarId=14707&amp;avatarType=issuetype">Enhancement</type>
                                            <priority id="3" iconUrl="https://bugs.openjdk.org/images/jbsImages/p3.png">P3</priority>
                        <status id="5" iconUrl="https://bugs.openjdk.org/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="success"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="fparain">Frederic Parain</assignee>
                                    <reporter username="jrose">John Rose</reporter>
                        <labels>
                            <label>metadata</label>
                    </labels>
                <created>Tue, 23 Aug 2022 14:52:18 -0700</created>
                <updated>Wed, 10 Sep 2025 03:05:59 -0700</updated>
                            <resolved>Fri, 17 Mar 2023 13:20:39 -0700</resolved>
                                    <version>20</version>
                                    <fixVersion>21</fixVersion>
                                    <component>hotspot</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>7</watches>
                                                                                                                <comments>
                            <comment id="14567869" author="dukebot" created="Fri, 17 Mar 2023 13:20:38 -0700"  >Changeset: bfb812a8&lt;br/&gt;
Author:    Frederic Parain &amp;lt;&lt;a href=&apos;mailto:fparain@openjdk.org&apos;&gt;fparain@openjdk.org&lt;/a&gt;&amp;gt;&lt;br/&gt;
Date:      2023-03-17 20:18:36 +0000&lt;br/&gt;
URL:       &lt;a href=&quot;https://git.openjdk.org/jdk/commit/bfb812a8ff8bca70aed7695c73f019ae66ac6f33&quot;&gt;https://git.openjdk.org/jdk/commit/bfb812a8ff8bca70aed7695c73f019ae66ac6f33&lt;/a&gt;&lt;br/&gt;
</comment>
                            <comment id="14564701" author="roboduke" created="Mon, 6 Mar 2023 08:46:24 -0800"  >A pull request was submitted for review.&lt;br/&gt;
Branch: master&lt;br/&gt;
URL: &lt;a href=&quot;https://git.openjdk.org/jdk/pull/12855&quot;&gt;https://git.openjdk.org/jdk/pull/12855&lt;/a&gt;&lt;br/&gt;
Date: 2023-03-03 14:50:34 +0000</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10200">
                    <name>Backport</name>
                                                                <inwardlinks description="backport of">
                                        <issuelink>
            <issuekey id="5153078">JDK-8352169</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                            <issuelinktype id="10000">
                    <name>Blocks</name>
                                            <outwardlinks description="blocks">
                                        <issuelink>
            <issuekey id="5096083">JDK-8304069</issuekey>
        </issuelink>
                            </outwardlinks>
                                                                <inwardlinks description="is blocked by">
                                        <issuelink>
            <issuekey id="5082060">JDK-8292758</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                            <issuelinktype id="10600">
                    <name>Causes</name>
                                            <outwardlinks description="causes">
                                        <issuelink>
            <issuekey id="5152969">JDK-8352075</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="5159401">JDK-8357576</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                            <issuelinktype id="10003">
                    <name>Relates</name>
                                            <outwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="5111923">JDK-8317692</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="5114239">JDK-8319650</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="5082532">JDK-8293118</issuekey>
        </issuelink>
                            </outwardlinks>
                                                                <inwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="5097792">JDK-8305490</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="5110386">JDK-8316342</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_11700" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_10600" key="com.oracle.jira.javabugsystem-jira-plugin:jbs-fixedBackportedCustomfield">
                        <customfieldname>Fixed</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_11100" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i2ycpf:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_11004" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10006" key="com.atlassian.jira.plugin.system.customfieldtypes:select">
                        <customfieldname>Resolved In Build</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="17352"><![CDATA[b15]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10008" key="com.oracle.jira.jira-subcomponent-plugin:oracle-subComponentField">
                        <customfieldname>Subcomponent</customfieldname>
                        <customfieldvalues>
                             <customfieldvalue key="192"><![CDATA[runtime]]></customfieldvalue> 
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_10601" key="com.oracle.jira.javabugsystem-jira-plugin:jbs-targetBackportedCustomfield">
                        <customfieldname>Targeted</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    </customfields>
    </item>
</channel>
</rss>