<!-- 
RSS generated by JIRA (9.12.27#9120027-sha1:edc4490121e366e9e7bd2213d532dbe7e028fc5d) at Tue Sep 30 19:26:29 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>Java Bug System</title>
    <link>https://bugs.openjdk.org</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-us</language>    <build-info>
        <version>9.12.27</version>
        <build-number>9120027</build-number>
        <build-date>02-09-2025</build-date>
    </build-info>


<item>
            <title>[JDK-8308038] java/util/concurrent/ThreadPerTaskExecutor/ThreadPerTaskExecutorTest.java timed out</title>
                <link>https://bugs.openjdk.org/browse/JDK-8308038</link>
                <project id="10100" key="JDK">JDK</project>
                    <description>The following test timed out in the JDK21 CI:&lt;br/&gt;
&lt;br/&gt;
java/util/concurrent/ThreadPerTaskExecutor/ThreadPerTaskExecutorTest.java#platform&lt;br/&gt;
&lt;br/&gt;
Here&amp;#39;s a snippet from the log file:&lt;br/&gt;
&lt;br/&gt;
#section:junit&lt;br/&gt;
----------messages:(8/369)----------&lt;br/&gt;
command: junit -DthreadFactory=platform ThreadPerTaskExecutorTest&lt;br/&gt;
reason: User specified action: run junit/othervm -DthreadFactory=platform ThreadPerTaskExecutorTest &lt;br/&gt;
started: Sat May 13 13:38:47 UTC 2023&lt;br/&gt;
Mode: othervm [/othervm specified]&lt;br/&gt;
Timeout information:&lt;br/&gt;
--- Timeout information end.&lt;br/&gt;
finished: Sat May 13 13:50:02 UTC 2023&lt;br/&gt;
elapsed time (seconds): 674.825&lt;br/&gt;
----------configuration:(0/0)----------&lt;br/&gt;
----------System.out:(1/27)----------&lt;br/&gt;
Timeout refired 480 times&lt;br/&gt;
----------System.err:(21/2413)----------&lt;br/&gt;
STARTED    ThreadPerTaskExecutorTest::testSubmitNulls1 &amp;#39;[1] java.lang.ThreadBuilders$&lt;a href=&apos;mailto:PlatformThreadFactory@5fe04fcb&apos;&gt;PlatformThreadFactory@5fe04fcb&lt;/a&gt;&amp;#39;&lt;br/&gt;
SUCCESSFUL ThreadPerTaskExecutorTest::testSubmitNulls1 &amp;#39;[1] java.lang.ThreadBuilders$&lt;a href=&apos;mailto:PlatformThreadFactory@5fe04fcb&apos;&gt;PlatformThreadFactory@5fe04fcb&lt;/a&gt;&amp;#39;&lt;br/&gt;
STARTED    ThreadPerTaskExecutorTest::testSubmitNulls2 &amp;#39;[1] java.lang.ThreadBuilders$&lt;a href=&apos;mailto:PlatformThreadFactory@5fe04fcb&apos;&gt;PlatformThreadFactory@5fe04fcb&lt;/a&gt;&amp;#39;&lt;br/&gt;
SUCCESSFUL ThreadPerTaskExecutorTest::testSubmitNulls2 &amp;#39;[1] java.lang.ThreadBuilders$&lt;a href=&apos;mailto:PlatformThreadFactory@5fe04fcb&apos;&gt;PlatformThreadFactory@5fe04fcb&lt;/a&gt;&amp;#39;&lt;br/&gt;
STARTED    ThreadPerTaskExecutorTest::testInvokeAnyEmpty1 &amp;#39;[1] java.lang.ThreadBuilders$&lt;a href=&apos;mailto:PlatformThreadFactory@5fe04fcb&apos;&gt;PlatformThreadFactory@5fe04fcb&lt;/a&gt;&amp;#39;&lt;br/&gt;
SUCCESSFUL ThreadPerTaskExecutorTest::testInvokeAnyEmpty1 &amp;#39;[1] java.lang.ThreadBuilders$&lt;a href=&apos;mailto:PlatformThreadFactory@5fe04fcb&apos;&gt;PlatformThreadFactory@5fe04fcb&lt;/a&gt;&amp;#39;&lt;br/&gt;
STARTED    ThreadPerTaskExecutorTest::testInvokeAnyEmpty2 &amp;#39;[1] java.lang.ThreadBuilders$&lt;a href=&apos;mailto:PlatformThreadFactory@5fe04fcb&apos;&gt;PlatformThreadFactory@5fe04fcb&lt;/a&gt;&amp;#39;&lt;br/&gt;
SUCCESSFUL ThreadPerTaskExecutorTest::testInvokeAnyEmpty2 &amp;#39;[1] java.lang.ThreadBuilders$&lt;a href=&apos;mailto:PlatformThreadFactory@5fe04fcb&apos;&gt;PlatformThreadFactory@5fe04fcb&lt;/a&gt;&amp;#39;&lt;br/&gt;
STARTED    ThreadPerTaskExecutorTest::testInvokeAnyAfterShutdown &amp;#39;[1] &lt;a href=&apos;mailto:java.util.concurrent.ThreadPerTaskExecutor@737e7993&apos;&gt;java.util.concurrent.ThreadPerTaskExecutor@737e7993&lt;/a&gt;&amp;#39;&lt;br/&gt;
SUCCESSFUL ThreadPerTaskExecutorTest::testInvokeAnyAfterShutdown &amp;#39;[1] &lt;a href=&apos;mailto:java.util.concurrent.ThreadPerTaskExecutor@737e7993&apos;&gt;java.util.concurrent.ThreadPerTaskExecutor@737e7993&lt;/a&gt;&amp;#39;&lt;br/&gt;
STARTED    ThreadPerTaskExecutorTest::testNull &amp;#39;testNull()&amp;#39;&lt;br/&gt;
SUCCESSFUL ThreadPerTaskExecutorTest::testNull &amp;#39;testNull()&amp;#39;&lt;br/&gt;
STARTED    ThreadPerTaskExecutorTest::testInterruptInvokeAny &amp;#39;[1] &lt;a href=&apos;mailto:java.util.concurrent.ThreadPerTaskExecutor@183f8340&apos;&gt;java.util.concurrent.ThreadPerTaskExecutor@183f8340&lt;/a&gt;&amp;#39;&lt;br/&gt;
SUCCESSFUL ThreadPerTaskExecutorTest::testInterruptInvokeAny &amp;#39;[1] &lt;a href=&apos;mailto:java.util.concurrent.ThreadPerTaskExecutor@183f8340&apos;&gt;java.util.concurrent.ThreadPerTaskExecutor@183f8340&lt;/a&gt;&amp;#39;&lt;br/&gt;
STARTED    ThreadPerTaskExecutorTest::testInvokeAllInterrupt1 &amp;#39;[1] &lt;a href=&apos;mailto:java.util.concurrent.ThreadPerTaskExecutor@7340aa2e&apos;&gt;java.util.concurrent.ThreadPerTaskExecutor@7340aa2e&lt;/a&gt;&amp;#39;&lt;br/&gt;
SUCCESSFUL ThreadPerTaskExecutorTest::testInvokeAllInterrupt1 &amp;#39;[1] &lt;a href=&apos;mailto:java.util.concurrent.ThreadPerTaskExecutor@7340aa2e&apos;&gt;java.util.concurrent.ThreadPerTaskExecutor@7340aa2e&lt;/a&gt;&amp;#39;&lt;br/&gt;
STARTED    ThreadPerTaskExecutorTest::testInvokeAllInterrupt3 &amp;#39;[1] &lt;a href=&apos;mailto:java.util.concurrent.ThreadPerTaskExecutor@1c44ccff&apos;&gt;java.util.concurrent.ThreadPerTaskExecutor@1c44ccff&lt;/a&gt;&amp;#39;&lt;br/&gt;
SUCCESSFUL ThreadPerTaskExecutorTest::testInvokeAllInterrupt3 &amp;#39;[1] &lt;a href=&apos;mailto:java.util.concurrent.ThreadPerTaskExecutor@1c44ccff&apos;&gt;java.util.concurrent.ThreadPerTaskExecutor@1c44ccff&lt;/a&gt;&amp;#39;&lt;br/&gt;
STARTED    ThreadPerTaskExecutorTest::testInvokeAllInterrupt4 &amp;#39;[1] &lt;a href=&apos;mailto:java.util.concurrent.ThreadPerTaskExecutor@324e4a07&apos;&gt;java.util.concurrent.ThreadPerTaskExecutor@324e4a07&lt;/a&gt;&amp;#39;&lt;br/&gt;
SUCCESSFUL ThreadPerTaskExecutorTest::testInvokeAllInterrupt4 &amp;#39;[1] &lt;a href=&apos;mailto:java.util.concurrent.ThreadPerTaskExecutor@324e4a07&apos;&gt;java.util.concurrent.ThreadPerTaskExecutor@324e4a07&lt;/a&gt;&amp;#39;&lt;br/&gt;
STARTED    ThreadPerTaskExecutorTest::testInvokeAllInterrupt6 &amp;#39;[1] &lt;a href=&apos;mailto:java.util.concurrent.ThreadPerTaskExecutor@66865fe4&apos;&gt;java.util.concurrent.ThreadPerTaskExecutor@66865fe4&lt;/a&gt;&amp;#39;&lt;br/&gt;
----------rerun:(44/6131)*----------&lt;br/&gt;
&lt;br/&gt;
&amp;lt;snip&amp;gt;&lt;br/&gt;
&lt;br/&gt;
result: Error. Program `c:\ade\mesos\work_dir\jib-master\install\jdk-21+23-1937\windows-x64-debug.jdk\jdk-21\fastdebug\bin\java&amp;#39; timed out (timeout set to 480000ms, elapsed time including timeout handling was 674809ms).&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
</description>
                <environment></environment>
        <key id="5100864">JDK-8308038</key>
            <summary>java/util/concurrent/ThreadPerTaskExecutor/ThreadPerTaskExecutorTest.java timed out</summary>
                <type id="1" iconUrl="https://bugs.openjdk.org/secure/viewavatar?size=xsmall&amp;avatarId=14703&amp;avatarType=issuetype">Bug</type>
                                            <priority id="4" iconUrl="https://bugs.openjdk.org/images/jbsImages/p4.png">P4</priority>
                        <status id="5" iconUrl="https://bugs.openjdk.org/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="success"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="alanb">Alan Bateman</assignee>
                                    <reporter username="dcubed">Daniel Daugherty</reporter>
                        <labels>
                            <label>genzgc</label>
                            <label>noreg-self</label>
                            <label>tier5</label>
                    </labels>
                <created>Sat, 13 May 2023 07:02:31 -0700</created>
                <updated>Sun, 28 May 2023 20:47:45 -0700</updated>
                            <resolved>Tue, 23 May 2023 00:08:00 -0700</resolved>
                                    <version>21</version>
                                    <fixVersion>21</fixVersion>
                                    <component>core-libs</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>8</watches>
                                                                                                                <comments>
                            <comment id="14583731" author="dcubed" created="Tue, 23 May 2023 07:19:34 -0700"  >The fix for this bug is integrated in jdk-21+24-2061.</comment>
                            <comment id="14583547" author="dukebot" created="Tue, 23 May 2023 00:07:59 -0700"  >Changeset: fe8c689e&lt;br/&gt;
Author:    Alan Bateman &amp;lt;&lt;a href=&apos;mailto:alanb@openjdk.org&apos;&gt;alanb@openjdk.org&lt;/a&gt;&amp;gt;&lt;br/&gt;
Date:      2023-05-23 07:05:44 +0000&lt;br/&gt;
URL:       &lt;a href=&quot;https://git.openjdk.org/jdk/commit/fe8c689eeea4fa19d4a8742f4ef1d8216f1394e6&quot;&gt;https://git.openjdk.org/jdk/commit/fe8c689eeea4fa19d4a8742f4ef1d8216f1394e6&lt;/a&gt;&lt;br/&gt;
</comment>
                            <comment id="14583268" author="roboduke" created="Mon, 22 May 2023 01:37:00 -0700"  >A pull request was submitted for review.&lt;br/&gt;
URL: &lt;a href=&quot;https://git.openjdk.org/jdk/pull/14072&quot;&gt;https://git.openjdk.org/jdk/pull/14072&lt;/a&gt;&lt;br/&gt;
Date: 2023-05-21 13:52:06 +0000</comment>
                            <comment id="14582641" author="martin" created="Thu, 18 May 2023 08:45:44 -0700"  >j.u.c. tests were understandably plagued by flakes due to sleeps or timeouts that weren&amp;#39;t long enough.&lt;br/&gt;
&lt;br/&gt;
I made a serious effort over the years to deflake and remove any sleeps, so that e.g. all the tck tests run in ~10 seconds total, while being resistant to long stalls during execution - LONG_DELAY_MS defaults to 10_000.&lt;br/&gt;
&lt;br/&gt;
After running billions of iterations (thanks, Google infrastructure!) I developed the rule of thumb that 10 seconds is long enough that one can be sure it&amp;#39;s a real failure and not e.g. due to a stall running a trivial task in another thread.  The longest stall ever actually observed in a test was about 4 seconds.&lt;br/&gt;
&lt;br/&gt;
And that&amp;#39;s why you can see things like&lt;br/&gt;
&lt;br/&gt;
```&lt;br/&gt;
&amp;nbsp;static final long LONG_DELAY_MS = Utils.adjustTimeout(10_000);&lt;br/&gt;
```&lt;br/&gt;
</comment>
                            <comment id="14582472" author="smarks" created="Wed, 17 May 2023 13:55:43 -0700"  >&amp;quot;This test violates Martin&amp;#39;s 10-second rule of thumb to avoid test flakes.&amp;quot; &lt;br/&gt;
&lt;br/&gt;
[~martin] Could you explain this rule? It sounds like something good for us to continue to keep in mind. Thanks.</comment>
                            <comment id="14582233" author="alanb" created="Tue, 16 May 2023 23:38:59 -0700"  >I have changes coming that replace the scheduleInterrupt in  testInterruptInvokeAny, testInvokeAllInterrupt4 and testInvokeAllInterrupt6 so they only interrupt when the tasks are running. I think we&amp;#39;re only seeing these failure recently because TPPE moved to using FutureTask in JDK 21. The task is effectively stillborn if interrupted before is executes, which wasn&amp;#39;t the case with the previous implementation. Sorry for the noise in the CI.</comment>
                            <comment id="14582225" author="jpai" created="Tue, 16 May 2023 22:19:00 -0700"  >This test method testInvokeAllInterrupt6 (and at least one other similar method) does this at a high level:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;...&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;scheduleInterrupt(Thread.currentThread(), Duration.ofMillis(500));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;try {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;executor.invokeAll(Set.of(task1, task2), 1, TimeUnit.DAYS);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;fail(&amp;quot;invokeAll did not throw&amp;quot;);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;} catch (InterruptedException expected) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;assertFalse(Thread.currentThread().isInterrupted());&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// task2 should have been interrupted&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;while (!task2.isDone()) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Thread.sleep(Duration.ofMillis(100));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&lt;br/&gt;
So it schedules a task which is expected to interrupt the current thread that&amp;#39;s running the test method after 500 milli seconds. Within those 500 milli seconds, this very thread schedules through an executor 2 tasks (which are java.util.concurrent.Callable instances) and waits, by calling invokeAll(), for both those tasks to complete. After 500 milli seconds, the current waiting thread is expected to be interrupted and the submitted invokeAll() tasks are expected to be cancelled (and thus task2 which is doing a Thread.sleep(...) is expected to be interrupted). Once this current thread is interrupted it enters the catch block and then verifies that the other task2 too has been completed due to interruption.&lt;br/&gt;
&lt;br/&gt;
In these specific runs where this seems to be timing out, the only way this test can timeout is if task2&amp;#39;s call() method hasn&amp;#39;t been called at all, by the time the current thread is interrupted. Looking at how ThreadPerTaskExecutor.invokeAll() is implemented, I think this is what is indeed happening - i.e. the task2&amp;#39;s call() hasn&amp;#39;t been called by the time the current thread got interrupted.&lt;br/&gt;
&lt;br/&gt;
The invokeAll() implementation first creates threads for each task and start()s those threads and assigns the corresponding Future instances to an internal list. It then iterates over the Future(s) list and waits on them. This wait can/will get interuppted in this test and once that happens, the invokeAll() implementation cancel(s) these Future(s). Since the submitted tasks are Callable instances, internally, the ThreadPerTaskExecutor uses a wrapper which implements the java.lang.Runnable interface that is passed on to the created threads. The implementation of this Runnable is responsible for passing on the invocation to the task&amp;#39;s call() method.&lt;br/&gt;
&lt;br/&gt;
Now, in this test, it&amp;#39;s possible that by the time the call reaches executor.invokeAll() a substantially long time might have passed such that it&amp;#39;s almost time for the schedule to interrupt the main thread. There&amp;#39;s now a small window of time where the invokeAll() implementation has started the tasks&amp;#39; threads and those threads are in the run() implementation of the wrapper Runnable and the main thread is waiting on future.get(...) in the invokeAll implementation. At this point, if the main thread gets interuppted then the invokeAll() will cancel the tasks and the threads which are in the wrapper&amp;#39;s run() method might notice that the task is cancelled and thus will never invoke the underlying call() method on the submitted task. Thus the task never gets executed and the test&amp;#39;s expectations fail.&lt;br/&gt;
&lt;br/&gt;
What this underlines is that there can be no expectations that the submitted tasks&amp;#39; call() method will be called when using ThreadPerTaskExecutor.invokeAll() if the current thread is interrupted, when the invokeAll is waiting on the submitted tasks to complete. One way to fix this test is probably doing something like:&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
diff --git a/test/jdk/java/util/concurrent/ThreadPerTaskExecutor/ThreadPerTaskExecutorTest.java b/test/jdk/java/util/concurrent/ThreadPerTaskExecutor/ThreadPerTaskExecutorTest.java&lt;br/&gt;
index d57cacb7001..392021848c9 100644&lt;br/&gt;
--- a/test/jdk/java/util/concurrent/ThreadPerTaskExecutor/ThreadPerTaskExecutorTest.java&lt;br/&gt;
+++ b/test/jdk/java/util/concurrent/ThreadPerTaskExecutor/ThreadPerTaskExecutorTest.java&lt;br/&gt;
@@ -898,11 +898,13 @@ class ThreadPerTaskExecutorTest {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;} catch (InterruptedException expected) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;assertFalse(Thread.currentThread().isInterrupted());&lt;br/&gt;
&amp;nbsp;&lt;br/&gt;
-                // task2 should have been interrupted&lt;br/&gt;
-                while (!task2.isDone()) {&lt;br/&gt;
-                    Thread.sleep(Duration.ofMillis(100));&lt;br/&gt;
+                if (task2.wasCalled()) {&lt;br/&gt;
+                    // task2 should have been interrupted, if it was invoked&lt;br/&gt;
+                    while (!task2.isDone()) {&lt;br/&gt;
+                        Thread.sleep(Duration.ofMillis(100));&lt;br/&gt;
+                    }&lt;br/&gt;
+                    assertTrue(task2.exception() instanceof InterruptedException);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
-                assertTrue(task2.exception() instanceof InterruptedException);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;} finally {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Thread.interrupted(); // clear interrupt&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
@@ -1047,11 +1049,15 @@ class ThreadPerTaskExecutorTest {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;final Duration delay;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;volatile boolean done;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;volatile Exception exception;&lt;br/&gt;
+        volatile boolean called;&lt;br/&gt;
+&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;DelayedResult(T result, Duration delay) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;this.result = result;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;this.delay = delay;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
+        @Override&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public T call() throws Exception {&lt;br/&gt;
+            called = true;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;try {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Thread.sleep(delay);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return result;&lt;br/&gt;
@@ -1065,6 +1071,9 @@ class ThreadPerTaskExecutorTest {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;boolean isDone() {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return done;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
+        boolean wasCalled() {&lt;br/&gt;
+            return called;&lt;br/&gt;
+        }&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Exception exception() {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return exception;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
</comment>
                            <comment id="14582204" author="martin" created="Tue, 16 May 2023 19:19:03 -0700"  >This test violates Martin&amp;#39;s 10-second rule of thumb to avoid test flakes.&lt;br/&gt;
That said, 500ms should be enough to make any flakes vanishingly rare.&lt;br/&gt;
&lt;br/&gt;
Waiting on a CountDownLatch(1) is better than spinning on a boolean.&lt;br/&gt;
&lt;br/&gt;
The test should check that tasks were done in less than Duration.ofMinutes(1).</comment>
                            <comment id="14581981" author="stefank" created="Tue, 16 May 2023 10:54:05 -0700"  >I&amp;#39;ve looked at a couple of failures. The test spins on the isDone() check until it times out.&lt;br/&gt;
&lt;br/&gt;
```&lt;br/&gt;
void testInvokeAllInterrupt4(ExecutorService executor) throws Exception {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;try (executor) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Callable&amp;lt;String&amp;gt; task1 = () -&amp;gt; &amp;quot;foo&amp;quot;;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;DelayedResult&amp;lt;String&amp;gt; task2 = new DelayedResult(&amp;quot;bar&amp;quot;, Duration.ofMinutes(1));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;scheduleInterrupt(Thread.currentThread(), Duration.ofMillis(500));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;try {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;executor.invokeAll(Set.of(task1, task2));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;fail(&amp;quot;invokeAll did not throw&amp;quot;);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;} catch (InterruptedException expected) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;assertFalse(Thread.currentThread().isInterrupted());&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// task2 should have been interrupted&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;while (!task2.isDone()) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Thread.sleep(Duration.ofMillis(100));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;assertTrue(task2.exception() instanceof InterruptedException);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;} finally {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Thread.interrupted(); // clear interrupt&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
static class DelayedResult&amp;lt;T&amp;gt; implements Callable&amp;lt;T&amp;gt; {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;final T result;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;final Duration delay;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;volatile boolean done;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;volatile Exception exception;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;DelayedResult(T result, Duration delay) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;this.result = result;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;this.delay = delay;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public T call() throws Exception {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;try {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Thread.sleep(delay);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return result;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;} catch (Exception e) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;this.exception = e;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;throw e;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;} finally {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;done = true;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;boolean isDone() {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return done;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Exception exception() {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return exception;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
}&lt;br/&gt;
```&lt;br/&gt;
&lt;br/&gt;
From my local runs I see that we don&amp;#39;t even start a GC.</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10002">
                    <name>Duplicate</name>
                                            <outwardlinks description="duplicates">
                                        <issuelink>
            <issuekey id="5100865">JDK-8308039</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                    </issuelinks>
                <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_10000" key="com.atlassian.jira.plugin.system.customfieldtypes:multiselect">
                        <customfieldname>CPU</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="19000"><![CDATA[x86_64]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_11700" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_10600" key="com.oracle.jira.javabugsystem-jira-plugin:jbs-fixedBackportedCustomfield">
                        <customfieldname>Fixed</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                            <customfield id="customfield_10005" key="com.atlassian.jira.plugin.system.customfieldtypes:multiselect">
                        <customfieldname>OS</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="17005"><![CDATA[windows]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                            <customfield id="customfield_11100" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i31ig3:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_11004" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10006" key="com.atlassian.jira.plugin.system.customfieldtypes:select">
                        <customfieldname>Resolved In Build</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="17436"><![CDATA[b24]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10008" key="com.oracle.jira.jira-subcomponent-plugin:oracle-subComponentField">
                        <customfieldname>Subcomponent</customfieldname>
                        <customfieldvalues>
                             <customfieldvalue key="215"><![CDATA[java.util.concurrent]]></customfieldvalue> 
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_10601" key="com.oracle.jira.javabugsystem-jira-plugin:jbs-targetBackportedCustomfield">
                        <customfieldname>Targeted</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    </customfields>
    </item>
</channel>
</rss>