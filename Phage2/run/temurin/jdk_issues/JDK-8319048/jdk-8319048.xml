<!-- 
RSS generated by JIRA (9.12.27#9120027-sha1:edc4490121e366e9e7bd2213d532dbe7e028fc5d) at Tue Sep 30 11:45:27 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>Java Bug System</title>
    <link>https://bugs.openjdk.org</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-us</language>    <build-info>
        <version>9.12.27</version>
        <build-number>9120027</build-number>
        <build-date>02-09-2025</build-date>
    </build-info>


<item>
            <title>[JDK-8319048] Monitor deflation unlink phase prolongs time to safepoint</title>
                <link>https://bugs.openjdk.org/browse/JDK-8319048</link>
                <project id="10100" key="JDK">JDK</project>
                    <description>We have seen one of the cases in our production, where we have TTSP hiccups. Profiling shows the hiccup is in monitor deflation thread, which is busy unlinking the monitors. It is batched with `MonitorDeflationMax` (default: 1M) and checks safepoint after each batch.&lt;br/&gt;
&lt;br/&gt;
However, the current default for the batch is unfortunately very high. If we spend just a 1ns per unlinking monitor, 1M batch size means we would not respond to safepoint request for about 1ms. In practice, it seems the delays are up to 30 ms. This gives a major latency hiccup.&lt;br/&gt;
&lt;br/&gt;
Here is the simplest reproducer I have:&lt;br/&gt;
&lt;br/&gt;
```&lt;br/&gt;
import java.util.ArrayList;&lt;br/&gt;
import java.util.List;&lt;br/&gt;
&lt;br/&gt;
public class MonitorChurn {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;static final int THREAD_COUNT = Integer.getInteger(&amp;quot;threads&amp;quot;, 10);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;static final int MONITORS_PER_THREAD = Integer.getInteger(&amp;quot;monitors&amp;quot;, 1_000_000);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;static class HolderThread extends Thread {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Object[] objs = new Object[MONITORS_PER_THREAD];&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public void run() {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;try {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;for (int c = 0; c &amp;lt; objs.length; c++) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;objs[c] = new Object();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;while (true) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;for (int c = 0; c &amp;lt; objs.length; c++) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;synchronized (objs[c]) {}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;} catch (Exception e) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;e.printStackTrace();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;static Object sink;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;public static void main(String... args) throws Exception {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;for (int c = 0; c &amp;lt; THREAD_COUNT; c++) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Thread t = new HolderThread();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;t.start();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;while (true) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;sink = new byte[1000000];&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Thread.sleep(1);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
}&lt;br/&gt;
```&lt;br/&gt;
&lt;br/&gt;
I added two logging statements in deflation/unlinking code to see when we are actually hitting the deflation/unlinking paths. &lt;br/&gt;
&lt;br/&gt;
```&lt;br/&gt;
diff --git a/src/hotspot/share/runtime/synchronizer.cpp b/src/hotspot/share/runtime/synchronizer.cpp&lt;br/&gt;
index c83df922e0d..a5a16c56968 100644&lt;br/&gt;
--- a/src/hotspot/share/runtime/synchronizer.cpp&lt;br/&gt;
+++ b/src/hotspot/share/runtime/synchronizer.cpp&lt;br/&gt;
@@ -132,6 +132,7 @@ size_t MonitorList::unlink_deflated(Thread* current, LogStream* ls,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;ObjectMonitor* prev = nullptr;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;ObjectMonitor* head = Atomic::load_acquire(&amp;amp;_head);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;ObjectMonitor* m = head;&lt;br/&gt;
+  log_warning(monitorinflation)(&amp;quot;IN UNLINK PATH: &amp;quot; SIZE_FORMAT &amp;quot; MONITORS TO UNLINK&amp;quot;, count());&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;// The in-use list head can be null during the final audit.&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;while (m != nullptr) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if (m-&amp;gt;is_being_async_deflated()) {&lt;br/&gt;
@@ -1688,6 +1689,8 @@ size_t ObjectSynchronizer::deflate_idle_monitors(ObjectMonitorsHashtable* table)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;size_t unlinked_count = 0;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;size_t deleted_count = 0;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;if (deflated_count &amp;gt; 0 || is_final_audit()) {&lt;br/&gt;
+    log_warning(monitorinflation)(&amp;quot;IN DEFLATION PATH: &amp;quot; SIZE_FORMAT &amp;quot; MONITORS DEFLATED&amp;quot;, deflated_count);&lt;br/&gt;
+&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// There are ObjectMonitors that have been deflated or this is the&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// final audit and all the remaining ObjectMonitors have been&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// deflated, BUT the MonitorDeflationThread blocked for the final&lt;br/&gt;
&lt;br/&gt;
```&lt;br/&gt;
&lt;br/&gt;
The result is like this:&lt;br/&gt;
&lt;br/&gt;
```&lt;br/&gt;
$ /java -XX:+UnlockDiagnosticVMOptions -Xmx256m -XX:GuaranteedAsyncDeflationInterval=1000 -XX:+UseParallelGC -XX:LockingMode=0 -XX:MonitorDeflationMax=1000000 -Xlog:safepoint+stats MonitorChurn.java&lt;br/&gt;
&lt;br/&gt;
[10.589s][info   ][safepoint,stats ] VM Operation                 [ threads: total initial_running ][ time:       sync    cleanup       vmop      total ] page_trap_count&lt;br/&gt;
[10.589s][info   ][safepoint,stats ] ParallelGCFailedAllocation   [             20              10 ][            62375       2541   62300334   62365250 ]               0&lt;br/&gt;
[10.705s][info   ][safepoint,stats ] ParallelGCFailedAllocation   [             20              10 ][            42875       1375   62180458   62224708 ]               0&lt;br/&gt;
[10.756s][warning][monitorinflation] IN DEFLATION PATH: 1000000 MONITORS DEFLATED&lt;br/&gt;
[10.757s][warning][monitorinflation] IN UNLINK PATH: 2399912 MONITORS TO UNLINK&lt;br/&gt;
[10.834s][info   ][safepoint,stats ] ParallelGCFailedAllocation   [             20              11 ][         12407500       7208   63076667   75491375 ]               1&lt;br/&gt;
[10.953s][info   ][safepoint,stats ] ParallelGCFailedAllocation   [             20              11 ][            59208       2042   65406500   65467750 ]               0&lt;br/&gt;
[11.067s][info   ][safepoint,stats ] ParallelGCFailedAllocation   [             20              10 ][            26292       1917   61031375   61059584 ]               0&lt;br/&gt;
[11.182s][info   ][safepoint,stats ] ParallelGCFailedAllocation   [             20              10 ][            40334       1708   62094458   62136500 ]               0&lt;br/&gt;
[11.294s][info   ][safepoint,stats ] ParallelGCFailedAllocation   [             20              10 ][            43083       2167   58604166   58649416 ]               0&lt;br/&gt;
[11.404s][info   ][safepoint,stats ] ParallelGCFailedAllocation   [             20              10 ][            43083       2542   56941542   56987167 ]               0&lt;br/&gt;
[&lt;br/&gt;
```&lt;br/&gt;
&lt;br/&gt;
Near the 2.4M monitor unlinking path we have incurred 12.4 ms TTSP latency.&lt;br/&gt;
&lt;br/&gt;
Naively, one can tune down `MonitorDeflationMax`, but it has impact on the number of monitors we actually deflate per one monitor deflation phase, which unfortunately creeps up monitor population, as deflater thread is less active. &lt;br/&gt;
&lt;br/&gt;
We need to take a deeper look into safepoint checking policy during unlinkage. It is interesting that deflation loop actually checks for pending safepoint on every monitor. It is not immediately clear why unliking requires batching. If it does require batching for good reason, we might want to split the thresholds into `MonitorDeflationMax` (which would continue to drive deflation batch) and `MonitorUnlinkMax` (which would drive the batching for unlinkage).</description>
                <environment></environment>
        <key id="5113463">JDK-8319048</key>
            <summary>Monitor deflation unlink phase prolongs time to safepoint</summary>
                <type id="7" iconUrl="https://bugs.openjdk.org/secure/viewavatar?size=xsmall&amp;avatarId=14707&amp;avatarType=issuetype">Enhancement</type>
                                            <priority id="4" iconUrl="https://bugs.openjdk.org/images/jbsImages/p4.png">P4</priority>
                        <status id="5" iconUrl="https://bugs.openjdk.org/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="success"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="shade">Aleksey Shipilev</assignee>
                                    <reporter username="shade">Aleksey Shipilev</reporter>
                        <labels>
                            <label>amazon-interest</label>
                            <label>jdk17u-fix-request</label>
                            <label>jdk17u-fix-yes</label>
                            <label>jdk21u-fix-request</label>
                            <label>jdk21u-fix-yes</label>
                            <label>sync</label>
                    </labels>
                <created>Fri, 27 Oct 2023 12:51:19 -0700</created>
                <updated>Tue, 27 Aug 2024 00:39:43 -0700</updated>
                            <resolved>Tue, 28 Nov 2023 01:50:34 -0800</resolved>
                                    <version>17</version>
                    <version>21</version>
                    <version>22</version>
                                    <fixVersion>22</fixVersion>
                                    <component>hotspot</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>14</watches>
                                                                                                                <comments>
                            <comment id="14666315" author="roboduke" created="Thu, 18 Apr 2024 11:40:43 -0700"  >[jdk17u-fix-request] Approval Request from Aleksey Shipil&amp;#xEB;v&lt;br/&gt;
Unclean backport to eliminate another safepoint hiccup caused by monitor deflation. The uncleanliness comes from the usual `NULL` vs `nullptr` differences. Otherwise applies cleanly. We are not at risk with interleaving with anything else in JDK 17: &lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8273107&quot; title=&quot;RunThese24H times out with &amp;quot;java.lang.management.ThreadInfo.getLockName()&amp;quot; is null&quot; class=&quot;issue-link&quot; data-issue-key=&quot;JDK-8273107&quot;&gt;&lt;strike&gt;JDK-8273107&lt;/strike&gt;&lt;/a&gt; is not present, so we don&amp;#39;t collide with VM_ThreadDump; final audit (removed in JDK 21+ with &lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8319896&quot; title=&quot;Remove monitor deflation from final audit&quot; class=&quot;issue-link&quot; data-issue-key=&quot;JDK-8319896&quot;&gt;&lt;strike&gt;JDK-8319896&lt;/strike&gt;&lt;/a&gt;) should not be risky. All tests pass.</comment>
                            <comment id="14659404" author="roboduke" created="Thu, 21 Mar 2024 10:23:31 -0700"  >A pull request was submitted for review.&lt;br/&gt;
URL: &lt;a href=&quot;https://git.openjdk.org/jdk17u-dev/pull/2309&quot;&gt;https://git.openjdk.org/jdk17u-dev/pull/2309&lt;/a&gt;&lt;br/&gt;
Date: 2024-03-19 18:33:35 +0000</comment>
                            <comment id="14658631" author="roboduke" created="Tue, 19 Mar 2024 08:04:40 -0700"  >[jdk21u-fix-request] Approval Request from Aleksey Shipil&amp;#xEB;v&lt;br/&gt;
Clean backport to improve TTSP under heavy monitor deflation, and provide better parity with 21.0.4-oracle. Applies cleanly. All tests pass. The risk is medium: it touches the fiddly monitor code. We have seen no bug tail since the original integration in Nov 2023.</comment>
                            <comment id="14658045" author="roboduke" created="Mon, 18 Mar 2024 03:13:48 -0700"  >A pull request was submitted for review.&lt;br/&gt;
URL: &lt;a href=&quot;https://git.openjdk.org/jdk21u-dev/pull/369&quot;&gt;https://git.openjdk.org/jdk21u-dev/pull/369&lt;/a&gt;&lt;br/&gt;
Date: 2024-03-18 09:15:14 +0000</comment>
                            <comment id="14657465" author="JIRAUSER19505" created="Thu, 14 Mar 2024 08:51:28 -0700"  >Thanks for confirming, [~shade]</comment>
                            <comment id="14657454" author="shade" created="Thu, 14 Mar 2024 08:37:28 -0700"  >Yes, that is my understanding as well. I am waiting for &lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8318757&quot; title=&quot;VM_ThreadDump asserts in interleaved ObjectMonitor::deflate_monitor calls&quot; class=&quot;issue-link&quot; data-issue-key=&quot;JDK-8318757&quot;&gt;&lt;strike&gt;JDK-8318757&lt;/strike&gt;&lt;/a&gt; to land in jdk21u-dev, after which I am planning to propose this fix to jdk21u-dev. I plan to propose this fix to jdk17u-dev as well.</comment>
                            <comment id="14657421" author="JIRAUSER19505" created="Thu, 14 Mar 2024 06:41:04 -0700"  >Backporting considerations (summary of my understanding, based on comments in &lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8318757&quot; title=&quot;VM_ThreadDump asserts in interleaved ObjectMonitor::deflate_monitor calls&quot; class=&quot;issue-link&quot; data-issue-key=&quot;JDK-8318757&quot;&gt;&lt;strike&gt;JDK-8318757&lt;/strike&gt;&lt;/a&gt; and &lt;a href=&quot;https://github.com/openjdk/jdk/pull/16412)&quot;&gt;https://github.com/openjdk/jdk/pull/16412)&lt;/a&gt;&lt;br/&gt;
&lt;br/&gt;
Background:&lt;br/&gt;
Monitor deflation is the process of removing the explicit native monitors which are created for objects used in synchronization. Since any object can be synchronized on, theoretically there might be as many native monitors as there are objects.&lt;br/&gt;
In the past, monitor deflation was always done in a safepoint. This fell out of fashion, deflation started being done concurrently in a separate thread, and there was in principle no deflation done in safepoints in the jdk17 timespan. &lt;br/&gt;
&lt;br/&gt;
Timeline:&lt;br/&gt;
&lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8273107&quot; title=&quot;RunThese24H times out with &amp;quot;java.lang.management.ThreadInfo.getLockName()&amp;quot; is null&quot; class=&quot;issue-link&quot; data-issue-key=&quot;JDK-8273107&quot;&gt;&lt;strike&gt;JDK-8273107&lt;/strike&gt;&lt;/a&gt; changed this - introduced in jdk18, it added monitor deflation inside a safepoint again, in the VM_TreadDump VM operation.&lt;br/&gt;
&lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8318757&quot; title=&quot;VM_ThreadDump asserts in interleaved ObjectMonitor::deflate_monitor calls&quot; class=&quot;issue-link&quot; data-issue-key=&quot;JDK-8318757&quot;&gt;&lt;strike&gt;JDK-8318757&lt;/strike&gt;&lt;/a&gt; addressed a problem with this - when concurrent deflation was interleaved with in-safepoint deflation, crashes could happen. This didn&amp;#39;t happen often in practice because part of the concurrent deflation process wasn&amp;#39;t polling for safepoints that much. &lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8318757&quot; title=&quot;VM_ThreadDump asserts in interleaved ObjectMonitor::deflate_monitor calls&quot; class=&quot;issue-link&quot; data-issue-key=&quot;JDK-8318757&quot;&gt;&lt;strike&gt;JDK-8318757&lt;/strike&gt;&lt;/a&gt; removed the deflation happening inside VM_TreadDump.&lt;br/&gt;
&lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8319048&quot; title=&quot;Monitor deflation unlink phase prolongs time to safepoint&quot; class=&quot;issue-link&quot; data-issue-key=&quot;JDK-8319048&quot;&gt;&lt;strike&gt;JDK-8319048&lt;/strike&gt;&lt;/a&gt; (this issue) makes the last part of concurrent deflation poll for safepoints more often. This reduces time-to-safepoint, but would have hit the issue from &lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8273107&quot; title=&quot;RunThese24H times out with &amp;quot;java.lang.management.ThreadInfo.getLockName()&amp;quot; is null&quot; class=&quot;issue-link&quot; data-issue-key=&quot;JDK-8273107&quot;&gt;&lt;strike&gt;JDK-8273107&lt;/strike&gt;&lt;/a&gt; much more often, had not &lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8318757&quot; title=&quot;VM_ThreadDump asserts in interleaved ObjectMonitor::deflate_monitor calls&quot; class=&quot;issue-link&quot; data-issue-key=&quot;JDK-8318757&quot;&gt;&lt;strike&gt;JDK-8318757&lt;/strike&gt;&lt;/a&gt; been introduced.&lt;br/&gt;
&lt;br/&gt;
Conclusions:&lt;br/&gt;
If/when backporting &lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8319048&quot; title=&quot;Monitor deflation unlink phase prolongs time to safepoint&quot; class=&quot;issue-link&quot; data-issue-key=&quot;JDK-8319048&quot;&gt;&lt;strike&gt;JDK-8319048&lt;/strike&gt;&lt;/a&gt;, care must be taken whether &lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8273107&quot; title=&quot;RunThese24H times out with &amp;quot;java.lang.management.ThreadInfo.getLockName()&amp;quot; is null&quot; class=&quot;issue-link&quot; data-issue-key=&quot;JDK-8273107&quot;&gt;&lt;strike&gt;JDK-8273107&lt;/strike&gt;&lt;/a&gt; exists in the backport target. If it does, then &lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8318757&quot; title=&quot;VM_ThreadDump asserts in interleaved ObjectMonitor::deflate_monitor calls&quot; class=&quot;issue-link&quot; data-issue-key=&quot;JDK-8318757&quot;&gt;&lt;strike&gt;JDK-8318757&lt;/strike&gt;&lt;/a&gt; must be backported before &lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8319048&quot; title=&quot;Monitor deflation unlink phase prolongs time to safepoint&quot; class=&quot;issue-link&quot; data-issue-key=&quot;JDK-8319048&quot;&gt;&lt;strike&gt;JDK-8319048&lt;/strike&gt;&lt;/a&gt;.&lt;br/&gt;
&lt;br/&gt;
Thanks to [~stefank] [~eosterlund] for bringing this to my attention and helping me understand the interplay.</comment>
                            <comment id="14629440" author="dukebot" created="Tue, 28 Nov 2023 01:50:32 -0800"  >Changeset: efc39225&lt;br/&gt;
Author:    Aleksey Shipilev &amp;lt;&lt;a href=&apos;mailto:shade@openjdk.org&apos;&gt;shade@openjdk.org&lt;/a&gt;&amp;gt;&lt;br/&gt;
Date:      2023-11-28 09:49:03 +0000&lt;br/&gt;
URL:       &lt;a href=&quot;https://git.openjdk.org/jdk/commit/efc392259c64986bbbe880259e95b09058b9076a&quot;&gt;https://git.openjdk.org/jdk/commit/efc392259c64986bbbe880259e95b09058b9076a&lt;/a&gt;&lt;br/&gt;
</comment>
                            <comment id="14622052" author="roboduke" created="Mon, 30 Oct 2023 08:24:11 -0700"  >A pull request was submitted for review.&lt;br/&gt;
URL: &lt;a href=&quot;https://git.openjdk.org/jdk/pull/16412&quot;&gt;https://git.openjdk.org/jdk/pull/16412&lt;/a&gt;&lt;br/&gt;
Date: 2023-10-30 08:20:37 +0000</comment>
                            <comment id="14621950" author="shade" created="Mon, 30 Oct 2023 01:08:20 -0700"  >I see why batching is needed: we have to modify MonitorList, and batching basically removes the entire runs of unlinkable monitors in one list update. Then we probably just need to make sure those batches are not overly large.</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10200">
                    <name>Backport</name>
                                            <outwardlinks description="backported by">
                                        <issuelink>
            <issuekey id="5124228">JDK-8328182</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="5124439">JDK-8328354</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="5124822">JDK-8328677</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="5127407">JDK-8330692</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                            <issuelinktype id="10000">
                    <name>Blocks</name>
                                                                <inwardlinks description="is blocked by">
                                        <issuelink>
            <issuekey id="5113126">JDK-8318757</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                            <issuelinktype id="10003">
                    <name>Relates</name>
                                                                <inwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="5120947">JDK-8325437</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_11700" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_10600" key="com.oracle.jira.javabugsystem-jira-plugin:jbs-fixedBackportedCustomfield">
                        <customfieldname>Fixed</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_11100" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i33nuz:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_11004" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10006" key="com.atlassian.jira.plugin.system.customfieldtypes:select">
                        <customfieldname>Resolved In Build</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="17357"><![CDATA[b26]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10008" key="com.oracle.jira.jira-subcomponent-plugin:oracle-subComponentField">
                        <customfieldname>Subcomponent</customfieldname>
                        <customfieldvalues>
                             <customfieldvalue key="192"><![CDATA[runtime]]></customfieldvalue> 
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_10601" key="com.oracle.jira.javabugsystem-jira-plugin:jbs-targetBackportedCustomfield">
                        <customfieldname>Targeted</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    </customfields>
    </item>
</channel>
</rss>