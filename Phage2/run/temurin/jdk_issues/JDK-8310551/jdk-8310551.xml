<!-- 
RSS generated by JIRA (9.12.27#9120027-sha1:edc4490121e366e9e7bd2213d532dbe7e028fc5d) at Tue Sep 30 09:29:31 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>Java Bug System</title>
    <link>https://bugs.openjdk.org</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-us</language>    <build-info>
        <version>9.12.27</version>
        <build-number>9120027</build-number>
        <build-date>02-09-2025</build-date>
    </build-info>


<item>
            <title>[JDK-8310551] vmTestbase/nsk/jdb/interrupt/interrupt001/interrupt001.java timed out due to missing prompt</title>
                <link>https://bugs.openjdk.org/browse/JDK-8310551</link>
                <project id="10100" key="JDK">JDK</project>
                    <description>The following test timed out in the JDK21 CI:&lt;br/&gt;
&lt;br/&gt;
vmTestbase/nsk/jdb/interrupt/interrupt001/interrupt001.java&lt;br/&gt;
&lt;br/&gt;
Here&amp;#39;s a snippet from the log file:&lt;br/&gt;
&lt;br/&gt;
#section:main&lt;br/&gt;
----------messages:(6/1956)----------&lt;br/&gt;
command: main nsk.jdb.interrupt.interrupt001.interrupt001 -arch=linux-x64 -waittime=5 -debugee.vmkind=java -transport.address=dynamic -jdb=/opt/mach5/mesos/work_dir/jib-master/install/jdk-21+28-2370/linux-x64-debug.jdk/jdk-21/fastdebug/bin/jdb -java.options=&amp;quot;-XX:MaxRAMPercentage=4.16667 -Dtest.boot.jdk=/opt/mach5/mesos/work_dir/jib-master/install/jdk/20/36/bundles/linux-x64/jdk-20_linux-x64_bin.tar.gz/jdk-20 -Djava.io.tmpdir=/opt/mach5/mesos/work_dir/slaves/741e9afd-8c02-45c3-b2e2-9db1450d0832-S24786/frameworks/1735e8a2-a1db-478c-8104-60c8b0af87dd-0196/executors/7017c33b-e64b-4be6-9c80-dd90f1817134/runs/94477d99-63d4-48b7-9576-5f84f27a68c5/testoutput/test-support/jtreg_open_test_hotspot_jtreg_vmTestbase_nsk_jdb/tmp -Xcomp -XX:+CreateCoredumpOnCrash -ea -esa -XX:CompileThreshold=100 -XX:+UnlockExperimentalVMOptions -server -XX:-TieredCompilation&amp;quot; -workdir=. -debugee.vmkeys=&amp;quot;-XX:MaxRAMPercentage=4.16667 -Dtest.boot.jdk=/opt/mach5/mesos/work_dir/jib-master/install/jdk/20/36/bundles/linux-x64/jdk-20_linux-x64_bin.tar.gz/jdk-20 -Djava.io.tmpdir=/opt/mach5/mesos/work_dir/slaves/741e9afd-8c02-45c3-b2e2-9db1450d0832-S24786/frameworks/1735e8a2-a1db-478c-8104-60c8b0af87dd-0196/executors/7017c33b-e64b-4be6-9c80-dd90f1817134/runs/94477d99-63d4-48b7-9576-5f84f27a68c5/testoutput/test-support/jtreg_open_test_hotspot_jtreg_vmTestbase_nsk_jdb/tmp -Xcomp -XX:+CreateCoredumpOnCrash -ea -esa -XX:CompileThreshold=100 -XX:+UnlockExperimentalVMOptions -server -XX:-TieredCompilation&amp;quot;&lt;br/&gt;
reason: User specified action: run main/othervm nsk.jdb.interrupt.interrupt001.interrupt001 -arch=${os.family}-${os.simpleArch} -waittime=5 -debugee.vmkind=java -transport.address=dynamic -jdb=${test.jdk}/bin/jdb -java.options=&amp;quot;${test.vm.opts} ${test.java.opts}&amp;quot; -workdir=. -debugee.vmkeys=&amp;quot;${test.vm.opts} ${test.java.opts}&amp;quot; &lt;br/&gt;
started: Wed Jun 21 11:39:31 UTC 2023&lt;br/&gt;
Mode: othervm [/othervm specified]&lt;br/&gt;
finished: Wed Jun 21 11:50:55 UTC 2023&lt;br/&gt;
elapsed time (seconds): 683.638&lt;br/&gt;
----------configuration:(0/0)----------&lt;br/&gt;
----------System.out:(173/11140)----------&lt;br/&gt;
Launching process by array of args: &lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;args[0]: &amp;gt;/opt/mach5/mesos/work_dir/jib-master/install/jdk-21+28-2370/linux-x64-debug.jdk/jdk-21/fastdebug/bin/jdb&amp;lt;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;args[1]: &amp;gt;-J-XX:MaxRAMPercentage=4.16667&amp;lt;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;args[2]: &amp;gt;-J-Dtest.boot.jdk=/opt/mach5/mesos/work_dir/jib-master/install/jdk/20/36/bundles/linux-x64/jdk-20_linux-x64_bin.tar.gz/jdk-20&amp;lt;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;args[3]: &amp;gt;-J-Djava.io.tmpdir=/opt/mach5/mesos/work_dir/slaves/741e9afd-8c02-45c3-b2e2-9db1450d0832-S24786/frameworks/1735e8a2-a1db-478c-8104-60c8b0af87dd-0196/executors/7017c33b-e64b-4be6-9c80-dd90f1817134/runs/94477d99-63d4-48b7-9576-5f84f27a68c5/testoutput/test-support/jtreg_open_test_hotspot_jtreg_vmTestbase_nsk_jdb/tmp&amp;lt;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;args[4]: &amp;gt;-J-Xcomp&amp;lt;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;args[5]: &amp;gt;-J-XX:+CreateCoredumpOnCrash&amp;lt;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;args[6]: &amp;gt;-J-ea&amp;lt;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;args[7]: &amp;gt;-J-esa&amp;lt;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;args[8]: &amp;gt;-J-XX:CompileThreshold=100&amp;lt;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;args[9]: &amp;gt;-J-XX:+UnlockExperimentalVMOptions&amp;lt;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;args[10]: &amp;gt;-J-server&amp;lt;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;args[11]: &amp;gt;-J-XX:-TieredCompilation&amp;lt;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;args[12]: &amp;gt;-connect&amp;lt;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;args[13]: &amp;gt;com.sun.jdi.CommandLineLaunch:vmexec=java,options= &amp;quot;-XX:MaxRAMPercentage=4.16667&amp;quot; &amp;quot;-Dtest.boot.jdk=/opt/mach5/mesos/work_dir/jib-master/install/jdk/20/36/bundles/linux-x64/jdk-20_linux-x64_bin.tar.gz/jdk-20&amp;quot; &amp;quot;-Djava.io.tmpdir=/opt/mach5/mesos/work_dir/slaves/741e9afd-8c02-45c3-b2e2-9db1450d0832-S24786/frameworks/1735e8a2-a1db-478c-8104-60c8b0af87dd-0196/executors/7017c33b-e64b-4be6-9c80-dd90f1817134/runs/94477d99-63d4-48b7-9576-5f84f27a68c5/testoutput/test-support/jtreg_open_test_hotspot_jtreg_vmTestbase_nsk_jdb/tmp&amp;quot; &amp;quot;-Xcomp&amp;quot; &amp;quot;-XX:+CreateCoredumpOnCrash&amp;quot; &amp;quot;-ea&amp;quot; &amp;quot;-esa&amp;quot; &amp;quot;-XX:CompileThreshold=100&amp;quot; &amp;quot;-XX:+UnlockExperimentalVMOptions&amp;quot; &amp;quot;-server&amp;quot; &amp;quot;-XX:-TieredCompilation&amp;quot;,main=nsk.jdb.interrupt.interrupt001.interrupt001a  -waittime 5&amp;lt;&lt;br/&gt;
#&amp;gt;  &lt;br/&gt;
#&amp;gt;  WARNING: switching log to verbose mode,&lt;br/&gt;
#&amp;gt;      because error is complained&lt;br/&gt;
#&amp;gt;  &lt;br/&gt;
launcher &amp;gt; Starting jdb launching local debuggee&lt;br/&gt;
Creating file for jdb stdout stream: ./jdb.stdout&lt;br/&gt;
Creating file for jdb session: ./jdb.session&lt;br/&gt;
Creating file for jdb stderr stream: ./jdb.stderr&lt;br/&gt;
Setting first breakpoint&lt;br/&gt;
Sending command: stop in nsk.jdb.interrupt.interrupt001.interrupt001a.main&lt;br/&gt;
reply[0]: Deferring breakpoint nsk.jdb.interrupt.interrupt001.interrupt001a.main.&lt;br/&gt;
reply[1]: It will be set after the class is loaded.&lt;br/&gt;
reply[2]: &amp;gt; &lt;br/&gt;
Starting debuggee class&lt;br/&gt;
Sending command: run &lt;br/&gt;
reply[0]: run nsk.jdb.interrupt.interrupt001.interrupt001a  -waittime 5&lt;br/&gt;
reply[1]: Set uncaught java.lang.Throwable&lt;br/&gt;
reply[2]: Set deferred uncaught java.lang.Throwable&lt;br/&gt;
reply[3]: &amp;gt; &lt;br/&gt;
reply[4]: VM Started: Set deferred breakpoint nsk.jdb.interrupt.interrupt001.interrupt001a.main&lt;br/&gt;
reply[5]: &lt;br/&gt;
reply[6]: Breakpoint hit: &amp;quot;thread=main&amp;quot;, nsk.jdb.interrupt.interrupt001.interrupt001a.main(), line=69 bci=0&lt;br/&gt;
reply[7]: 69           interrupt001a _interrupt001a = new interrupt001a();&lt;br/&gt;
reply[8]: &lt;br/&gt;
reply[9]: main[1] &lt;br/&gt;
Test cases starts.&lt;br/&gt;
Sending command: stop in nsk.jdb.interrupt.interrupt001.interrupt001a.breakHere&lt;br/&gt;
reply[0]: Set breakpoint nsk.jdb.interrupt.interrupt001.interrupt001a.breakHere&lt;br/&gt;
reply[1]: main[1] &lt;br/&gt;
Sending command: cont&lt;br/&gt;
reply[0]: &amp;gt; &lt;br/&gt;
reply[1]: Breakpoint hit: &amp;quot;thread=main&amp;quot;, nsk.jdb.interrupt.interrupt001.interrupt001a.breakHere(), line=73 bci=0&lt;br/&gt;
reply[2]: 73        static void breakHere () {}&lt;br/&gt;
reply[3]: &lt;br/&gt;
reply[4]: main[1] &lt;br/&gt;
Sending command: threads &lt;br/&gt;
reply[0]: Group system:&lt;br/&gt;
reply[1]:   (java.lang.ref.Reference$ReferenceHandler)498              Reference Handler   running&lt;br/&gt;
reply[2]:   (java.lang.ref.Finalizer$FinalizerThread)499               Finalizer           cond. waiting&lt;br/&gt;
reply[3]:   (java.lang.Thread)500                                      Signal Dispatcher   running&lt;br/&gt;
reply[4]:   (java.lang.Thread)497                                      Notification Thread running&lt;br/&gt;
reply[5]: Group main:&lt;br/&gt;
reply[6]:   (java.lang.Thread)1                                        main                running (at breakpoint)&lt;br/&gt;
reply[7]:   (nsk.jdb.interrupt.interrupt001.interrupt001a$MyThread)728 Thread-0            cond. waiting&lt;br/&gt;
reply[8]:   (nsk.jdb.interrupt.interrupt001.interrupt001a$MyThread)729 Thread-1            cond. waiting&lt;br/&gt;
reply[9]:   (nsk.jdb.interrupt.interrupt001.interrupt001a$MyThread)730 Thread-2            cond. waiting&lt;br/&gt;
reply[10]:   (nsk.jdb.interrupt.interrupt001.interrupt001a$MyThread)731 Thread-3            cond. waiting&lt;br/&gt;
reply[11]:   (nsk.jdb.interrupt.interrupt001.interrupt001a$MyThread)732 Thread-4            cond. waiting&lt;br/&gt;
reply[12]: Group InnocuousThreadGroup:&lt;br/&gt;
reply[13]:   (jdk.internal.misc.InnocuousThread)526                     Common-Cleaner      cond. waiting&lt;br/&gt;
reply[14]:   (jdk.internal.misc.InnocuousThread)716                     Cleaner-0           cond. waiting&lt;br/&gt;
reply[15]: main[1] &lt;br/&gt;
Sending command: threads &lt;br/&gt;
reply[0]: Group system:&lt;br/&gt;
reply[1]:   (java.lang.ref.Reference$ReferenceHandler)498              Reference Handler   running&lt;br/&gt;
reply[2]:   (java.lang.ref.Finalizer$FinalizerThread)499               Finalizer           cond. waiting&lt;br/&gt;
reply[3]:   (java.lang.Thread)500                                      Signal Dispatcher   running&lt;br/&gt;
reply[4]:   (java.lang.Thread)497                                      Notification Thread running&lt;br/&gt;
reply[5]: Group main:&lt;br/&gt;
reply[6]:   (java.lang.Thread)1                                        main                running (at breakpoint)&lt;br/&gt;
reply[7]:   (nsk.jdb.interrupt.interrupt001.interrupt001a$MyThread)728 Thread-0            cond. waiting&lt;br/&gt;
reply[8]:   (nsk.jdb.interrupt.interrupt001.interrupt001a$MyThread)729 Thread-1            cond. waiting&lt;br/&gt;
reply[9]:   (nsk.jdb.interrupt.interrupt001.interrupt001a$MyThread)730 Thread-2            cond. waiting&lt;br/&gt;
reply[10]:   (nsk.jdb.interrupt.interrupt001.interrupt001a$MyThread)731 Thread-3            cond. waiting&lt;br/&gt;
reply[11]:   (nsk.jdb.interrupt.interrupt001.interrupt001a$MyThread)732 Thread-4            cond. waiting&lt;br/&gt;
reply[12]: Group InnocuousThreadGroup:&lt;br/&gt;
reply[13]:   (jdk.internal.misc.InnocuousThread)526                     Common-Cleaner      cond. waiting&lt;br/&gt;
reply[14]:   (jdk.internal.misc.InnocuousThread)716                     Cleaner-0           cond. waiting&lt;br/&gt;
reply[15]: main[1] &lt;br/&gt;
Sending command: set nsk.jdb.interrupt.interrupt001.interrupt001a.allWorkersAreWaiting=true&lt;br/&gt;
reply[0]:  nsk.jdb.interrupt.interrupt001.interrupt001a.allWorkersAreWaiting=true = true&lt;br/&gt;
reply[1]: main[1] &lt;br/&gt;
Sending command: interrupt 728&lt;br/&gt;
reply[0]: main[1] &lt;br/&gt;
Sending command: interrupt 729&lt;br/&gt;
reply[0]: main[1] &lt;br/&gt;
Sending command: interrupt 730&lt;br/&gt;
reply[0]: main[1] &lt;br/&gt;
Sending command: interrupt 731&lt;br/&gt;
reply[0]: main[1] &lt;br/&gt;
Sending command: interrupt 732&lt;br/&gt;
reply[0]: main[1] &lt;br/&gt;
Sending command: threads &lt;br/&gt;
reply[0]: Group system:&lt;br/&gt;
reply[1]:   (java.lang.ref.Reference$ReferenceHandler)498              Reference Handler   running&lt;br/&gt;
reply[2]:   (java.lang.ref.Finalizer$FinalizerThread)499               Finalizer           cond. waiting&lt;br/&gt;
reply[3]:   (java.lang.Thread)500                                      Signal Dispatcher   running&lt;br/&gt;
reply[4]:   (java.lang.Thread)497                                      Notification Thread running&lt;br/&gt;
reply[5]: Group main:&lt;br/&gt;
reply[6]:   (java.lang.Thread)1                                        main                running (at breakpoint)&lt;br/&gt;
reply[7]:   (nsk.jdb.interrupt.interrupt001.interrupt001a$MyThread)728 Thread-0            cond. waiting&lt;br/&gt;
reply[8]:   (nsk.jdb.interrupt.interrupt001.interrupt001a$MyThread)729 Thread-1            cond. waiting&lt;br/&gt;
reply[9]:   (nsk.jdb.interrupt.interrupt001.interrupt001a$MyThread)730 Thread-2            cond. waiting&lt;br/&gt;
reply[10]:   (nsk.jdb.interrupt.interrupt001.interrupt001a$MyThread)731 Thread-3            cond. waiting&lt;br/&gt;
reply[11]:   (nsk.jdb.interrupt.interrupt001.interrupt001a$MyThread)732 Thread-4            cond. waiting&lt;br/&gt;
reply[12]: Group InnocuousThreadGroup:&lt;br/&gt;
reply[13]:   (jdk.internal.misc.InnocuousThread)526                     Common-Cleaner      cond. waiting&lt;br/&gt;
reply[14]:   (jdk.internal.misc.InnocuousThread)716                     Cleaner-0           cond. waiting&lt;br/&gt;
reply[15]: main[1] &lt;br/&gt;
Sending command: cont&lt;br/&gt;
receiveReply FAILED due to &amp;quot;nsk.share.Failure: Prompt is not received during 300200 milliseconds.&amp;quot;.&lt;br/&gt;
Pending reply output follows:&lt;br/&gt;
reply[0]: &amp;gt; &lt;br/&gt;
reply[1]: Breakpoint hit: &amp;quot;thread=main&amp;quot;, nsk.jdb.interrupt.interrupt001.interrupt001a.breakHere(), line=73 bci=0&lt;br/&gt;
reply[2]: 73        static void breakHere () {}&lt;br/&gt;
reply[3]: &lt;br/&gt;
reply[4]: main[1] &lt;br/&gt;
# ERROR: Caught unexpected exception while executing the test: nsk.share.Failure: Prompt is not received during 300200 milliseconds.&lt;br/&gt;
The following stacktrace is for failure analysis.&lt;br/&gt;
nsk.share.TestFailure: Caught unexpected exception while executing the test: nsk.share.Failure: Prompt is not received during 300200 milliseconds.&lt;br/&gt;
	at nsk.share.Log.logExceptionForFailureAnalysis(Log.java:431)&lt;br/&gt;
	at nsk.share.Log.complain(Log.java:402)&lt;br/&gt;
	at nsk.share.jdb.JdbTest.failure(JdbTest.java:74)&lt;br/&gt;
	at nsk.share.jdb.JdbTest.runTest(JdbTest.java:158)&lt;br/&gt;
	at nsk.jdb.interrupt.interrupt001.interrupt001.run(interrupt001.java:82)&lt;br/&gt;
	at nsk.jdb.interrupt.interrupt001.interrupt001.main(interrupt001.java:76)&lt;br/&gt;
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)&lt;br/&gt;
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)&lt;br/&gt;
	at com.sun.javatest.regtest.agent.MainWrapper$MainTask.run(MainWrapper.java:138)&lt;br/&gt;
	at java.base/java.lang.Thread.run(Thread.java:1583)&lt;br/&gt;
nsk.share.Failure: Prompt is not received during 300200 milliseconds.&lt;br/&gt;
	at nsk.share.jdb.Jdb.waitForPrompt(Jdb.java:503)&lt;br/&gt;
	at nsk.share.jdb.Jdb.receiveReply(Jdb.java:404)&lt;br/&gt;
	at nsk.share.jdb.Jdb.receiveReplyFor(Jdb.java:351)&lt;br/&gt;
	at nsk.share.jdb.Jdb.receiveReplyFor(Jdb.java:333)&lt;br/&gt;
	at nsk.jdb.interrupt.interrupt001.interrupt001.runCases(interrupt001.java:128)&lt;br/&gt;
	at nsk.share.jdb.JdbTest.runTest(JdbTest.java:149)&lt;br/&gt;
	at nsk.jdb.interrupt.interrupt001.interrupt001.run(interrupt001.java:82)&lt;br/&gt;
	at nsk.jdb.interrupt.interrupt001.interrupt001.main(interrupt001.java:76)&lt;br/&gt;
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)&lt;br/&gt;
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)&lt;br/&gt;
	at com.sun.javatest.regtest.agent.MainWrapper$MainTask.run(MainWrapper.java:138)&lt;br/&gt;
	at java.base/java.lang.Thread.run(Thread.java:1583)&lt;br/&gt;
Waiting for jdb exits&lt;br/&gt;
# ERROR: jdb did not exit after timeout.&lt;br/&gt;
Sending quit command to jdb.&lt;br/&gt;
Sending command: quit&lt;br/&gt;
# ERROR: TEST FAILED&lt;br/&gt;
The following stacktrace is for failure analysis.&lt;br/&gt;
nsk.share.TestFailure: TEST FAILED&lt;br/&gt;
	at nsk.share.Log.logExceptionForFailureAnalysis(Log.java:431)&lt;br/&gt;
	at nsk.share.Log.complain(Log.java:402)&lt;br/&gt;
	at nsk.share.jdb.JdbTest.runTest(JdbTest.java:225)&lt;br/&gt;
	at nsk.jdb.interrupt.interrupt001.interrupt001.run(interrupt001.java:82)&lt;br/&gt;
	at nsk.jdb.interrupt.interrupt001.interrupt001.main(interrupt001.java:76)&lt;br/&gt;
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)&lt;br/&gt;
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)&lt;br/&gt;
	at com.sun.javatest.regtest.agent.MainWrapper$MainTask.run(MainWrapper.java:138)&lt;br/&gt;
	at java.base/java.lang.Thread.run(Thread.java:1583)&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
#&amp;gt;  &lt;br/&gt;
#&amp;gt;  SUMMARY: Following errors occured&lt;br/&gt;
#&amp;gt;      during test execution:&lt;br/&gt;
#&amp;gt;  &lt;br/&gt;
# ERROR: Caught unexpected exception while executing the test: nsk.share.Failure: Prompt is not received during 300200 milliseconds.&lt;br/&gt;
# ERROR: jdb did not exit after timeout.&lt;br/&gt;
# ERROR: TEST FAILED&lt;br/&gt;
----------System.err:(0/0)----------&lt;br/&gt;
----------rerun:(43/10266)*----------</description>
                <environment></environment>
        <key id="5103786">JDK-8310551</key>
            <summary>vmTestbase/nsk/jdb/interrupt/interrupt001/interrupt001.java timed out due to missing prompt</summary>
                <type id="1" iconUrl="https://bugs.openjdk.org/secure/viewavatar?size=xsmall&amp;avatarId=14703&amp;avatarType=issuetype">Bug</type>
                                            <priority id="4" iconUrl="https://bugs.openjdk.org/images/jbsImages/p4.png">P4</priority>
                        <status id="5" iconUrl="https://bugs.openjdk.org/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="success"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="cjplummer">Chris Plummer</assignee>
                                    <reporter username="dcubed">Daniel Daugherty</reporter>
                        <labels>
                            <label>hgupdate-sync</label>
                            <label>intermittent</label>
                            <label>jdk11u-fix-request</label>
                            <label>jdk11u-fix-yes</label>
                            <label>jdk17u-fix-request</label>
                            <label>jdk17u-fix-yes</label>
                            <label>noreg-self</label>
                            <label>problemlist</label>
                            <label>tier4</label>
                            <label>tier6</label>
                            <label>tier8</label>
                    </labels>
                <created>Wed, 21 Jun 2023 07:32:24 -0700</created>
                <updated>Mon, 8 Jan 2024 00:25:11 -0800</updated>
                            <resolved>Fri, 14 Jul 2023 11:41:33 -0700</resolved>
                                    <version>21</version>
                    <version>22</version>
                                    <fixVersion>22</fixVersion>
                                    <component>core-svc</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>6</watches>
                                                                                                                                                            <comments>
                            <comment id="14637577" author="JIRAUSER20917" created="Thu, 4 Jan 2024 18:14:43 -0800"  >Fix request [11u]&lt;br/&gt;
&lt;br/&gt;
I backport this for parity with 11.0.23-oracle.&lt;br/&gt;
No risk, only a test change.&lt;br/&gt;
Clean backport(except the problemList).&lt;br/&gt;
SAP nightly testing passed.</comment>
                            <comment id="14637296" author="roboduke" created="Wed, 3 Jan 2024 21:45:53 -0800"  >A pull request was submitted for review.&lt;br/&gt;
URL: &lt;a href=&quot;https://git.openjdk.org/jdk11u-dev/pull/2431&quot;&gt;https://git.openjdk.org/jdk11u-dev/pull/2431&lt;/a&gt;&lt;br/&gt;
Date: 2024-01-04 05:40:51 +0000</comment>
                            <comment id="14603004" author="roboduke" created="Wed, 9 Aug 2023 08:49:10 -0700"  >A pull request was submitted for review.&lt;br/&gt;
URL: &lt;a href=&quot;https://git.openjdk.org/jdk17u-dev/pull/1654&quot;&gt;https://git.openjdk.org/jdk17u-dev/pull/1654&lt;/a&gt;&lt;br/&gt;
Date: 2023-08-09 15:40:26 +0000</comment>
                            <comment id="14603002" author="mdoerr" created="Wed, 9 Aug 2023 08:41:18 -0700"  >Fix Request (17u):&lt;br/&gt;
Should get backported for parity with 17.0.9-oracle. Applies cleanly except removal from ProblemList. (Not problem listed in 17u). Test has passed.</comment>
                            <comment id="14596680" author="roboduke" created="Mon, 17 Jul 2023 11:34:28 -0700"  >A pull request was submitted for review.&lt;br/&gt;
URL: &lt;a href=&quot;https://git.openjdk.org/jdk21/pull/133&quot;&gt;https://git.openjdk.org/jdk21/pull/133&lt;/a&gt;&lt;br/&gt;
Date: 2023-07-17 18:29:08 +0000</comment>
                            <comment id="14596341" author="dukebot" created="Fri, 14 Jul 2023 11:41:32 -0700"  >Changeset: c84866ac&lt;br/&gt;
Author:    Chris Plummer &amp;lt;&lt;a href=&apos;mailto:cjplummer@openjdk.org&apos;&gt;cjplummer@openjdk.org&lt;/a&gt;&amp;gt;&lt;br/&gt;
Date:      2023-07-14 18:39:34 +0000&lt;br/&gt;
URL:       &lt;a href=&quot;https://git.openjdk.org/jdk/commit/c84866ac0dcda487fe2abc2a8841f237df0a395b&quot;&gt;https://git.openjdk.org/jdk/commit/c84866ac0dcda487fe2abc2a8841f237df0a395b&lt;/a&gt;&lt;br/&gt;
</comment>
                            <comment id="14594867" author="roboduke" created="Mon, 10 Jul 2023 15:43:03 -0700"  >A pull request was submitted for review.&lt;br/&gt;
URL: &lt;a href=&quot;https://git.openjdk.org/jdk/pull/14817&quot;&gt;https://git.openjdk.org/jdk/pull/14817&lt;/a&gt;&lt;br/&gt;
Date: 2023-07-10 20:17:21 +0000</comment>
                            <comment id="14594838" author="cjplummer" created="Mon, 10 Jul 2023 12:29:28 -0700"  >I spent a lot of time debugging this. Without going into all the details of everything I tried, I&amp;#39;ll just point out that it appeared that the expected prompt output was somehow being blocked from appearing while executing in the waitForPrompt() loop, only to then appear once the loop was exited. I couldn&amp;#39;t figure out why, so I eventually decided to track down which build this first started happening in. I had to go back 3 weeks before the first sighting of this bug before I found builds that did not reproduce it. I&amp;#39;m not sure why it didn&amp;#39;t reproduce during this 3 period given how frequently it reproduced after that point, but the builds during this period definitely all reproduce it if you run a couple hundred time.&lt;br/&gt;
&lt;br/&gt;
The root cause is &lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8308232&quot; title=&quot;nsk/jdb tests don&amp;#39;t pass -verbose flag to the debuggee&quot; class=&quot;issue-link&quot; data-issue-key=&quot;JDK-8308232&quot;&gt;&lt;strike&gt;JDK-8308232&lt;/strike&gt;&lt;/a&gt;. It added code to make the test launch jdb in a way that would pass a couple of extra arguments to the debugeee:&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;cmdline += &amp;quot; -waittime &amp;quot; + argumentHandler.getWaitTime();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if (argumentHandler.verbose()) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;cmdline += &amp;quot; -verbose&amp;quot;;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&lt;br/&gt;
Since the test was not run with -verbose, it had to be the addition of -waittime that caused the issue. Seemed kind of odd, but once I tracked down why it made sense.&lt;br/&gt;
&lt;br/&gt;
The default waittime is 2 minutes:&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public int getWaitTime() {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;String val = options.getProperty(&amp;quot;waittime&amp;quot;, &amp;quot;2&amp;quot;);&lt;br/&gt;
&lt;br/&gt;
Pretty much all tests are run with a specified waittime of 5 minutes, which you&amp;#39;ll find in the @run arguments the test&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;*      -waittime=5&lt;br/&gt;
&lt;br/&gt;
This previously only affected the test, not the debuggee, but with &lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8308232&quot; title=&quot;nsk/jdb tests don&amp;#39;t pass -verbose flag to the debuggee&quot; class=&quot;issue-link&quot; data-issue-key=&quot;JDK-8308232&quot;&gt;&lt;strike&gt;JDK-8308232&lt;/strike&gt;&lt;/a&gt;, both test and debuggee now have the same waittime.&lt;br/&gt;
&lt;br/&gt;
On the test side waitForPrompt() uses waittime to decide how long it should wait for a the prompt to appear:&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;long delta = 200; // time in milliseconds to wait at every iteration.&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;long total = 0;    // total time has waited.&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;long max = getLauncher().getJdbArgumentHandler().getWaitTime() * 60 * 1000;  // maximum time to wait.&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;while ((total += delta) &amp;lt;= max) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;...&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;found = findPrompt(stdoutBuffer, true, startPos);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;...&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&lt;br/&gt;
On the debuggee side for this test we have:&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;long waitTime = argumentHandler.getWaitTime() * 60 * 1000;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;long startTime = System.currentTimeMillis();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;while (notInterrupted.get() &amp;gt; 0 &amp;amp;&amp;amp; System.currentTimeMillis() - startTime &amp;lt;= waitTime) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;synchronized (waitnotify) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;try {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;waitnotify.wait(waitTime);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;} catch (InterruptedException e) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;log.display(&amp;quot;Main thread was interrupted while waiting&amp;quot;);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;...&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;breakHere(); // a break to check if MyThreads were interrupted&lt;br/&gt;
&lt;br/&gt;
This loop is also using waittime before it times out, which is ok. It is suppose to loop until all test threads have been interrupted (the main thread is not expected to be interrupted), and this should happen right away. However, notice it also uses waittime in waitnotify.wait(waitTime). This wait() call is expected to be short because if we&amp;#39;ve entered the loop, then that means not all threads have been interrupted yet, and we should get a notify when the the next thread is interrupted. However, it&amp;#39;s possible that by the time we get to the wait() call, all threads have already been interrupted, and there will be no notify. This means the wait() call ends up essentially sleeping for the loop&amp;#39;s entire waittime before timing out. Other than wasting time, this isn&amp;#39;t necessarily an issue. Given that the waittime used to be 2 minutes and the test was willing to wait 5 minutes for the prompt, it all still worked. However...&lt;br/&gt;
&lt;br/&gt;
The waittime for the debuggee used is 5 minutes, same as the waittime the test uses to control the waitForPrompt loop. This means if we ever enter the loop, we are going to wait for 5 minutes. If all threads are already interrupted before the wait(), it means the debuggee will wait 5 minutes before proceeding to the breakpoint line, which generates the prompt that waitForPrompt is looking for. So there is a race here. The debuggee is going to produce the prompt after 5 minutes and the waitForPrompt loop is going to wait up to 5 minutes for it to appear. Normally it appears in time because normally the threads have all been interrupted before entering the loop, so we never get to the wait() call, but sometimes this is not the case, and the wait() call is resulting in the prompt not appearing in time (just barely not in time).&lt;br/&gt;
&lt;br/&gt;
So this explains why it always appeared that the expected output was being blocked while in the waitForPrompt() loop, but was unblocked (and ready) once the loop exited. There was nothing about the waitForPrompt() loop that was preventing the output. The prevention was in the 5 minute delay being done by the debuggee.&lt;br/&gt;
&lt;br/&gt;
This appears to be a test bug. I think the debuggee should be waiting for some small increment, like 200ms, and not base the amount of time it waits on waittime.&lt;br/&gt;
</comment>
                            <comment id="14591110" author="cjplummer" created="Wed, 21 Jun 2023 10:47:15 -0700"  >The test executes the following 3 commands:&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;reply = jdb.receiveReplyFor(JdbCommand.threads);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;reply = jdb.receiveReplyFor(JdbCommand.cont, true);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;reply = jdb.receiveReplyFor(JdbCommand.eval + DEBUGGEE_RESULT);&lt;br/&gt;
&lt;br/&gt;
You can see from the output that it has executed the first two, but not the 3rd, so it is still waiting for the reply from the &amp;quot;cont&amp;quot; command. From the output it appears that the reply was received, so I&amp;#39;m not sure why it is still waiting:&lt;br/&gt;
&lt;br/&gt;
Sending command: cont&lt;br/&gt;
receiveReply FAILED due to &amp;quot;nsk.share.Failure: Prompt is not received during 300200 milliseconds.&amp;quot;.&lt;br/&gt;
Pending reply output follows:&lt;br/&gt;
reply[0]: &amp;gt; &lt;br/&gt;
reply[1]: Breakpoint hit: &amp;quot;thread=main&amp;quot;, nsk.jdb.interrupt.interrupt001.interrupt001a.breakHere(), line=73 bci=0&lt;br/&gt;
reply[2]: 73        static void breakHere () {}&lt;br/&gt;
reply[3]: &lt;br/&gt;
reply[4]: main[1] &lt;br/&gt;
&lt;br/&gt;
This is exactly the output we expect for the &amp;quot;cont&amp;quot; command, and receiveReplyFor() should be seeing the &amp;quot;main[1]&amp;quot; prompt in the output and returning. I&amp;#39;m not sure why it&amp;#39;s not.&lt;br/&gt;
&lt;br/&gt;
Nothing has changed in this area recently. I&amp;#39;ll keep an eye out for more failures. If we see them, I&amp;#39;ll instrument receiveReplyFor() to provide some additional details that may give a clue as to why it is not seeing the &amp;quot;main[1]&amp;quot; prompt.</comment>
                            <comment id="14591098" author="cjplummer" created="Wed, 21 Jun 2023 10:18:33 -0700"  >No changes to this test in the past few years. I don&amp;#39;t there have been any jdb or JDI changes in the past few weeks.</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10200">
                    <name>Backport</name>
                                            <outwardlinks description="backported by">
                                        <issuelink>
            <issuekey id="5105879">JDK-8312413</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="5106108">JDK-8312614</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="5106462">JDK-8312956</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="5106468">JDK-8312962</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="5106796">JDK-8313255</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="5107904">JDK-8314178</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="5118223">JDK-8323109</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                            <issuelinktype id="10003">
                    <name>Relates</name>
                                            <outwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="5101076">JDK-8308232</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                    </issuelinks>
                <attachments>
                    </attachments>
                <subtasks>
                                              <subtask id="5104494">JDK-8311193</subtask>
                                    </subtasks>
                <customfields>
                                                <customfield id="customfield_10000" key="com.atlassian.jira.plugin.system.customfieldtypes:multiselect">
                        <customfieldname>CPU</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="19000"><![CDATA[x86_64]]></customfieldvalue>
    <customfieldvalue key="19300"><![CDATA[aarch64]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_11700" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_10600" key="com.oracle.jira.javabugsystem-jira-plugin:jbs-fixedBackportedCustomfield">
                        <customfieldname>Fixed</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                            <customfield id="customfield_10005" key="com.atlassian.jira.plugin.system.customfieldtypes:multiselect">
                        <customfieldname>OS</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="17023"><![CDATA[linux]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                            <customfield id="customfield_11100" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i320aj:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_11004" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10006" key="com.atlassian.jira.plugin.system.customfieldtypes:select">
                        <customfieldname>Resolved In Build</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="17335"><![CDATA[b07]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10008" key="com.oracle.jira.jira-subcomponent-plugin:oracle-subComponentField">
                        <customfieldname>Subcomponent</customfieldname>
                        <customfieldvalues>
                             <customfieldvalue key="370"><![CDATA[debugger]]></customfieldvalue> 
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_10601" key="com.oracle.jira.javabugsystem-jira-plugin:jbs-targetBackportedCustomfield">
                        <customfieldname>Targeted</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    </customfields>
    </item>
</channel>
</rss>