<!-- 
RSS generated by JIRA (9.12.27#9120027-sha1:edc4490121e366e9e7bd2213d532dbe7e028fc5d) at Tue Sep 30 12:47:34 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>Java Bug System</title>
    <link>https://bugs.openjdk.org</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-us</language>    <build-info>
        <version>9.12.27</version>
        <build-number>9120027</build-number>
        <build-date>02-09-2025</build-date>
    </build-info>


<item>
            <title>[JDK-8325754] Dead AbstractQueuedSynchronizer$ConditionNodes survive minor garbage collections</title>
                <link>https://bugs.openjdk.org/browse/JDK-8325754</link>
                <project id="10100" key="JDK">JDK</project>
                    <description>A DESCRIPTION OF THE PROBLEM :&lt;br/&gt;
On executing many asynchronous tasks in a fixed thread pool, survivor spaces grow unexpectedly, and minor collection times increase though the application doesn&#8217;t generate much garbage.&lt;br/&gt;
&lt;br/&gt;
This being the case, many java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionNode&lt;br/&gt;
instances can be found on the heap. In fact, the whole heap (rank 1 as shown in jmap) is filled up with ConditionNode instances after a while.&lt;br/&gt;
&lt;br/&gt;
G1 seems to be able to collect &#8220;dead&#8221; ConditionNode instances during minor collections only if no formerly alive ConditionNode instances were promoted to the old generation and died there, which often cannot be avoided since e.g. on application startup many objects are promoted to the old generation after a few collections.&lt;br/&gt;
&lt;br/&gt;
Proposed solution:&lt;br/&gt;
Similar to &lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-6805775,&quot;&gt;https://bugs.openjdk.org/browse/JDK-6805775,&lt;/a&gt; &amp;#39;ConditionNode&amp;#39; instances should unlink themselves (i.e. their &#8216;nextWaiter&#8217; reference) before they are transferred to the sync queue.&lt;br/&gt;
&lt;br/&gt;
Example code change OpenJDK 17 (&lt;a href=&quot;https://github.com/openjdk/jdk/blob/jdk-17%2B35/src/java.base/share/classes/java/util/concurrent/locks/AbstractQueuedSynchronizer.java):&quot;&gt;https://github.com/openjdk/jdk/blob/jdk-17%2B35/src/java.base/share/classes/java/util/concurrent/locks/AbstractQueuedSynchronizer.java):&lt;/a&gt;&lt;br/&gt;
&lt;br/&gt;
@@ -1431,40 +1431,41 @@ public abstract class AbstractQueuedSynchronizer&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public class ConditionObject implements Condition, java.io.Serializable {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// ...&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;private void doSignal(ConditionNode first, boolean all) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;while (first != null) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ConditionNode next = first.nextWaiter;&lt;br/&gt;
+                first.nextWaiter = null;  // GC-friendly&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if ((firstWaiter = next) == null)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;lastWaiter = null;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if ((first.getAndUnsetStatus(COND) &amp;amp; COND) != 0) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;enqueue(first);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// ...&lt;br/&gt;
&lt;br/&gt;
This applies not only to &amp;#39;AbstractQueuedSynchronizer&amp;#39;, but also to &amp;#39;AbstractQueuedLongSynchronizer&amp;#39;.&lt;br/&gt;
&lt;br/&gt;
STEPS TO FOLLOW TO REPRODUCE THE PROBLEM :&lt;br/&gt;
Compile and run attached &#8220;G1LoiteringConditionNodes&#8221; class, e.g. under Linux with OpenJDK 17.0.10:&lt;br/&gt;
&lt;br/&gt;
java -Xms2048m -Xmx2048m -XX:+UseG1GC -XX:+UnlockExperimentalVMOptions -XX:G1MaxNewSizePercent=20 -Xlog:gc*,gc+age*=trace -cp . G1LoiteringConditionNodes&lt;br/&gt;
&lt;br/&gt;
EXPECTED VERSUS ACTUAL BEHAVIOR :&lt;br/&gt;
EXPECTED -&lt;br/&gt;
Survivor spaces and minor collection times shall not increase.&lt;br/&gt;
ACTUAL -&lt;br/&gt;
During the first two minutes of the test case, everything is fine, but after a promotion to the old generation (which is triggered after 2 minutes for demo purposes), survivors grow and minor pause time increase, i.e. they are more than doubled.&lt;br/&gt;
&lt;br/&gt;
---------- BEGIN SOURCE ----------&lt;br/&gt;
import java.util.Arrays;&lt;br/&gt;
import java.util.concurrent.Callable;&lt;br/&gt;
import java.util.concurrent.ExecutorService;&lt;br/&gt;
import java.util.concurrent.Executors;&lt;br/&gt;
import java.util.concurrent.ScheduledExecutorService;&lt;br/&gt;
import java.util.concurrent.TimeUnit;&lt;br/&gt;
&lt;br/&gt;
/**&lt;br/&gt;
&amp;nbsp;* Asynchronously execute tasks in a fixed thread pool, in order to demonstrate that&lt;br/&gt;
&amp;nbsp;* {@code java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionNode} instances are properly&lt;br/&gt;
&amp;nbsp;* collected during minor collections, but only if no instances were promoted to the old generation.&lt;br/&gt;
&amp;nbsp;* &amp;lt;p&amp;gt;&lt;br/&gt;
&amp;nbsp;* If such instances were promoted to old generation (here after 2 minutes),&lt;br/&gt;
&amp;nbsp;* ConditionNode instances are not collected during minor collections by G1 in OpenJDK 17.0.9+9 any more,&lt;br/&gt;
&amp;nbsp;* but promoted to survivor spaces and finally to the old generation, filling it up until a&lt;br/&gt;
&amp;nbsp;* mixed or full collection kicks in.&lt;br/&gt;
&amp;nbsp;* &amp;lt;p&amp;gt;&lt;br/&gt;
&amp;nbsp;* This increase minor collection pauses from 3ms to 10ms, and leads to earlier mixed collections later on.&lt;br/&gt;
&amp;nbsp;*&lt;br/&gt;
&amp;nbsp;* Recommended VM-options: -Xms2048m -Xmx2048m -XX:+UseG1GC -XX:+UnlockExperimentalVMOptions -XX:G1MaxNewSizePercent=20 -Xlog:gc*,gc+age*=trace&lt;br/&gt;
&amp;nbsp;*/&lt;br/&gt;
public class G1LoiteringConditionNodes {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;private static final int NUM_OF_PRODUCERS = 16;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;private static final int NUM_OF_WORKERS = 32;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;private static final long TXNS_PER_SECOND = 1600;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;private static final long WORK_MILLISECONDS = 10;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;private static final long GC_AFTER_SECONDS = 120;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public static void main(final String[] args) {&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// worker thread pool&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;final ExecutorService workers = Executors.newFixedThreadPool(NUM_OF_WORKERS);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;final Callable&amp;lt;String&amp;gt; work = () -&amp;gt; {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;try {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// simulate work (just sleep for a while)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;TimeUnit.MILLISECONDS.sleep(WORK_MILLISECONDS);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;} catch (final InterruptedException e) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Thread.currentThread().interrupt();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// generate some garbage&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return Arrays.toString(new byte[4096]) + System.currentTimeMillis();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;};&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// produce tasks to be scheduled in the worker pool&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;final ScheduledExecutorService producer = Executors.newScheduledThreadPool(NUM_OF_PRODUCERS);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;producer.scheduleWithFixedDelay(&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;() -&amp;gt; workers.submit(work),&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;0, TimeUnit.SECONDS.toNanos(1L) / TXNS_PER_SECOND,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;TimeUnit.NANOSECONDS);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// trigger a full garbage collection, in order to promote ConditionNode objects to old generation for test purposes&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// in real live application, ConditionNode objects are promoted to old gen. on JVM startup&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// if many objects are created, more than can be hold in survivors&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;producer.schedule(System::gc, GC_AFTER_SECONDS, TimeUnit.SECONDS);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
}&lt;br/&gt;
---------- END SOURCE ----------&lt;br/&gt;
&lt;br/&gt;
FREQUENCY : often&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
</description>
                <environment></environment>
        <key id="5121138">JDK-8325754</key>
            <summary>Dead AbstractQueuedSynchronizer$ConditionNodes survive minor garbage collections</summary>
                <type id="1" iconUrl="https://bugs.openjdk.org/secure/viewavatar?size=xsmall&amp;avatarId=14703&amp;avatarType=issuetype">Bug</type>
                                            <priority id="4" iconUrl="https://bugs.openjdk.org/images/jbsImages/p4.png">P4</priority>
                        <status id="6" iconUrl="https://bugs.openjdk.org/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="success"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="vklang">Viktor Klang</assignee>
                                    <reporter username="webbuggrp">Webbug Group</reporter>
                        <labels>
                            <label>amazon-interest</label>
                            <label>dcscg</label>
                            <label>jdk17u-fix-request</label>
                            <label>jdk17u-fix-yes</label>
                            <label>jdk21u-fix-request</label>
                            <label>jdk21u-fix-yes</label>
                            <label>jdk22u-fix-request</label>
                            <label>reproducer-yes</label>
                            <label>webbug</label>
                    </labels>
                <created>Sat, 10 Feb 2024 07:24:08 -0800</created>
                <updated>Wed, 21 Aug 2024 04:09:13 -0700</updated>
                            <resolved>Tue, 27 Feb 2024 02:41:57 -0800</resolved>
                                    <version>17</version>
                    <version>21</version>
                    <version>22</version>
                    <version>23</version>
                                    <fixVersion>23</fixVersion>
                                    <component>core-libs</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>8</watches>
                                                                                                                <comments>
                            <comment id="14682676" author="roboduke" created="Tue, 18 Jun 2024 09:21:15 -0700"  >A pull request was submitted for review.&lt;br/&gt;
Branch: master&lt;br/&gt;
URL: &lt;a href=&quot;https://git.openjdk.org/jdk22u/pull/249&quot;&gt;https://git.openjdk.org/jdk22u/pull/249&lt;/a&gt;&lt;br/&gt;
Date: 2024-06-17 22:15:59 +0000</comment>
                            <comment id="14682671" author="roboduke" created="Tue, 18 Jun 2024 09:17:11 -0700"  >[jdk22u-fix-request] Approval Request from Neethu Prasad&lt;br/&gt;
Backport to unlink &amp;#39;ConditionNode&amp;#39; before they are transferred to the sync queue; applies cleanly; All tests passed; Risk is low: there are no follow-up bug since mainline integration 4 months ago. Also, similar change was made to LinkedBlockingQueue more than 10 years ago as part of [&lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-6805775&quot; title=&quot;LinkedBlockingQueue Nodes should unlink themselves before becoming garbage&quot; class=&quot;issue-link&quot; data-issue-key=&quot;JDK-6805775&quot;&gt;&lt;strike&gt;JDK-6805775&lt;/strike&gt;&lt;/a&gt;](&lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-6805775&quot;&gt;https://bugs.openjdk.org/browse/JDK-6805775&lt;/a&gt;)</comment>
                            <comment id="14682644" author="roboduke" created="Tue, 18 Jun 2024 08:08:42 -0700"  >[jdk17u-fix-request] Approval Request from Neethu Prasad&lt;br/&gt;
Backport to unlink &amp;#39;ConditionNode&amp;#39; before they are transferred to the sync queue; applies cleanly; All tests passed; Risk is low: there are no follow-up bug since mainline integration 4 months ago. Also, similar change was made to LinkedBlockingQueue more than 10 years ago to LinkedBlockingQueue as part of [&lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-6805775&quot; title=&quot;LinkedBlockingQueue Nodes should unlink themselves before becoming garbage&quot; class=&quot;issue-link&quot; data-issue-key=&quot;JDK-6805775&quot;&gt;&lt;strike&gt;JDK-6805775&lt;/strike&gt;&lt;/a&gt;](&lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-6805775&quot;&gt;https://bugs.openjdk.org/browse/JDK-6805775&lt;/a&gt;)</comment>
                            <comment id="14682643" author="roboduke" created="Tue, 18 Jun 2024 08:07:35 -0700"  >[jdk21u-fix-request] Approval Request from Neethu Prasad&lt;br/&gt;
Backport to unlink &amp;#39;ConditionNode&amp;#39; before they are transferred to the sync queue; applies cleanly; All tests passed; Risk is low: there are no follow-up bug since mainline integration 4 months ago. Also, similar change was made to LinkedBlockingQueue more than 10 years ago to LinkedBlockingQueue as part of [&lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-6805775&quot; title=&quot;LinkedBlockingQueue Nodes should unlink themselves before becoming garbage&quot; class=&quot;issue-link&quot; data-issue-key=&quot;JDK-6805775&quot;&gt;&lt;strike&gt;JDK-6805775&lt;/strike&gt;&lt;/a&gt;](&lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-6805775&quot;&gt;https://bugs.openjdk.org/browse/JDK-6805775&lt;/a&gt;)</comment>
                            <comment id="14682632" author="roboduke" created="Tue, 18 Jun 2024 07:04:40 -0700"  >A pull request was submitted for review.&lt;br/&gt;
Branch: master&lt;br/&gt;
URL: &lt;a href=&quot;https://git.openjdk.org/jdk17u-dev/pull/2599&quot;&gt;https://git.openjdk.org/jdk17u-dev/pull/2599&lt;/a&gt;&lt;br/&gt;
Date: 2024-06-17 22:14:40 +0000</comment>
                            <comment id="14682611" author="roboduke" created="Tue, 18 Jun 2024 06:16:19 -0700"  >A pull request was submitted for review.&lt;br/&gt;
URL: &lt;a href=&quot;https://git.openjdk.org/jdk21u-dev/pull/735&quot;&gt;https://git.openjdk.org/jdk21u-dev/pull/735&lt;/a&gt;&lt;br/&gt;
Date: 2024-06-17 22:12:49 +0000</comment>
                            <comment id="14653427" author="shade" created="Thu, 29 Feb 2024 01:15:21 -0800"  >We have seen a similar behavior in some production environments. Let&amp;#39;s see if this comes with any ill effects, and then maybe we backport the fix.</comment>
                            <comment id="14652723" author="dukebot" created="Tue, 27 Feb 2024 02:41:56 -0800"  >Changeset: 60cbf292&lt;br/&gt;
Author:    Viktor Klang &amp;lt;&lt;a href=&apos;mailto:vklang@openjdk.org&apos;&gt;vklang@openjdk.org&lt;/a&gt;&amp;gt;&lt;br/&gt;
Date:      2024-02-27 10:38:36 +0000&lt;br/&gt;
URL:       &lt;a href=&quot;https://git.openjdk.org/jdk/commit/60cbf2925024b1c2253256688ae41741fff0a860&quot;&gt;https://git.openjdk.org/jdk/commit/60cbf2925024b1c2253256688ae41741fff0a860&lt;/a&gt;&lt;br/&gt;
</comment>
                            <comment id="14651328" author="roboduke" created="Wed, 21 Feb 2024 07:06:06 -0800"  >A pull request was submitted for review.&lt;br/&gt;
URL: &lt;a href=&quot;https://git.openjdk.org/jdk/pull/17950&quot;&gt;https://git.openjdk.org/jdk/pull/17950&lt;/a&gt;&lt;br/&gt;
Date: 2024-02-21 15:01:15 +0000</comment>
                            <comment id="14649291" author="JIRAUSER20508" created="Wed, 14 Feb 2024 07:01:16 -0800"  >After discussing with [~dl] we concluded that this could be addressed but the proposed solution may not be the best possible option, so some further explorations are required.</comment>
                            <comment id="14649092" author="jpai" created="Tue, 13 Feb 2024 22:44:30 -0800"  >The mail discussion about this on core-libs-dev &lt;a href=&quot;https://mail.openjdk.org/pipermail/core-libs-dev/2024-February/119078.html&quot;&gt;https://mail.openjdk.org/pipermail/core-libs-dev/2024-February/119078.html&lt;/a&gt;&lt;br/&gt;
</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10200">
                    <name>Backport</name>
                                            <outwardlinks description="backported by">
                                        <issuelink>
            <issuekey id="5132494">JDK-8334825</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="5134019">JDK-8336173</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="5134123">JDK-8336269</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                    </issuelinks>
                <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_10000" key="com.atlassian.jira.plugin.system.customfieldtypes:multiselect">
                        <customfieldname>CPU</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="17008"><![CDATA[generic]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_11700" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_10600" key="com.oracle.jira.javabugsystem-jira-plugin:jbs-fixedBackportedCustomfield">
                        <customfieldname>Fixed</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                            <customfield id="customfield_10005" key="com.atlassian.jira.plugin.system.customfieldtypes:multiselect">
                        <customfieldname>OS</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="17010"><![CDATA[generic]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                            <customfield id="customfield_11100" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i34xuz:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_11004" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10006" key="com.atlassian.jira.plugin.system.customfieldtypes:select">
                        <customfieldname>Resolved In Build</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="17349"><![CDATA[b12]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10008" key="com.oracle.jira.jira-subcomponent-plugin:oracle-subComponentField">
                        <customfieldname>Subcomponent</customfieldname>
                        <customfieldvalues>
                             <customfieldvalue key="215"><![CDATA[java.util.concurrent]]></customfieldvalue> 
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_10601" key="com.oracle.jira.javabugsystem-jira-plugin:jbs-targetBackportedCustomfield">
                        <customfieldname>Targeted</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_10100" key="com.atlassian.jira.plugin.system.customfieldtypes:radiobuttons">
                        <customfieldname>Verification</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="17001"><![CDATA[Not verified]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                </customfields>
    </item>
</channel>
</rss>