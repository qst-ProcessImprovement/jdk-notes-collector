<!-- 
RSS generated by JIRA (9.12.27#9120027-sha1:edc4490121e366e9e7bd2213d532dbe7e028fc5d) at Tue Sep 30 17:28:15 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>Java Bug System</title>
    <link>https://bugs.openjdk.org</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-us</language>    <build-info>
        <version>9.12.27</version>
        <build-number>9120027</build-number>
        <build-date>02-09-2025</build-date>
    </build-info>


<item>
            <title>[JDK-8303624] The java.lang.Thread.FieldHolder can be null for JNI attaching threads</title>
                <link>https://bugs.openjdk.org/browse/JDK-8303624</link>
                <project id="10100" key="JDK">JDK</project>
                    <description>With the introduction of virtual threads (&lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8284161&quot; title=&quot;Implementation of Virtual Threads (Preview)&quot; class=&quot;issue-link&quot; data-issue-key=&quot;JDK-8284161&quot;&gt;&lt;strike&gt;JDK-8284161&lt;/strike&gt;&lt;/a&gt;) a number of fields in java.lang.Thread were moved into a separate data structure, the FieldHolder class, so that only platform threads would have these. Unfortunately the logic in the VM to create the java.lang.Thread instance when attaching a native thread doesn&amp;#39;t account for this properly as it can try to use these fields even if the Thread constructor threw an exception and failed to create the FieldHolder:&lt;br/&gt;
&lt;br/&gt;
void JavaThread::allocate_threadObj(Handle thread_group, const char* thread_name,&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;bool daemon, TRAPS) {&lt;br/&gt;
...&lt;br/&gt;
if (thread_name != nullptr) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Handle name = java_lang_String::create_from_str(thread_name, CHECK);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// Thread gets assigned specified name and null target&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;JavaCalls::call_special(&amp;amp;result,&lt;br/&gt;
...&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;THREAD);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;} else {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;JavaCalls::call_special(&amp;amp;result,&lt;br/&gt;
...&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;THREAD);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&lt;br/&gt;
&amp;lt;= Exception could be pending at this point due to use of THREAD not CHECK&lt;br/&gt;
&amp;nbsp;&amp;nbsp;os::set_priority(this, NormPriority);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;if (daemon) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;java_lang_Thread::set_daemon(thread_oop()); &amp;lt;== Could try to set null FieldHolder here&lt;br/&gt;
&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&lt;br/&gt;
Further, java_lang_Thread::is_daemon() also expects the FieldHolder to be set if you have a non-null Thread oop, but that is not guaranteed.&lt;br/&gt;
&lt;br/&gt;
This problem manifests as a failed assertion in a debug build, when calling set_daemon, as the FieldHolder field is null. Crash reporting then calls is-daemon which fails the same assert and so we get a secondary crash.</description>
                <environment></environment>
        <key id="5095540">JDK-8303624</key>
            <summary>The java.lang.Thread.FieldHolder can be null for JNI attaching threads</summary>
                <type id="1" iconUrl="https://bugs.openjdk.org/secure/viewavatar?size=xsmall&amp;avatarId=14703&amp;avatarType=issuetype">Bug</type>
                                            <priority id="3" iconUrl="https://bugs.openjdk.org/images/jbsImages/p3.png">P3</priority>
                        <status id="5" iconUrl="https://bugs.openjdk.org/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="success"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="dholmes">David Holmes</assignee>
                                    <reporter username="dholmes">David Holmes</reporter>
                        <labels>
                            <label>loom</label>
                            <label>noreg-hard</label>
                    </labels>
                <created>Sun, 5 Mar 2023 17:36:13 -0800</created>
                <updated>Thu, 16 Mar 2023 00:18:38 -0700</updated>
                            <resolved>Thu, 9 Mar 2023 19:10:53 -0800</resolved>
                                    <version>19</version>
                    <version>20</version>
                    <version>21</version>
                                    <fixVersion>21</fixVersion>
                                    <component>hotspot</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>4</watches>
                                                                                                                <comments>
                            <comment id="14565717" author="dukebot" created="Thu, 9 Mar 2023 19:10:51 -0800"  >Changeset: e26cc526&lt;br/&gt;
Author:    David Holmes &amp;lt;&lt;a href=&apos;mailto:dholmes@openjdk.org&apos;&gt;dholmes@openjdk.org&lt;/a&gt;&amp;gt;&lt;br/&gt;
Date:      2023-03-10 03:08:26 +0000&lt;br/&gt;
URL:       &lt;a href=&quot;https://git.openjdk.org/jdk/commit/e26cc526006b16765510e72bd085de069dfae419&quot;&gt;https://git.openjdk.org/jdk/commit/e26cc526006b16765510e72bd085de069dfae419&lt;/a&gt;&lt;br/&gt;
</comment>
                            <comment id="14564878" author="roboduke" created="Mon, 6 Mar 2023 13:59:24 -0800"  >A pull request was submitted for review.&lt;br/&gt;
URL: &lt;a href=&quot;https://git.openjdk.org/jdk/pull/12892&quot;&gt;https://git.openjdk.org/jdk/pull/12892&lt;/a&gt;&lt;br/&gt;
Date: 2023-03-06 21:52:47 +0000</comment>
                            <comment id="14564588" author="dholmes" created="Sun, 5 Mar 2023 23:13:24 -0800"  >Marked as noreg-hard as we would need to be able to attach a thread and force the Thread constructor to throw an exception before initializing the FieldHolder, and then switch to another thread that invoked JVMTI to get access to the attaching thread and then invoke methods in it whilst still attaching. There is no way to do that.</comment>
                            <comment id="14564582" author="dholmes" created="Sun, 5 Mar 2023 21:49:55 -0800"  >See &lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-6404306&quot; title=&quot;IllegalArgumentException:Invalid thread ID occurs in 6.0b76&quot; class=&quot;issue-link&quot; data-issue-key=&quot;JDK-6404306&quot;&gt;&lt;strike&gt;JDK-6404306&lt;/strike&gt;&lt;/a&gt; for the general problem of JNI-attaching threads partial initialization. JVMTI exposes such threads so in theory could call any Thread methods on them. This would even &amp;quot;work&amp;quot; before the introduction of the FieldHolder because we have successfully allocated (but not initialized) the Thread instance and so can set the fields. Now however any &amp;quot;set&amp;quot; operation would have to be a no-op.&lt;br/&gt;
&lt;br/&gt;
EDIT: correction. Prompted by a query from [~alanb] I re-examined the setter methods and none of them can be called on a JNI attaching thread whilst it is partially constructed. Such a thread could have regular Java methods called on it, but they would throw NPE when trying to access the FieldHolder. So it suffices to keep the assertion that holder!=nullptr in the setter methods.</comment>
                            <comment id="14564578" author="dholmes" created="Sun, 5 Mar 2023 21:26:06 -0800"  >Unfortunately there are cases where attaching threads are not ignored. In such cases it is not just that we have to avoid trying to access a null holder field but we also have to return the default values for these un-set holder fields.</comment>
                            <comment id="14564541" author="dholmes" created="Sun, 5 Mar 2023 17:41:12 -0800"  >This potentially impacts access to all these fields:&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;private static class FieldHolder {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;final ThreadGroup group;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;final Runnable task;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;final long stackSize;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;volatile int priority;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;volatile boolean daemon;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;volatile int threadStatus;&lt;br/&gt;
&lt;br/&gt;
fortunately attaching threads are ignored in most cases until the attaching is complete. So it is really on the attach code itself, and crash reporting that needs to be resilient to this problem.</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10003">
                    <name>Relates</name>
                                            <outwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="4271726">JDK-6404306</issuekey>
        </issuelink>
                            </outwardlinks>
                                                                <inwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="5095434">JDK-8303549</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="5071507">JDK-8284161</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_11700" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_10600" key="com.oracle.jira.javabugsystem-jira-plugin:jbs-fixedBackportedCustomfield">
                        <customfieldname>Fixed</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                <customfield id="customfield_10004" key="com.atlassian.jira.plugin.system.customfieldtypes:version">
                        <customfieldname>Introduced In Version</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue id="22020">19</customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_11100" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i30mbf:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_11004" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10006" key="com.atlassian.jira.plugin.system.customfieldtypes:select">
                        <customfieldname>Resolved In Build</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="17407"><![CDATA[b14]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10008" key="com.oracle.jira.jira-subcomponent-plugin:oracle-subComponentField">
                        <customfieldname>Subcomponent</customfieldname>
                        <customfieldvalues>
                             <customfieldvalue key="192"><![CDATA[runtime]]></customfieldvalue> 
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_10601" key="com.oracle.jira.javabugsystem-jira-plugin:jbs-targetBackportedCustomfield">
                        <customfieldname>Targeted</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    </customfields>
    </item>
</channel>
</rss>