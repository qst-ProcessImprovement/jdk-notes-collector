<!-- 
RSS generated by JIRA (9.12.27#9120027-sha1:edc4490121e366e9e7bd2213d532dbe7e028fc5d) at Tue Sep 30 14:05:37 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>Java Bug System</title>
    <link>https://bugs.openjdk.org</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-us</language>    <build-info>
        <version>9.12.27</version>
        <build-number>9120027</build-number>
        <build-date>02-09-2025</build-date>
    </build-info>


<item>
            <title>[JDK-8292674] ReportJNIFatalError should print all java frames</title>
                <link>https://bugs.openjdk.org/browse/JDK-8292674</link>
                <project id="10100" key="JDK">JDK</project>
                    <description>Peter Hofer reported the following output with -Xcheck:jni when using a JVM TI agent:&lt;br/&gt;
&lt;br/&gt;
FATAL ERROR in native method: Wrong object class or methodID passed to JNI call&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at jdk.internal.vm.Continuation.run(java.base/Continuation.java:260)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at java.lang.VirtualThread.runContinuation(java.base/VirtualThread.java:213)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at java.lang.VirtualThread$$Lambda$44/0x00000008000a2490.run(java.base/Unknown Source)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at java.util.concurrent.ForkJoinTask$RunnableExecuteAction.exec(java.base/ForkJoinTask.java:1423)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at java.util.concurrent.ForkJoinTask.doExec(java.base/ForkJoinTask.java:387)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(java.base/ForkJoinPool.java:1311)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at java.util.concurrent.ForkJoinPool.scan(java.base/ForkJoinPool.java:1840)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at java.util.concurrent.ForkJoinPool.runWorker(java.base/ForkJoinPool.java:1806)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at java.util.concurrent.ForkJoinWorkerThread.run(java.base/ForkJoinWorkerThread.java:177)&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
The issue here is not the crash or the reasons for it, but that the stack trace printed by ReportJNIFatalError is not very useful when there are virtual thread frames on the stack and the thread identity has temporarily switched to the carrier thread. The thread stack printing supports just the carrier stack frames or just the virtual thread stack frames but the scenario where the thread identity has to temporarily switch to the carrier is complicated and we should except a stack trace like this:&lt;br/&gt;
&lt;br/&gt;
at java.lang.Class.isArray()&lt;br/&gt;
at java.lang.invoke.MethodHandles$Lookup.isClassAccessible&lt;br/&gt;
at java.lang.invoke.MethodHandles$Lookup.checkSymbolicClass&lt;br/&gt;
at java.lang.invoke.MethodHandles$Lookup.resolveOrFail&lt;br/&gt;
at java.lang.invoke.MethodHandles$Lookup.findVarHandle&lt;br/&gt;
at java.lang.invoke.MethodHandles$Lookup.findVarHandle&lt;br/&gt;
at java.util.concurrent.FutureTask.&amp;lt;clinit&amp;gt;&lt;br/&gt;
at java.util.concurrent.ScheduledThreadPoolExecutor.schedule&lt;br/&gt;
at java.lang.VirtualThread.scheduleUnpark.   &amp;lt;=== thread identity changes to the carrier thread here&lt;br/&gt;
at java.lang.VirtualThread.parkNanos&lt;br/&gt;
at java.lang.VirtualThread.doSleepNanos&lt;br/&gt;
at java.lang.VirtualThread.sleepNanos&lt;br/&gt;
at java.lang.Thread.sleep&lt;br/&gt;
at gameoflife.GameOfLife.sleep&lt;br/&gt;
at gameoflife.GameOfLife.run&lt;br/&gt;
at jdk.internal.vm.Continuation.enterSpecial&lt;br/&gt;
at jdk.internal.vm.Continuation.run(java.base/Continuation.java:260)&lt;br/&gt;
at java.lang.VirtualThread.runContinuation(java.base/VirtualThread.java:213)&lt;br/&gt;
at java.lang.VirtualThread$$Lambda$44/0x00000008000a2490.run(java.base/Unknown Source)&lt;br/&gt;
at java.util.concurrent.ForkJoinTask$RunnableExecuteAction.exec(java.base/ForkJoinTask.java:1423)&lt;br/&gt;
at java.util.concurrent.ForkJoinTask.doExec(java.base/ForkJoinTask.java:387)&lt;br/&gt;
at java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(java.base/ForkJoinPool.java:1311)&lt;br/&gt;
at java.util.concurrent.ForkJoinPool.scan(java.base/ForkJoinPool.java:1840)&lt;br/&gt;
at java.util.concurrent.ForkJoinPool.runWorker(java.base/ForkJoinPool.java:1806)&lt;br/&gt;
at java.util.concurrent.ForkJoinWorkerThread.run(java.base/ForkJoinWorkerThread.java:177)&lt;br/&gt;
&lt;br/&gt;
For JNI fatal errors then I think the simplest is to print all stack frames (there are flags for that).&lt;br/&gt;
</description>
                <environment></environment>
        <key id="5081947">JDK-8292674</key>
            <summary>ReportJNIFatalError should print all java frames</summary>
                <type id="7" iconUrl="https://bugs.openjdk.org/secure/viewavatar?size=xsmall&amp;avatarId=14707&amp;avatarType=issuetype">Enhancement</type>
                                            <priority id="3" iconUrl="https://bugs.openjdk.org/images/jbsImages/p3.png">P3</priority>
                        <status id="5" iconUrl="https://bugs.openjdk.org/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="success"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="dholmes">David Holmes</assignee>
                                    <reporter username="alanb">Alan Bateman</reporter>
                        <labels>
                            <label>jni</label>
                            <label>loom</label>
                            <label>noreg-hard</label>
                    </labels>
                <created>Fri, 19 Aug 2022 07:54:14 -0700</created>
                <updated>Mon, 19 Dec 2022 12:38:22 -0800</updated>
                            <resolved>Mon, 12 Dec 2022 16:07:40 -0800</resolved>
                                    <version>19</version>
                                    <fixVersion>21</fixVersion>
                                    <component>hotspot</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>7</watches>
                                                                                                                <comments>
                            <comment id="14544938" author="dukebot" created="Mon, 12 Dec 2022 16:07:39 -0800"  >Changeset: 829cbc2c&lt;br/&gt;
Author:    David Holmes &amp;lt;&lt;a href=&apos;mailto:dholmes@openjdk.org&apos;&gt;dholmes@openjdk.org&lt;/a&gt;&amp;gt;&lt;br/&gt;
Date:      2022-12-13 00:04:38 +0000&lt;br/&gt;
URL:       &lt;a href=&quot;https://git.openjdk.org/jdk/commit/829cbc2cb16cfe4ad23df934768cb820e79511d8&quot;&gt;https://git.openjdk.org/jdk/commit/829cbc2cb16cfe4ad23df934768cb820e79511d8&lt;/a&gt;&lt;br/&gt;
</comment>
                            <comment id="14542964" author="roboduke" created="Mon, 5 Dec 2022 16:09:37 -0800"  >A pull request was submitted for review.&lt;br/&gt;
URL: &lt;a href=&quot;https://git.openjdk.org/jdk/pull/11503&quot;&gt;https://git.openjdk.org/jdk/pull/11503&lt;/a&gt;&lt;br/&gt;
Date: 2022-12-05 06:58:32 +0000</comment>
                            <comment id="14542494" author="dholmes" created="Sun, 4 Dec 2022 19:10:28 -0800"  >I modified the existing runtime/jni/checked/TestPrimitiveArrayCriticalWithBadParam.java test to run a normal (main) thread or a vthread. This is the output for the main thread:&lt;br/&gt;
&lt;br/&gt;
FATAL ERROR in native method: Primitive type array expected but not received for JNI array operation&lt;br/&gt;
	at TestPrimitiveArrayCriticalWithBadParam.pin(Native Method)&lt;br/&gt;
	at TestPrimitiveArrayCriticalWithBadParam.lambda$test$0(TestPrimitiveArrayCriticalWithBadParam.java:85)&lt;br/&gt;
	at TestPrimitiveArrayCriticalWithBadParam$$Lambda$1/0x0000000801000a08.run(Unknown Source)&lt;br/&gt;
	at TestPrimitiveArrayCriticalWithBadParam.test(TestPrimitiveArrayCriticalWithBadParam.java:97)&lt;br/&gt;
	at TestPrimitiveArrayCriticalWithBadParam.main(TestPrimitiveArrayCriticalWithBadParam.java:51)&lt;br/&gt;
&lt;br/&gt;
and this is for a virtual thread before the fix:&lt;br/&gt;
&lt;br/&gt;
FATAL ERROR in native method: Primitive type array expected but not received for JNI array operation&lt;br/&gt;
	at jdk.internal.vm.Continuation.run(&lt;a href=&apos;mailto:java.base@20-internal&apos;&gt;java.base@20-internal&lt;/a&gt;/Continuation.java:257)&lt;br/&gt;
	at java.lang.VirtualThread.runContinuation(&lt;a href=&apos;mailto:java.base@20-internal&apos;&gt;java.base@20-internal&lt;/a&gt;/VirtualThread.java:213)&lt;br/&gt;
	at java.lang.VirtualThread$$Lambda$8/0x0000000801047430.run(&lt;a href=&apos;mailto:java.base@20-internal&apos;&gt;java.base@20-internal&lt;/a&gt;/Unknown Source)&lt;br/&gt;
	at java.util.concurrent.ForkJoinTask$RunnableExecuteAction.exec(&lt;a href=&apos;mailto:java.base@20-internal&apos;&gt;java.base@20-internal&lt;/a&gt;/ForkJoinTask.java:1423)&lt;br/&gt;
	at java.util.concurrent.ForkJoinTask.doExec(&lt;a href=&apos;mailto:java.base@20-internal&apos;&gt;java.base@20-internal&lt;/a&gt;/ForkJoinTask.java:387)&lt;br/&gt;
	at java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(&lt;a href=&apos;mailto:java.base@20-internal&apos;&gt;java.base@20-internal&lt;/a&gt;/ForkJoinPool.java:1311)&lt;br/&gt;
	at java.util.concurrent.ForkJoinPool.scan(&lt;a href=&apos;mailto:java.base@20-internal&apos;&gt;java.base@20-internal&lt;/a&gt;/ForkJoinPool.java:1841)&lt;br/&gt;
	at java.util.concurrent.ForkJoinPool.runWorker(&lt;a href=&apos;mailto:java.base@20-internal&apos;&gt;java.base@20-internal&lt;/a&gt;/ForkJoinPool.java:1806)&lt;br/&gt;
	at java.util.concurrent.ForkJoinWorkerThread.run(&lt;a href=&apos;mailto:java.base@20-internal&apos;&gt;java.base@20-internal&lt;/a&gt;/ForkJoinWorkerThread.java:177)&lt;br/&gt;
&lt;br/&gt;
and a virtual thread after the fix:&lt;br/&gt;
&lt;br/&gt;
FATAL ERROR in native method: Primitive type array expected but not received for JNI array operation&lt;br/&gt;
	at TestPrimitiveArrayCriticalWithBadParam.pin(Native Method)&lt;br/&gt;
	at TestPrimitiveArrayCriticalWithBadParam.lambda$test$0(TestPrimitiveArrayCriticalWithBadParam.java:85)&lt;br/&gt;
	at TestPrimitiveArrayCriticalWithBadParam$$Lambda$1/0x0000000801000a08.run(Unknown Source)&lt;br/&gt;
	at java.lang.VirtualThread.run(&lt;a href=&apos;mailto:java.base@20-internal&apos;&gt;java.base@20-internal&lt;/a&gt;/VirtualThread.java:287)&lt;br/&gt;
	at java.lang.VirtualThread$VThreadContinuation.lambda$new$0(&lt;a href=&apos;mailto:java.base@20-internal&apos;&gt;java.base@20-internal&lt;/a&gt;/VirtualThread.java:174)&lt;br/&gt;
	at java.lang.VirtualThread$VThreadContinuation$$Lambda$7/0x0000000801047208.run(&lt;a href=&apos;mailto:java.base@20-internal&apos;&gt;java.base@20-internal&lt;/a&gt;/Unknown Source)&lt;br/&gt;
	at jdk.internal.vm.Continuation.enter0(&lt;a href=&apos;mailto:java.base@20-internal&apos;&gt;java.base@20-internal&lt;/a&gt;/Continuation.java:327)&lt;br/&gt;
	at jdk.internal.vm.Continuation.enter(&lt;a href=&apos;mailto:java.base@20-internal&apos;&gt;java.base@20-internal&lt;/a&gt;/Continuation.java:320)</comment>
                            <comment id="14542491" author="dholmes" created="Sun, 4 Dec 2022 17:32:15 -0800"  >For reference here is the output before:&lt;br/&gt;
&lt;br/&gt;
FATAL ERROR in native method: VirtualThread::scheduleUnpark&lt;br/&gt;
	at jdk.internal.vm.Continuation.run(&lt;a href=&apos;mailto:java.base@20-internal&apos;&gt;java.base@20-internal&lt;/a&gt;/Continuation.java:257)&lt;br/&gt;
	at java.lang.VirtualThread.runContinuation(&lt;a href=&apos;mailto:java.base@20-internal&apos;&gt;java.base@20-internal&lt;/a&gt;/VirtualThread.java:213)&lt;br/&gt;
	at java.lang.VirtualThread$$Lambda$8/0x0000000801049a30.run(&lt;a href=&apos;mailto:java.base@20-internal&apos;&gt;java.base@20-internal&lt;/a&gt;/Unknown Source)&lt;br/&gt;
	at java.util.concurrent.ForkJoinTask$RunnableExecuteAction.exec(&lt;a href=&apos;mailto:java.base@20-internal&apos;&gt;java.base@20-internal&lt;/a&gt;/ForkJoinTask.java:1423)&lt;br/&gt;
	at java.util.concurrent.ForkJoinTask.doExec(&lt;a href=&apos;mailto:java.base@20-internal&apos;&gt;java.base@20-internal&lt;/a&gt;/ForkJoinTask.java:387)&lt;br/&gt;
	at java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(&lt;a href=&apos;mailto:java.base@20-internal&apos;&gt;java.base@20-internal&lt;/a&gt;/ForkJoinPool.java:1311)&lt;br/&gt;
	at java.util.concurrent.ForkJoinPool.scan(&lt;a href=&apos;mailto:java.base@20-internal&apos;&gt;java.base@20-internal&lt;/a&gt;/ForkJoinPool.java:1841)&lt;br/&gt;
	at java.util.concurrent.ForkJoinPool.runWorker(&lt;a href=&apos;mailto:java.base@20-internal&apos;&gt;java.base@20-internal&lt;/a&gt;/ForkJoinPool.java:1806)&lt;br/&gt;
	at java.util.concurrent.ForkJoinWorkerThread.run(&lt;a href=&apos;mailto:java.base@20-internal&apos;&gt;java.base@20-internal&lt;/a&gt;/ForkJoinWorkerThread.java:177)&lt;br/&gt;
Aborted (core dumped)&lt;br/&gt;
&lt;br/&gt;
and after:&lt;br/&gt;
&lt;br/&gt;
FATAL ERROR in native method: VirtualThread::scheduleUnpark&lt;br/&gt;
	at java.lang.VirtualThread.JNIFatalError(&lt;a href=&apos;mailto:java.base@20-internal&apos;&gt;java.base@20-internal&lt;/a&gt;/Native Method)&lt;br/&gt;
	at java.lang.VirtualThread.scheduleUnpark(&lt;a href=&apos;mailto:java.base@20-internal&apos;&gt;java.base@20-internal&lt;/a&gt;/VirtualThread.java:625)&lt;br/&gt;
	at java.lang.VirtualThread.parkNanos(&lt;a href=&apos;mailto:java.base@20-internal&apos;&gt;java.base@20-internal&lt;/a&gt;/VirtualThread.java:562)&lt;br/&gt;
	at java.lang.VirtualThread.doSleepNanos(&lt;a href=&apos;mailto:java.base@20-internal&apos;&gt;java.base@20-internal&lt;/a&gt;/VirtualThread.java:745)&lt;br/&gt;
	at java.lang.VirtualThread.sleepNanos(&lt;a href=&apos;mailto:java.base@20-internal&apos;&gt;java.base@20-internal&lt;/a&gt;/VirtualThread.java:718)&lt;br/&gt;
	at java.lang.Thread.sleep(&lt;a href=&apos;mailto:java.base@20-internal&apos;&gt;java.base@20-internal&lt;/a&gt;/Thread.java:453)&lt;br/&gt;
	at VirtualSleep.lambda$main$0(VirtualSleep.java:8)&lt;br/&gt;
	at VirtualSleep$$Lambda$1/0x0000000801000a08.run(Unknown Source)&lt;br/&gt;
	at java.util.concurrent.Executors$RunnableAdapter.call(&lt;a href=&apos;mailto:java.base@20-internal&apos;&gt;java.base@20-internal&lt;/a&gt;/Executors.java:577)&lt;br/&gt;
	at java.util.concurrent.ThreadPerTaskExecutor$ThreadBoundFuture.run(&lt;a href=&apos;mailto:java.base@20-internal&apos;&gt;java.base@20-internal&lt;/a&gt;/ThreadPerTaskExecutor.java:352)&lt;br/&gt;
	at java.lang.VirtualThread.run(&lt;a href=&apos;mailto:java.base@20-internal&apos;&gt;java.base@20-internal&lt;/a&gt;/VirtualThread.java:287)&lt;br/&gt;
	at java.lang.VirtualThread$VThreadContinuation.lambda$new$0(&lt;a href=&apos;mailto:java.base@20-internal&apos;&gt;java.base@20-internal&lt;/a&gt;/VirtualThread.java:174)&lt;br/&gt;
	at java.lang.VirtualThread$VThreadContinuation$$Lambda$7/0x0000000801049808.run(&lt;a href=&apos;mailto:java.base@20-internal&apos;&gt;java.base@20-internal&lt;/a&gt;/Unknown Source)&lt;br/&gt;
	at jdk.internal.vm.Continuation.enter0(&lt;a href=&apos;mailto:java.base@20-internal&apos;&gt;java.base@20-internal&lt;/a&gt;/Continuation.java:327)&lt;br/&gt;
	at jdk.internal.vm.Continuation.enter(&lt;a href=&apos;mailto:java.base@20-internal&apos;&gt;java.base@20-internal&lt;/a&gt;/Continuation.java:320)&lt;br/&gt;
&lt;br/&gt;
I think this needs further test cases though, with actual native code triggering the fatal error (per the original description), in which case we probably want to include native frames as well as Java frames (though existing code for regular threads doesn&amp;#39;t do that - so perhaps another RFE).</comment>
                            <comment id="14542489" author="dholmes" created="Sun, 4 Dec 2022 13:25:55 -0800"  >After further discussion I&amp;#39;m going to redo this fix and just fix the cases that obviously need to work with virtual threads. I will add a new method to just print the current virtual thread stack. I will likely split out the cases into separate bugs for clarity, so this issue will just add the new method and use it for JNI reporting.</comment>
                            <comment id="14542156" author="rpressler" created="Fri, 2 Dec 2022 01:27:54 -0800"  >There is no doubt there are cases -- especially related to synchronized deadlock due to the current synchronized limitation -- where showing that information would be helpful. But that information should be shown in the right place, and not by giving users the wrong impression about the relationship between virtual threads and carriers. So the problem here is that we need to improve deadlock detection and its troubleshooting for virtual threads -- because that is what the stacks shown are trying to troubleshoot -- but that improvement should be in the virtual thread dump, and not in the stack dump of other threads.</comment>
                            <comment id="14542068" author="dholmes" created="Thu, 1 Dec 2022 17:42:49 -0800"  >The Loom folk are objecting to the generalisation of this, and I&amp;#39;ve been pointed to a previous discussion on the general topic:&lt;br/&gt;
&lt;br/&gt;
&lt;a href=&quot;https://mail.openjdk.org/pipermail/loom-dev/2022-July/004762.html&quot;&gt;https://mail.openjdk.org/pipermail/loom-dev/2022-July/004762.html&lt;/a&gt;&lt;br/&gt;
&lt;br/&gt;
and I&amp;#39;m still arguing that it makes sense to always show the mounted virtual thread, rather than just special casing for JNI ReportFatalError, and DiagnoseSyncOnValueBasedClasses.</comment>
                            <comment id="14542066" author="dholmes" created="Thu, 1 Dec 2022 16:36:48 -0800"  >This also affects the operation of `jstack` and `jcmd Thread.print`</comment>
                            <comment id="14541788" author="dholmes" created="Wed, 30 Nov 2022 23:35:28 -0800"  >To add some clarity to things I&amp;#39;ve marked the end of the virtual thread stack:&lt;br/&gt;
&lt;br/&gt;
&amp;quot;ForkJoinPool-1-worker-2&amp;quot; #31 [21102] daemon prio=5 os_prio=0 cpu=0.95ms elapsed=2.63s tid=0x00007f05a4000d30  [0x00007f05e58f6000]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;Carrying virtual thread #30&lt;br/&gt;
Thread: 0x00007f05a4000d30  [0x526e] State: _at_safepoint _at_poll_safepoint 0&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;JavaThread state: _thread_blocked&lt;br/&gt;
	at SyncDeadlock$4.run(SyncDeadlock.java:24)&lt;br/&gt;
	- waiting to lock &amp;lt;0x0000000454014b08&amp;gt; (a SyncDeadlock$1)&lt;br/&gt;
	- locked &amp;lt;0x0000000454015298&amp;gt; (a SyncDeadlock$2)&lt;br/&gt;
	at java.lang.VirtualThread.run(&lt;a href=&apos;mailto:java.base@20-internal&apos;&gt;java.base@20-internal&lt;/a&gt;/VirtualThread.java:287)&lt;br/&gt;
	at java.lang.VirtualThread$VThreadContinuation.lambda$new$0(&lt;a href=&apos;mailto:java.base@20-internal&apos;&gt;java.base@20-internal&lt;/a&gt;/VirtualThread.java:174)&lt;br/&gt;
	at java.lang.VirtualThread$VThreadContinuation$$Lambda$6/0x0000000801046d48.run(&lt;a href=&apos;mailto:java.base@20-internal&apos;&gt;java.base@20-internal&lt;/a&gt;/Unknown Source)&lt;br/&gt;
	at jdk.internal.vm.Continuation.enter0(&lt;a href=&apos;mailto:java.base@20-internal&apos;&gt;java.base@20-internal&lt;/a&gt;/Continuation.java:327)&lt;br/&gt;
	at jdk.internal.vm.Continuation.enter(&lt;a href=&apos;mailto:java.base@20-internal&apos;&gt;java.base@20-internal&lt;/a&gt;/Continuation.java:320)&lt;br/&gt;
	at jdk.internal.vm.Continuation.enterSpecial(&lt;a href=&apos;mailto:java.base@20-internal&apos;&gt;java.base@20-internal&lt;/a&gt;/Native Method)&lt;br/&gt;
	&amp;lt;&amp;lt;&amp;lt; end of virtual thread stack &amp;gt;&amp;gt;&amp;gt;&lt;br/&gt;
	at jdk.internal.vm.Continuation.run(&lt;a href=&apos;mailto:java.base@20-internal&apos;&gt;java.base@20-internal&lt;/a&gt;/Continuation.java:257)&lt;br/&gt;
	at java.lang.VirtualThread.runContinuation(&lt;a href=&apos;mailto:java.base@20-internal&apos;&gt;java.base@20-internal&lt;/a&gt;/VirtualThread.java:213)&lt;br/&gt;
	at java.lang.VirtualThread$$Lambda$7/0x0000000801046f70.run(&lt;a href=&apos;mailto:java.base@20-internal&apos;&gt;java.base@20-internal&lt;/a&gt;/Unknown Source)&lt;br/&gt;
	at java.util.concurrent.ForkJoinTask$RunnableExecuteAction.exec(&lt;a href=&apos;mailto:java.base@20-internal&apos;&gt;java.base@20-internal&lt;/a&gt;/ForkJoinTask.java:1423)&lt;br/&gt;
	at java.util.concurrent.ForkJoinTask.doExec(&lt;a href=&apos;mailto:java.base@20-internal&apos;&gt;java.base@20-internal&lt;/a&gt;/ForkJoinTask.java:387)&lt;br/&gt;
	at java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(&lt;a href=&apos;mailto:java.base@20-internal&apos;&gt;java.base@20-internal&lt;/a&gt;/ForkJoinPool.java:1311)&lt;br/&gt;
	at java.util.concurrent.ForkJoinPool.scan(&lt;a href=&apos;mailto:java.base@20-internal&apos;&gt;java.base@20-internal&lt;/a&gt;/ForkJoinPool.java:1841)&lt;br/&gt;
	at java.util.concurrent.ForkJoinPool.runWorker(&lt;a href=&apos;mailto:java.base@20-internal&apos;&gt;java.base@20-internal&lt;/a&gt;/ForkJoinPool.java:1806)&lt;br/&gt;
	at java.util.concurrent.ForkJoinWorkerThread.run(&lt;a href=&apos;mailto:java.base@20-internal&apos;&gt;java.base@20-internal&lt;/a&gt;/ForkJoinWorkerThread.java:177)&lt;br/&gt;
</comment>
                            <comment id="14541751" author="dholmes" created="Wed, 30 Nov 2022 18:34:49 -0800"  >As an example here is what is synchronized deadlock would currently show in the thread dump:&lt;br/&gt;
&lt;br/&gt;
&amp;quot;ForkJoinPool-1-worker-1&amp;quot; #29 [24887] daemon prio=5 os_prio=0 cpu=2.26ms elapsed=6.57s tid=0x00007fe6882f0230  [0x00007fe658f5e000]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;Carrying virtual thread #28&lt;br/&gt;
Thread: 0x00007fe6882f0230  [0x6137] State: _at_safepoint _at_poll_safepoint 0&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;JavaThread state: _thread_blocked&lt;br/&gt;
	at jdk.internal.vm.Continuation.run(&lt;a href=&apos;mailto:java.base@20-internal&apos;&gt;java.base@20-internal&lt;/a&gt;/Continuation.java:257)&lt;br/&gt;
	at java.lang.VirtualThread.runContinuation(&lt;a href=&apos;mailto:java.base@20-internal&apos;&gt;java.base@20-internal&lt;/a&gt;/VirtualThread.java:213)&lt;br/&gt;
	at java.lang.VirtualThread$$Lambda$7/0x0000000801046f70.run(&lt;a href=&apos;mailto:java.base@20-internal&apos;&gt;java.base@20-internal&lt;/a&gt;/Unknown Source)&lt;br/&gt;
	at java.util.concurrent.ForkJoinTask$RunnableExecuteAction.exec(&lt;a href=&apos;mailto:java.base@20-internal&apos;&gt;java.base@20-internal&lt;/a&gt;/ForkJoinTask.java:1423)&lt;br/&gt;
	at java.util.concurrent.ForkJoinTask.doExec(&lt;a href=&apos;mailto:java.base@20-internal&apos;&gt;java.base@20-internal&lt;/a&gt;/ForkJoinTask.java:387)&lt;br/&gt;
	at java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(&lt;a href=&apos;mailto:java.base@20-internal&apos;&gt;java.base@20-internal&lt;/a&gt;/ForkJoinPool.java:1311)&lt;br/&gt;
	at java.util.concurrent.ForkJoinPool.scan(&lt;a href=&apos;mailto:java.base@20-internal&apos;&gt;java.base@20-internal&lt;/a&gt;/ForkJoinPool.java:1841)&lt;br/&gt;
	at java.util.concurrent.ForkJoinPool.runWorker(&lt;a href=&apos;mailto:java.base@20-internal&apos;&gt;java.base@20-internal&lt;/a&gt;/ForkJoinPool.java:1806)&lt;br/&gt;
	at java.util.concurrent.ForkJoinWorkerThread.run(&lt;a href=&apos;mailto:java.base@20-internal&apos;&gt;java.base@20-internal&lt;/a&gt;/ForkJoinWorkerThread.java:177)&lt;br/&gt;
&lt;br/&gt;
&amp;quot;ForkJoinPool-1-worker-2&amp;quot; #31 [24888] daemon prio=5 os_prio=0 cpu=1.15ms elapsed=6.57s tid=0x00007fe604000d30  [0x00007fe658e5d000]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;Carrying virtual thread #30&lt;br/&gt;
Thread: 0x00007fe604000d30  [0x6138] State: _at_safepoint _at_poll_safepoint 0&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;JavaThread state: _thread_blocked&lt;br/&gt;
	at jdk.internal.vm.Continuation.run(&lt;a href=&apos;mailto:java.base@20-internal&apos;&gt;java.base@20-internal&lt;/a&gt;/Continuation.java:257)&lt;br/&gt;
	at java.lang.VirtualThread.runContinuation(&lt;a href=&apos;mailto:java.base@20-internal&apos;&gt;java.base@20-internal&lt;/a&gt;/VirtualThread.java:213)&lt;br/&gt;
	at java.lang.VirtualThread$$Lambda$7/0x0000000801046f70.run(&lt;a href=&apos;mailto:java.base@20-internal&apos;&gt;java.base@20-internal&lt;/a&gt;/Unknown Source)&lt;br/&gt;
	at java.util.concurrent.ForkJoinTask$RunnableExecuteAction.exec(&lt;a href=&apos;mailto:java.base@20-internal&apos;&gt;java.base@20-internal&lt;/a&gt;/ForkJoinTask.java:1423)&lt;br/&gt;
	at java.util.concurrent.ForkJoinTask.doExec(&lt;a href=&apos;mailto:java.base@20-internal&apos;&gt;java.base@20-internal&lt;/a&gt;/ForkJoinTask.java:387)&lt;br/&gt;
	at java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(&lt;a href=&apos;mailto:java.base@20-internal&apos;&gt;java.base@20-internal&lt;/a&gt;/ForkJoinPool.java:1311)&lt;br/&gt;
	at java.util.concurrent.ForkJoinPool.scan(&lt;a href=&apos;mailto:java.base@20-internal&apos;&gt;java.base@20-internal&lt;/a&gt;/ForkJoinPool.java:1841)&lt;br/&gt;
	at java.util.concurrent.ForkJoinPool.runWorker(&lt;a href=&apos;mailto:java.base@20-internal&apos;&gt;java.base@20-internal&lt;/a&gt;/ForkJoinPool.java:1806)&lt;br/&gt;
	at java.util.concurrent.ForkJoinWorkerThread.run(&lt;a href=&apos;mailto:java.base@20-internal&apos;&gt;java.base@20-internal&lt;/a&gt;/ForkJoinWorkerThread.java:177)&lt;br/&gt;
&lt;br/&gt;
versus what is seen after this fix:&lt;br/&gt;
&lt;br/&gt;
&amp;quot;ForkJoinPool-1-worker-1&amp;quot; #29 [28907] daemon prio=5 os_prio=0 cpu=1.75ms elapsed=5.98s tid=0x00007f71182f83f0  [0x00007f70e905f000]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;Carrying virtual thread #28&lt;br/&gt;
Thread: 0x00007f71182f83f0  [0x70eb] State: _at_safepoint _at_poll_safepoint 0&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;JavaThread state: _thread_blocked&lt;br/&gt;
	at SyncDeadlock$3.run(SyncDeadlock.java:13)&lt;br/&gt;
	- waiting to lock &amp;lt;0x0000000454015298&amp;gt; (a SyncDeadlock$2)&lt;br/&gt;
	- locked &amp;lt;0x0000000454014b08&amp;gt; (a SyncDeadlock$1)&lt;br/&gt;
	at java.lang.VirtualThread.run(&lt;a href=&apos;mailto:java.base@20-internal&apos;&gt;java.base@20-internal&lt;/a&gt;/VirtualThread.java:287)&lt;br/&gt;
	at java.lang.VirtualThread$VThreadContinuation.lambda$new$0(&lt;a href=&apos;mailto:java.base@20-internal&apos;&gt;java.base@20-internal&lt;/a&gt;/VirtualThread.java:174)&lt;br/&gt;
	at java.lang.VirtualThread$VThreadContinuation$$Lambda$6/0x0000000801046d48.run(&lt;a href=&apos;mailto:java.base@20-internal&apos;&gt;java.base@20-internal&lt;/a&gt;/Unknown Source)&lt;br/&gt;
	at jdk.internal.vm.Continuation.enter0(&lt;a href=&apos;mailto:java.base@20-internal&apos;&gt;java.base@20-internal&lt;/a&gt;/Continuation.java:327)&lt;br/&gt;
	at jdk.internal.vm.Continuation.enter(&lt;a href=&apos;mailto:java.base@20-internal&apos;&gt;java.base@20-internal&lt;/a&gt;/Continuation.java:320)&lt;br/&gt;
	at jdk.internal.vm.Continuation.enterSpecial(&lt;a href=&apos;mailto:java.base@20-internal&apos;&gt;java.base@20-internal&lt;/a&gt;/Native Method)&lt;br/&gt;
	at jdk.internal.vm.Continuation.run(&lt;a href=&apos;mailto:java.base@20-internal&apos;&gt;java.base@20-internal&lt;/a&gt;/Continuation.java:257)&lt;br/&gt;
	at java.lang.VirtualThread.runContinuation(&lt;a href=&apos;mailto:java.base@20-internal&apos;&gt;java.base@20-internal&lt;/a&gt;/VirtualThread.java:213)&lt;br/&gt;
	at java.lang.VirtualThread$$Lambda$7/0x0000000801046f70.run(&lt;a href=&apos;mailto:java.base@20-internal&apos;&gt;java.base@20-internal&lt;/a&gt;/Unknown Source)&lt;br/&gt;
	at java.util.concurrent.ForkJoinTask$RunnableExecuteAction.exec(&lt;a href=&apos;mailto:java.base@20-internal&apos;&gt;java.base@20-internal&lt;/a&gt;/ForkJoinTask.java:1423)&lt;br/&gt;
	at java.util.concurrent.ForkJoinTask.doExec(&lt;a href=&apos;mailto:java.base@20-internal&apos;&gt;java.base@20-internal&lt;/a&gt;/ForkJoinTask.java:387)&lt;br/&gt;
	at java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(&lt;a href=&apos;mailto:java.base@20-internal&apos;&gt;java.base@20-internal&lt;/a&gt;/ForkJoinPool.java:1311)&lt;br/&gt;
	at java.util.concurrent.ForkJoinPool.scan(&lt;a href=&apos;mailto:java.base@20-internal&apos;&gt;java.base@20-internal&lt;/a&gt;/ForkJoinPool.java:1841)&lt;br/&gt;
	at java.util.concurrent.ForkJoinPool.runWorker(&lt;a href=&apos;mailto:java.base@20-internal&apos;&gt;java.base@20-internal&lt;/a&gt;/ForkJoinPool.java:1806)&lt;br/&gt;
	at java.util.concurrent.ForkJoinWorkerThread.run(&lt;a href=&apos;mailto:java.base@20-internal&apos;&gt;java.base@20-internal&lt;/a&gt;/ForkJoinWorkerThread.java:177)&lt;br/&gt;
&lt;br/&gt;
&amp;quot;ForkJoinPool-1-worker-2&amp;quot; #31 [28908] daemon prio=5 os_prio=0 cpu=1.85ms elapsed=5.98s tid=0x00007f7094000d30  [0x00007f70e8f5e000]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;Carrying virtual thread #30&lt;br/&gt;
Thread: 0x00007f7094000d30  [0x70ec] State: _at_safepoint _at_poll_safepoint 0&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;JavaThread state: _thread_blocked&lt;br/&gt;
	at SyncDeadlock$4.run(SyncDeadlock.java:24)&lt;br/&gt;
	- waiting to lock &amp;lt;0x0000000454014b08&amp;gt; (a SyncDeadlock$1)&lt;br/&gt;
	- locked &amp;lt;0x0000000454015298&amp;gt; (a SyncDeadlock$2)&lt;br/&gt;
	at java.lang.VirtualThread.run(&lt;a href=&apos;mailto:java.base@20-internal&apos;&gt;java.base@20-internal&lt;/a&gt;/VirtualThread.java:287)&lt;br/&gt;
	at java.lang.VirtualThread$VThreadContinuation.lambda$new$0(&lt;a href=&apos;mailto:java.base@20-internal&apos;&gt;java.base@20-internal&lt;/a&gt;/VirtualThread.java:174)&lt;br/&gt;
	at java.lang.VirtualThread$VThreadContinuation$$Lambda$6/0x0000000801046d48.run(&lt;a href=&apos;mailto:java.base@20-internal&apos;&gt;java.base@20-internal&lt;/a&gt;/Unknown Source)&lt;br/&gt;
	at jdk.internal.vm.Continuation.enter0(&lt;a href=&apos;mailto:java.base@20-internal&apos;&gt;java.base@20-internal&lt;/a&gt;/Continuation.java:327)&lt;br/&gt;
	at jdk.internal.vm.Continuation.enter(&lt;a href=&apos;mailto:java.base@20-internal&apos;&gt;java.base@20-internal&lt;/a&gt;/Continuation.java:320)&lt;br/&gt;
	at jdk.internal.vm.Continuation.enterSpecial(&lt;a href=&apos;mailto:java.base@20-internal&apos;&gt;java.base@20-internal&lt;/a&gt;/Native Method)&lt;br/&gt;
	at jdk.internal.vm.Continuation.run(&lt;a href=&apos;mailto:java.base@20-internal&apos;&gt;java.base@20-internal&lt;/a&gt;/Continuation.java:257)&lt;br/&gt;
	at java.lang.VirtualThread.runContinuation(&lt;a href=&apos;mailto:java.base@20-internal&apos;&gt;java.base@20-internal&lt;/a&gt;/VirtualThread.java:213)&lt;br/&gt;
	at java.lang.VirtualThread$$Lambda$7/0x0000000801046f70.run(&lt;a href=&apos;mailto:java.base@20-internal&apos;&gt;java.base@20-internal&lt;/a&gt;/Unknown Source)&lt;br/&gt;
	at java.util.concurrent.ForkJoinTask$RunnableExecuteAction.exec(&lt;a href=&apos;mailto:java.base@20-internal&apos;&gt;java.base@20-internal&lt;/a&gt;/ForkJoinTask.java:1423)&lt;br/&gt;
	at java.util.concurrent.ForkJoinTask.doExec(&lt;a href=&apos;mailto:java.base@20-internal&apos;&gt;java.base@20-internal&lt;/a&gt;/ForkJoinTask.java:387)&lt;br/&gt;
	at java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(&lt;a href=&apos;mailto:java.base@20-internal&apos;&gt;java.base@20-internal&lt;/a&gt;/ForkJoinPool.java:1311)&lt;br/&gt;
	at java.util.concurrent.ForkJoinPool.scan(&lt;a href=&apos;mailto:java.base@20-internal&apos;&gt;java.base@20-internal&lt;/a&gt;/ForkJoinPool.java:1841)&lt;br/&gt;
	at java.util.concurrent.ForkJoinPool.runWorker(&lt;a href=&apos;mailto:java.base@20-internal&apos;&gt;java.base@20-internal&lt;/a&gt;/ForkJoinPool.java:1806)&lt;br/&gt;
	at java.util.concurrent.ForkJoinWorkerThread.run(&lt;a href=&apos;mailto:java.base@20-internal&apos;&gt;java.base@20-internal&lt;/a&gt;/ForkJoinWorkerThread.java:177)&lt;br/&gt;
</comment>
                            <comment id="14541750" author="dholmes" created="Wed, 30 Nov 2022 18:32:04 -0800"  >After examining all the uses of JavaThread::print_stack/print_stack_on I have concluded that we do always want to show the virtual thread stack as well. As already indicated here that is the case for JNI ReportFatalError and examining the other cases it is also true:&lt;br/&gt;
- General ctrl-\ thread dump (else it hides critical details like virtual threads blocked on object monitor sync; and in general only gives you a partial view of what all the platform threads are doing)&lt;br/&gt;
- DiagnoseSyncOnValueBasedClassed (same reason: to be useful you need to see what the virtual thread is doing)&lt;br/&gt;
- Deadlock detection stack reporting - this doesn&amp;#39;t actually function when VT&amp;#39;s are involved, but you&amp;#39;d want to see the full stack if it did&lt;br/&gt;
&lt;br/&gt;
There is one other use in WhiteBox where it makes no difference but wouldn&amp;#39;t hurt.&lt;br/&gt;
&lt;br/&gt;
I can&amp;#39;t see any reason to not want to show the complete Java stack for platform threads using this API. So I propose to use this issue to enable VT stack printing in all cases.</comment>
                            <comment id="14541147" author="alanb" created="Tue, 29 Nov 2022 01:06:48 -0800"  >&amp;gt; IIUC during the call to UNPARKER.schedule there is no VT. [~alanb] is that correct?&lt;br/&gt;
&lt;br/&gt;
The virtual thread frames are on the java thread&amp;#39;s stack but the thread identity (as in Thread.currentThread) will be the carrier thread. These temporarily transitions are primarily intended to be avoid recursive parking.</comment>
                            <comment id="14541116" author="dholmes" created="Mon, 28 Nov 2022 22:29:52 -0800"  >Okay ... this is somewhat more complex than envisioned. We currently have three chunks of code that &amp;quot;print the stack&amp;quot;:&lt;br/&gt;
- JavaThread::print_stack&lt;br/&gt;
- JavaThread::trace_stack&lt;br/&gt;
- java_lang_Throwable::fill_in_stack_trace&lt;br/&gt;
&lt;br/&gt;
The latter two show the complete stack for the carrier thread and virtual thread. The former only shows the carrier thread up to Continuation.run.&lt;br/&gt;
&lt;br/&gt;
The use of  RegisterMap::WalkContinuation::include versus RegisterMap::WalkContinuation::skip does not seem to be what controls the difference (as trace_stack uses skip).&lt;br/&gt;
&lt;br/&gt;
It really seems to be about how the vframes are walked:&lt;br/&gt;
- print_stack starts from platform_thread_last_java_vframe(&amp;amp;reg_map)&lt;br/&gt;
- trace_stack starts from last_java_vframe(&amp;amp;reg_map)&lt;br/&gt;
- fill_in_stack_trace doesn&amp;#39;t use the vframes at all</comment>
                            <comment id="14540754" author="dholmes" created="Mon, 28 Nov 2022 13:55:17 -0800"  >Thanks [~phofer]. My test is slightly more direct in triggering a fatal error. Unfortunately I can&amp;#39;t seem to cause the frames of the VT to appear in the stack. I don&amp;#39;t know if this code has changed since this was reported but we have:&lt;br/&gt;
&lt;br/&gt;
private Future&amp;lt;?&amp;gt; scheduleUnpark(Runnable unparker, long nanos) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// need to switch to current carrier thread to avoid nested parking&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;boolean notifyJvmti = switchToCarrierThread();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;try {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return UNPARKER.schedule(unparker, nanos, NANOSECONDS);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;} finally {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;switchToVirtualThread(this, notifyJvmti);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&lt;br/&gt;
IIUC during the call to UNPARKER.schedule there is no VT. [~alanb] is that correct?&lt;br/&gt;
&lt;br/&gt;
EDIT: I&amp;#39;ve injected the fatalError at different points in the above code - when there should be a VT, but I cannot get the VT frames to show up.</comment>
                            <comment id="14540662" author="JIRAUSER20511" created="Mon, 28 Nov 2022 08:18:52 -0800"  >[~dholmes] I originally encountered this with a JVMTI agent which sets a breakpoint in MethodHandles$Lookup.findVarHandle. When the agent is called back once the breakpoint triggers, it attempts to read a local from the current frame via GetLocalObject and passes NULL for the thread argument to refer to the current (virtual) thread, but hits &lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8292657&quot; title=&quot;Calling GetLocalXXX from virtual thread with thread parameter set to NULL returns carrier locals&quot; class=&quot;issue-link&quot; data-issue-key=&quot;JDK-8292657&quot;&gt;&lt;strike&gt;JDK-8292657&lt;/strike&gt;&lt;/a&gt; and instead gets a local from the last carrier thread frame before switching to the virtual thread. When the agent passes the read object reference as an argument to a JNI call, it has an incompatible type and triggers the fatal error with -Xcheck:jni, but the stack trace will only include the bottom carrier frames. The breakpoint did in fact trigger during a temporary switch to the carrier thread, which should no longer happen, but I believe that this is unrelated to &lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8292657&quot; title=&quot;Calling GetLocalXXX from virtual thread with thread parameter set to NULL returns carrier locals&quot; class=&quot;issue-link&quot; data-issue-key=&quot;JDK-8292657&quot;&gt;&lt;strike&gt;JDK-8292657&lt;/strike&gt;&lt;/a&gt; and this issue.&lt;br/&gt;
The core problem is that the fatal error doesn&amp;#39;t print the virtual thread frames where the error happens. I think this can be reproduced just by doing a native call in a virtual thread, and in the native code calling a Java method via JNI with an invalid type so that it triggers a fatal error with -Xcheck:jni. The stack trace that is then printed should contain only the stack frames of the carrier thread (just ForkJoinPool code) and not those of the virtual thread that triggered the error, which would be the most helpful.</comment>
                            <comment id="14540575" author="dholmes" created="Mon, 28 Nov 2022 04:14:50 -0800"  >That is what I was saying above - the stack is unchanged whether I used skip or include - and scheduleUnpark does not show up.</comment>
                            <comment id="14540548" author="alanb" created="Mon, 28 Nov 2022 02:01:13 -0800"  >If JavaThread::print_stack_on is changed to use RegisterMap::WalkContinuation::include then it would be useful to know if you get the &amp;quot;full stack&amp;quot;. There will be three groups of frames. ForkJoinWorkerThread.run...Continuation.runContinuation for the carrier thread, Continuation.enter..VirtualThread.scheduleUnpark for the virtual thread, and maybe some additional frames for the carrier thread that leads to the JNI fatal error.&lt;br/&gt;
&lt;br/&gt;
</comment>
                            <comment id="14540539" author="dholmes" created="Mon, 28 Nov 2022 01:23:55 -0800"  >I injected a direct call to FatalError from scheduleUnpark. But this is as much of a stack as I seem to be able to get.&lt;br/&gt;
&lt;br/&gt;
FATAL ERROR in native method: VirtualThread::scheduleUnpark&lt;br/&gt;
	at jdk.internal.vm.Continuation.run(&lt;a href=&apos;mailto:java.base@20-internal&apos;&gt;java.base@20-internal&lt;/a&gt;/Continuation.java:257)&lt;br/&gt;
	at java.lang.VirtualThread.runContinuation(&lt;a href=&apos;mailto:java.base@20-internal&apos;&gt;java.base@20-internal&lt;/a&gt;/VirtualThread.java:213)&lt;br/&gt;
	at java.lang.VirtualThread$$Lambda$100/0x000000080106f2d8.run(&lt;a href=&apos;mailto:java.base@20-internal&apos;&gt;java.base@20-internal&lt;/a&gt;/Unknown Source)&lt;br/&gt;
	at java.util.concurrent.ForkJoinTask$RunnableExecuteAction.exec(&lt;a href=&apos;mailto:java.base@20-internal&apos;&gt;java.base@20-internal&lt;/a&gt;/ForkJoinTask.java:1423)&lt;br/&gt;
	at java.util.concurrent.ForkJoinTask.doExec(&lt;a href=&apos;mailto:java.base@20-internal&apos;&gt;java.base@20-internal&lt;/a&gt;/ForkJoinTask.java:387)&lt;br/&gt;
	at java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(&lt;a href=&apos;mailto:java.base@20-internal&apos;&gt;java.base@20-internal&lt;/a&gt;/ForkJoinPool.java:1311)&lt;br/&gt;
	at java.util.concurrent.ForkJoinPool.scan(&lt;a href=&apos;mailto:java.base@20-internal&apos;&gt;java.base@20-internal&lt;/a&gt;/ForkJoinPool.java:1841)&lt;br/&gt;
	at java.util.concurrent.ForkJoinPool.runWorker(&lt;a href=&apos;mailto:java.base@20-internal&apos;&gt;java.base@20-internal&lt;/a&gt;/ForkJoinPool.java:1806)&lt;br/&gt;
	at java.util.concurrent.ForkJoinWorkerThread.run(&lt;a href=&apos;mailto:java.base@20-internal&apos;&gt;java.base@20-internal&lt;/a&gt;/ForkJoinWorkerThread.java:177)&lt;br/&gt;
&lt;br/&gt;
I think I need t have multiple VT&amp;#39;s involved to actually get the type of stack show in the bug report - but that makes it much harder to try and inject the right kind of failure.&lt;br/&gt;
&lt;br/&gt;
&amp;gt; For JNI fatal errors then I think the simplest is to print all stack frames (there are flags for that). &lt;br/&gt;
&lt;br/&gt;
RegisterMap::WalkContinuation::include vs RegisterMap::WalkContinuation::skip ?</comment>
                            <comment id="14540152" author="alanb" created="Thu, 24 Nov 2022 03:08:48 -0800"  >I think it&amp;#39;s going to hard to create a test case to demonstrate this, maybe [~phofer] has something? It&amp;#39;s hard because we need to instrument a method such as VirtualThread.scheduleUnpark to execute JNI code between the calls to switchToCarrierThread to switchToVirtualThread. This bug report also pre-dates changes to JVMTI to hide events from agents when during temporarily transition so it might be that it will be super hard to demonstrate an issue now.&lt;br/&gt;
</comment>
                            <comment id="14540067" author="dholmes" created="Wed, 23 Nov 2022 19:27:23 -0800"  >[~alanb] do we have more details on how to reproduce this?</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10003">
                    <name>Relates</name>
                                            <outwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="5083172">JDK-8293613</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="5088876">JDK-8298081</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                    </issuelinks>
                <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_11700" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_10600" key="com.oracle.jira.javabugsystem-jira-plugin:jbs-fixedBackportedCustomfield">
                        <customfieldname>Fixed</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_11100" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i2ybkz:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_11004" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10006" key="com.atlassian.jira.plugin.system.customfieldtypes:select">
                        <customfieldname>Resolved In Build</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="17317"><![CDATA[b02]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10008" key="com.oracle.jira.jira-subcomponent-plugin:oracle-subComponentField">
                        <customfieldname>Subcomponent</customfieldname>
                        <customfieldvalues>
                             <customfieldvalue key="192"><![CDATA[runtime]]></customfieldvalue> 
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_10601" key="com.oracle.jira.javabugsystem-jira-plugin:jbs-targetBackportedCustomfield">
                        <customfieldname>Targeted</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    </customfields>
    </item>
</channel>
</rss>