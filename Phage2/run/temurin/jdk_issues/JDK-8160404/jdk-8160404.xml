<!-- 
RSS generated by JIRA (9.12.27#9120027-sha1:edc4490121e366e9e7bd2213d532dbe7e028fc5d) at Tue Sep 30 13:35:26 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>Java Bug System</title>
    <link>https://bugs.openjdk.org</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-us</language>    <build-info>
        <version>9.12.27</version>
        <build-number>9120027</build-number>
        <build-date>02-09-2025</build-date>
    </build-info>


<item>
            <title>[JDK-8160404] RelocationHolder constructors have bugs</title>
                <link>https://bugs.openjdk.org/browse/JDK-8160404</link>
                <project id="10100" key="JDK">JDK</project>
                    <description>RelocationHolder has a _relocbuf member, which is really just storage for a Relocation object.  The constructors for RelocationHolder are both problematic.  The no-arg constructor is&lt;br/&gt;
&lt;br/&gt;
RelocationHolder::RelocationHolder() {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;new(*this) Relocation();&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
This is all very contorted and fragile. I wonder why RelocationHolder doesn&amp;#39;t just use placement new to (default) construct the Relocation object. e.g.&lt;br/&gt;
&lt;br/&gt;
new (_relocbuf) Relocation();&lt;br/&gt;
&lt;br/&gt;
The other constructor is&lt;br/&gt;
&lt;br/&gt;
RelocationHolder::RelocationHolder(Relocation* r) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;// wordwise copy from r (ok if it copies garbage after r)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;for (int i = 0; i &amp;lt; _relocbuf_size; i++) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;_relocbuf[i] = ((void**)r)[i];&lt;br/&gt;
&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
and that comment is just wrong, since the actual object could have been allocated close to the end of accessible memory, with a read beyond its real end potentially resulting in some kind of memory fault.&lt;br/&gt;
</description>
                <environment></environment>
        <key id="4890701">JDK-8160404</key>
            <summary>RelocationHolder constructors have bugs</summary>
                <type id="1" iconUrl="https://bugs.openjdk.org/secure/viewavatar?size=xsmall&amp;avatarId=14703&amp;avatarType=issuetype">Bug</type>
                                            <priority id="4" iconUrl="https://bugs.openjdk.org/images/jbsImages/p4.png">P4</priority>
                        <status id="5" iconUrl="https://bugs.openjdk.org/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="success"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="kbarrett">Kim Barrett</assignee>
                                    <reporter username="kbarrett">Kim Barrett</reporter>
                        <labels>
                            <label>c2</label>
                            <label>community-candidate</label>
                            <label>hs-comp-triaged</label>
                            <label>oracle-triage-12</label>
                    </labels>
                <created>Mon, 27 Jun 2016 14:58:03 -0700</created>
                <updated>Wed, 21 Dec 2022 17:22:20 -0800</updated>
                            <resolved>Fri, 16 Dec 2022 12:49:36 -0800</resolved>
                                    <version>9</version>
                    <version>10</version>
                    <version>11</version>
                    <version>17</version>
                    <version>20</version>
                                    <fixVersion>21</fixVersion>
                                    <component>hotspot</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>9</watches>
                                                                                                                <comments>
                            <comment id="14546192" author="dukebot" created="Fri, 16 Dec 2022 12:49:34 -0800"  >Changeset: bfa921ae&lt;br/&gt;
Author:    Kim Barrett &amp;lt;&lt;a href=&apos;mailto:kbarrett@openjdk.org&apos;&gt;kbarrett@openjdk.org&lt;/a&gt;&amp;gt;&lt;br/&gt;
Date:      2022-12-16 20:47:40 +0000&lt;br/&gt;
URL:       &lt;a href=&quot;https://git.openjdk.org/jdk/commit/bfa921ae6ce068c53dfa708d6d3d2cddbad5fc33&quot;&gt;https://git.openjdk.org/jdk/commit/bfa921ae6ce068c53dfa708d6d3d2cddbad5fc33&lt;/a&gt;&lt;br/&gt;
</comment>
                            <comment id="14544354" author="roboduke" created="Fri, 9 Dec 2022 14:11:31 -0800"  >A pull request was submitted for review.&lt;br/&gt;
URL: &lt;a href=&quot;https://git.openjdk.org/jdk/pull/11618&quot;&gt;https://git.openjdk.org/jdk/pull/11618&lt;/a&gt;&lt;br/&gt;
Date: 2022-12-09 22:00:59 +0000</comment>
                            <comment id="14478171" author="kbarrett" created="Fri, 18 Feb 2022 04:06:27 -0800"  >I tried removing the warning suppressions from &lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8187676&quot; title=&quot;Disable uninitialized warnings for two files until proper fix available&quot; class=&quot;issue-link&quot; data-issue-key=&quot;JDK-8187676&quot;&gt;&lt;strike&gt;JDK-8187676&lt;/strike&gt;&lt;/a&gt;, and there is no problem building with gcc10.3 on x64, for all of release, fastdebug, and slowdebug configurations. I think the warnings were (and still would be) correct, so don&amp;#39;t know why we&amp;#39;re not getting them anymore. I don&amp;#39;t know what might have changed in the meantime.&lt;br/&gt;
</comment>
                            <comment id="14476983" author="dlong" created="Mon, 14 Feb 2022 19:15:19 -0800"  >[~jrose], looking at the SCCS history, it looks like you may have added RelocationHolder.  The commit comment says &amp;quot;+NewRelocs&amp;quot;, which seems to be an old flag that enabled new relocation code and classes.  Do you happen to remember the reason for RelocationHolder?  Was it all about supporting stack allocation?</comment>
                            <comment id="14476969" author="dlong" created="Mon, 14 Feb 2022 13:45:18 -0800"  >I was assuming the reason for RelocationHolder was to avoid using the C++ heap and to support the few cases that are using polymorphism.  I would be surprised if the object lifetimes were complicated enough to require reference counts.  Relocation objects are temporary objects that we translate to/from the compressed persistent form.&lt;br/&gt;
&lt;br/&gt;
I think we should be able to remove RelocationHolder completely by rewriting problematic code.  For example,&lt;br/&gt;
&lt;br/&gt;
1822       RelocationHolder rspec = _optimized_virtual ? opt_virtual_call_Relocation::spec(method_index)&lt;br/&gt;
1823                                                   : static_call_Relocation::spec(method_index);&lt;br/&gt;
1824       emit_d32_reloc(cbuf, [...], rspec, [...]);&lt;br/&gt;
&lt;br/&gt;
could be changed to:&lt;br/&gt;
&lt;br/&gt;
if (_optimized_virtual) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;opt_virtual_call_Relocation reloc(method_index);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;emit_d32_reloc(cbuf, [...], reloc, [...]);&lt;br/&gt;
} else {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;static_call_Relocation reloc(method_index);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;emit_d32_reloc(cbuf, [...], reloc, [...]);&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
... if we really wanted to preserve stack allocation.  It should be even simpler if we allocated from a ResoureArea instead of the stack.&lt;br/&gt;
To minimize the amount of changes, we could keep RelocationHolder around as a handle for the Relocation*.</comment>
                            <comment id="14476683" author="kbarrett" created="Sun, 13 Feb 2022 00:58:10 -0800"  >I assume the problem with that is keeping track of the lifetime of the Relocation object, so we know when to delete it. I don&amp;#39;t know the code, so don&amp;#39;t know how hard that is, but I&amp;#39;ve always assumed it&amp;#39;s hard enough to justify the holder mechanism. The holder passes it around by copy. Another option would be refcounting the Relocation objects.  Indeed, RelocationHolder could probably be reimplemented as a reference counting handle.  Presumably someone thought the cost of reference counting would outweigh the copying cost by enough to matter.  Though getting the holder to be conforming C++ is not so easy either, and the existing code is a long way off.&lt;br/&gt;
</comment>
                            <comment id="14150918" author="dlong" created="Thu, 25 Jan 2018 15:23:52 -0800"  >This may be a dumb question, but why do we need RelocationHolder at all?  Can&amp;#39;t we just pass the Relocation around as a const Relocation *?</comment>
                            <comment id="14134327" author="rraghavan" created="Tue, 28 Nov 2017 04:26:53 -0800"  >related - &lt;a href=&quot;http://mail.openjdk.java.net/pipermail/hotspot-compiler-dev/2017-November/027719.html&quot;&gt;http://mail.openjdk.java.net/pipermail/hotspot-compiler-dev/2017-November/027719.html&lt;/a&gt;&lt;br/&gt;
</comment>
                            <comment id="14134308" author="rraghavan" created="Tue, 28 Nov 2017 03:30:22 -0800"  >Notes - &lt;br/&gt;
&lt;br/&gt;
01. Attached &amp;#39;8160404_03.diff&amp;#39; with last updates incorporating following review comments from Kim Barrett on earlier &amp;#39;8160404_02.diff&amp;#39;.&lt;br/&gt;
(adding notes, extracts from emails for record)&lt;br/&gt;
&lt;br/&gt;
=================================&lt;br/&gt;
&amp;gt; Changing rspec.reloc()-&amp;gt;type() to rspec.type().&lt;br/&gt;
&amp;gt; There are a few more occurences of that pattern in other files that should be updated.&lt;br/&gt;
&amp;gt; x86_32.ad / macroAssembler_s390.inlin.hpp / macroAssembler_aarch64.cpp&lt;br/&gt;
&lt;br/&gt;
-- Yes, done. &lt;br/&gt;
&lt;br/&gt;
=================================&lt;br/&gt;
&amp;gt; src/share/vm/code/relocInfo.hpp&lt;br/&gt;
&amp;gt;   837   new((RelocationHolder &amp;amp;) _relocbuf) Relocation();&lt;br/&gt;
&amp;gt; I think the cast to RelocationHolder&amp;amp; is wrong.  &lt;br/&gt;
&amp;gt; We&amp;#39;re really doing placement new of an as yet uninitialized _relocbuf here, and should just treat _relocbuf as memory.&lt;br/&gt;
&amp;gt; The &amp;quot;new&amp;quot; being referenced here should be the global placement new function, not Relocation::operator new, so it probably needs to be explicitly qualified, &lt;br/&gt;
&amp;gt; e.g. I think line 837 should be&lt;br/&gt;
&amp;gt;    ::new (_relocbuf) Relocation();&lt;br/&gt;
&amp;gt; or possibly better is to have Relocation also provide an overload for operator placement new, like&lt;br/&gt;
&amp;gt;    void* operator new(size_t size, void* p) throw() { return p; }&lt;br/&gt;
&amp;gt; I see that Hotspot contains a number of qualified ::new calls in order to dodge the operator new provided by our various allocation controlling base classes &lt;br/&gt;
&amp;gt; and get to the global placement new.  &lt;br/&gt;
&amp;gt; So using ::new on line 837 would be culturally consistent&lt;br/&gt;
&lt;br/&gt;
-- Added overloaded operator placement new in Relocation and used the same in no-arg constructor, RelocationHolder().&lt;br/&gt;
&lt;br/&gt;
=================================&lt;br/&gt;
&amp;gt; src/share/vm/code/relocInfo.hpp&lt;br/&gt;
&amp;gt; The various clone_into implementatoins are doing raw memory copies;&lt;br/&gt;
&amp;gt; they shouldn&amp;#39;t be.  Instead, they should be doing placement copies.&lt;br/&gt;
&amp;gt; Also, I think clone_into should take a void* rather than an array of void*.&lt;br/&gt;
&amp;gt; So, e.g. for DataRelocation, I think it should be something like&lt;br/&gt;
&amp;gt;    void clone_into(void* ptr, size_t size) const {&lt;br/&gt;
&amp;gt;      assert(sizeof(DataRelocation) &amp;lt;= size, &amp;quot;...&amp;quot;);&lt;br/&gt;
&amp;gt;      ::new (ptr) DataRelocation(*this);&lt;br/&gt;
&amp;gt;    }&lt;br/&gt;
&amp;gt; [Note again here the use of explicitly qualified global new.]&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&lt;br/&gt;
-- Yes changes the clone_into implementations also to use the added overloaded operator placement new of Relocation. &lt;br/&gt;
&lt;br/&gt;
=================================&lt;br/&gt;
&amp;gt; src/share/vm/asm/codeBuffer.cpp&lt;br/&gt;
&amp;gt;   393   end-&amp;gt;initialize(this, const_cast&amp;lt;Relocation*&amp;gt;(reloc));&lt;br/&gt;
&amp;gt; I really dislike this const_cast, but on a quick look it appears removing it and making things const-correct might propogate quite far.&lt;br/&gt;
&amp;gt; I&amp;#39;d be interested in finding out how bad it gets though.  If it really is excessive, then maybe a followup cleanup?&lt;br/&gt;
&lt;br/&gt;
-- Tried propagating the constness and please check the required usage of mutable now.&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
02. Though confirmed no build issues locally with attached &amp;#39;8160404_03.diff&amp;#39; changeset with existing gcc versions,&lt;br/&gt;
&amp;nbsp;&lt;br/&gt;
But Erik Helin helped confirm following warnings still present, with this 8160404_03.diff patch, &lt;br/&gt;
when building hotspot with gcc7 -&lt;br/&gt;
&lt;br/&gt;
&amp;gt;&amp;gt; tested to compile the patch with &lt;br/&gt;
&amp;quot;g++ (GCC) 7.2.1 20170915 (Red Hat 7.2.1-2)&amp;quot; on Fedora 26 &lt;br/&gt;
and unfortunately we still get the following warnings:&lt;br/&gt;
&lt;br/&gt;
[&lt;a href=&apos;mailto:edvbld@edvbld-personal&apos;&gt;edvbld@edvbld-personal&lt;/a&gt; hs]$ make hotspot&lt;br/&gt;
Building target &amp;#39;hotspot&amp;#39; in configuration &amp;#39;linux-x86_64-normal-server-release&amp;#39;&lt;br/&gt;
/home/edvbld/code/openjdk/10/hs/src/hotspot/cpu/x86/assembler_x86.cpp: In static member function &#8216;static Address Address::make_raw(int, int, int, int, relocInfo::relocType)&#8217;:&lt;br/&gt;
/home/edvbld/code/openjdk/10/hs/src/hotspot/cpu/x86/assembler_x86.cpp:199:12: error: &#8216;*((void*)&amp;amp; rspec +32)&#8217; may be used uninitialized in this function [-Werror=maybe-uninitialized]&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return madr;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;^~~~&lt;br/&gt;
/home/edvbld/code/openjdk/10/hs/src/hotspot/cpu/x86/assembler_x86.cpp:199:12: error: &#8216;*((void*)&amp;amp; rspec +24)&#8217; may be used uninitialized in this function [-Werror=maybe-uninitialized]&lt;br/&gt;
/home/edvbld/code/openjdk/10/hs/src/hotspot/cpu/x86/assembler_x86.cpp:199:12: error: &#8216;*((void*)&amp;amp; rspec +16)&#8217; may be used uninitialized in this function [-Werror=maybe-uninitialized]&lt;br/&gt;
cc1plus: all warnings being treated as errors &lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
03. Latest comments from Kim for the record - &lt;br/&gt;
(not able to make progress on this yet)&lt;br/&gt;
&lt;br/&gt;
---------&lt;br/&gt;
&amp;quot; Looks like we don&amp;#39;t have an assignment operator for RelocationHolder, but need one. &lt;br/&gt;
Which suggests we also need a copy constructor.. &lt;br/&gt;
Something like this, perhaps?&lt;br/&gt;
&lt;br/&gt;
RelocationHolder&amp;amp; RelocationHolder::operator=(const RelocationHolder&amp;amp; x) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;if (this != &amp;amp;x) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;reloc()-&amp;gt;~Relocation();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;x.clone_into(_relocbuf, sizeof(_relocbuf));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return *this;&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
RelocationHolder::RelocationHolder(const RelocationHolder&amp;amp; x) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;x.reloc()-&amp;gt;clone_into(_relocbuf, sizeof(_relocbuf));&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
Also, I think Relocation should not have public (implicit) copy constructor or assignment operator.&lt;br/&gt;
I also just noticed that we&#8217;re missing a virtual destructor for Relocator, which we definitely need.&lt;br/&gt;
But this is feeling yet more contorted.  &lt;br/&gt;
It seems like there ought to be a better way, that is still correct.&lt;br/&gt;
Unfortunately, I don&amp;#39;t have time to think about it right now, &lt;br/&gt;
but I feel like much of the use of operator new in these classes is ill-conceived.&lt;br/&gt;
&lt;br/&gt;
Relocator/Relocation/&lt;br/&gt;
I&#8217;ve just been assuming its destructor was virtual, since it always should have been.&lt;br/&gt;
I really wish we could turn on the appropriate gcc warning flag &lt;br/&gt;
(-Wnon-virtual-dtor). &amp;quot;&lt;br/&gt;
-----------&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
04. Please note for now plan to defer this &lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8160404&quot; title=&quot;RelocationHolder constructors have bugs&quot; class=&quot;issue-link&quot; data-issue-key=&quot;JDK-8160404&quot;&gt;&lt;strike&gt;JDK-8160404&lt;/strike&gt;&lt;/a&gt; task to jdk11.&lt;br/&gt;
&lt;br/&gt;
Understood the related &lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8187676&quot; title=&quot;Disable uninitialized warnings for two files until proper fix available&quot; class=&quot;issue-link&quot; data-issue-key=&quot;JDK-8187676&quot;&gt;&lt;strike&gt;JDK-8187676&lt;/strike&gt;&lt;/a&gt; is also blocked because of this &lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8160404&quot; title=&quot;RelocationHolder constructors have bugs&quot; class=&quot;issue-link&quot; data-issue-key=&quot;JDK-8160404&quot;&gt;&lt;strike&gt;JDK-8160404&lt;/strike&gt;&lt;/a&gt;.&lt;br/&gt;
Since 8160404 is taking more time, if it is okay, &lt;br/&gt;
as Erik already suggested, can we please go ahead and disable the gcc warnings at the moment as part of 8187676 fix &lt;br/&gt;
&amp;nbsp;&amp;nbsp;and re-enable latest as part of 8160404 patch.&lt;br/&gt;
&lt;br/&gt;
ref : &lt;a href=&quot;http://mail.openjdk.java.net/pipermail/hotspot-compiler-dev/2017-September/027138.html&quot;&gt;http://mail.openjdk.java.net/pipermail/hotspot-compiler-dev/2017-September/027138.html&lt;/a&gt;&lt;br/&gt;
&lt;br/&gt;
</comment>
                            <comment id="14116539" author="rraghavan" created="Tue, 12 Sep 2017 06:12:15 -0700"  >Found no issues with testing - jprt (-testset hotspot) and RBT (--job hs-precheckin-comp) for all above suggested, attached changes.</comment>
                            <comment id="14113135" author="rraghavan" created="Mon, 28 Aug 2017 07:26:06 -0700"  >wrt to above comments - &lt;br/&gt;
&amp;nbsp;&lt;a href=&quot;https://bugs.openjdk.java.net/browse/JDK-8160404?focusedCommentId=14113088&amp;page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-14113088&quot;&gt;https://bugs.openjdk.java.net/browse/JDK-8160404?focusedCommentId=14113088&amp;amp;page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-14113088&lt;/a&gt;&lt;br/&gt;
&lt;br/&gt;
trying out fix proposal changes as per attached - 8160404_02.diff&lt;br/&gt;
&lt;br/&gt;
Notes - &lt;br/&gt;
&lt;br/&gt;
[1]. &amp;#39;changes in operator Relocation::new(), RelocationHolder::RelocationHolder()&amp;#39;&lt;br/&gt;
--- [relocInfo.hpp]&lt;br/&gt;
==========================&lt;br/&gt;
-  void* operator new(size_t size, const RelocationHolder&amp;amp; holder) throw() {&lt;br/&gt;
+  void* operator new(size_t size, RelocationHolder&amp;amp; holder) throw() {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if (size &amp;gt; sizeof(holder._relocbuf)) guarantee_size();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;assert((void* const *)holder.reloc() == &amp;amp;holder._relocbuf[0], &amp;quot;ptrs must agree&amp;quot;);&lt;br/&gt;
-    return holder.reloc();&lt;br/&gt;
+    holder.reloc()-&amp;gt;~Relocation();&lt;br/&gt;
+    return holder._relocbuf;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
....................&lt;br/&gt;
&amp;nbsp;&amp;nbsp;inline RelocationHolder::RelocationHolder() {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// initialize the vtbl, just to keep things type-safe&lt;br/&gt;
-  new(*this) Relocation();&lt;br/&gt;
+  STATIC_ASSERT(sizeof(Relocation) &amp;lt;= sizeof(_relocbuf));&lt;br/&gt;
+  new((RelocationHolder &amp;amp;) _relocbuf) Relocation();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
==========================&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
[2]. &amp;#39;RelocationHolder::reloc() related&amp;#39;&lt;br/&gt;
trying changes -&lt;br/&gt;
--- [relocInfo.hpp]&lt;br/&gt;
==========================&lt;br/&gt;
-  Relocation* reloc() const { return (Relocation*) &amp;amp;_relocbuf[0]; }&lt;br/&gt;
+  Relocation* reloc() { return (Relocation*)_relocbuf; }&lt;br/&gt;
+  const Relocation* reloc() const { return (const Relocation*)_relocbuf; }&lt;br/&gt;
==========================&lt;br/&gt;
&lt;br/&gt;
and related following type changes required -&lt;br/&gt;
.e.g.:&lt;br/&gt;
--- [relocInfo.hpp]&lt;br/&gt;
==========================&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;public:&lt;br/&gt;
-  virtual relocInfo::relocType type()            { return relocInfo::none; }&lt;br/&gt;
+  virtual relocInfo::relocType type() const      { return relocInfo::none; }&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// is it a call instruction?&lt;br/&gt;
-  virtual bool is_call()                         { return false; }&lt;br/&gt;
+  virtual bool is_call() const                   { return false; }&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// is it a data movement instruction?&lt;br/&gt;
-  virtual bool is_data()                         { return false; }&lt;br/&gt;
+  virtual bool is_data() const                   { return false; }&lt;br/&gt;
...............&lt;br/&gt;
&amp;nbsp;&amp;nbsp;class DataRelocation : public Relocation {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;public:&lt;br/&gt;
-  bool          is_data()                      { return true; }&lt;br/&gt;
+  bool          is_data() const                { return true; }&lt;br/&gt;
...............&lt;br/&gt;
&amp;nbsp;&amp;nbsp;class CallRelocation : public Relocation {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;public:&lt;br/&gt;
-  bool is_call() { return true; }&lt;br/&gt;
+  bool is_call() const { return true; }&lt;br/&gt;
...............&lt;br/&gt;
&amp;nbsp;&amp;nbsp;class oop_Relocation : public DataRelocation {&lt;br/&gt;
-  relocInfo::relocType type() { return relocInfo::oop_type; }&lt;br/&gt;
+  relocInfo::relocType type() const { return relocInfo::oop_type; }&lt;br/&gt;
...............&lt;br/&gt;
==========================&lt;br/&gt;
&lt;br/&gt;
--- [assembler_x86.cpp]&lt;br/&gt;
==========================&lt;br/&gt;
-  Relocation* r = rspec.reloc();&lt;br/&gt;
+  const Relocation* r = rspec.reloc();&lt;br/&gt;
...........&lt;br/&gt;
-  emit_data(disp, rspec.reloc(), call32_operand);&lt;br/&gt;
+  emit_data(disp, rspec, call32_operand);&lt;br/&gt;
==========================&lt;br/&gt;
&lt;br/&gt;
--- [x86_64.ad]&lt;br/&gt;
==========================&lt;br/&gt;
-  if (rspec.reloc()-&amp;gt;type() == relocInfo::oop_type &amp;amp;&amp;amp;&lt;br/&gt;
+  if (rspec.type() == relocInfo::oop_type &amp;amp;&amp;amp;&lt;br/&gt;
.............&lt;br/&gt;
==========================&lt;br/&gt;
&lt;br/&gt;
--- [codeBuffer.cpp]&lt;br/&gt;
==========================&lt;br/&gt;
&amp;nbsp;&amp;nbsp;void CodeSection::relocate(address at, RelocationHolder const&amp;amp; spec, int format) {&lt;br/&gt;
..........&lt;br/&gt;
-  Relocation* reloc = spec.reloc();&lt;br/&gt;
+  const Relocation* reloc = spec.reloc();&lt;br/&gt;
..........&lt;br/&gt;
-  end-&amp;gt;initialize(this, reloc);&lt;br/&gt;
+  end-&amp;gt;initialize(this, const_cast&amp;lt;Relocation*&amp;gt;(reloc));&lt;br/&gt;
==========================&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
[3]. &amp;#39;fixing RelocationHolder(Relocation*)&amp;#39;&lt;br/&gt;
&lt;br/&gt;
[3.1]. Adding clone_into()&lt;br/&gt;
.e.g.:&lt;br/&gt;
--- [relocInfo.hpp]&lt;br/&gt;
==========================&lt;br/&gt;
+  // used for creating RelocationHolder from Relocation object&lt;br/&gt;
+  virtual void clone_into(void* ptr[], size_t size) const;&lt;br/&gt;
+&lt;br/&gt;
.......&lt;br/&gt;
.......&lt;br/&gt;
&amp;nbsp;&amp;nbsp;class DataRelocation : public Relocation {&lt;br/&gt;
........&lt;br/&gt;
+  void clone_into(void* ptr[], size_t size) const {&lt;br/&gt;
+    guarantee(sizeof(DataRelocation) &amp;lt;= size, &amp;quot;Make _relocbuf bigger!&amp;quot;);&lt;br/&gt;
+    for (unsigned int i = 0; i &amp;lt; sizeof(DataRelocation); i++) {&lt;br/&gt;
+      ptr[i] = ((void**)this)[i];&lt;br/&gt;
+    }&lt;br/&gt;
+  }&lt;br/&gt;
.......&lt;br/&gt;
.......&lt;br/&gt;
&amp;nbsp;&amp;nbsp;class CallRelocation : public Relocation {&lt;br/&gt;
........&lt;br/&gt;
+  void clone_into(void* ptr[], size_t size) const {&lt;br/&gt;
+    guarantee(sizeof(CallRelocation) &amp;lt;= size, &amp;quot;Make _relocbuf bigger!&amp;quot;);&lt;br/&gt;
+    for (unsigned int i = 0; i &amp;lt; sizeof(CallRelocation); i++) {&lt;br/&gt;
+      ptr[i] = ((void**)this)[i];&lt;br/&gt;
+    }&lt;br/&gt;
+  }&lt;br/&gt;
.........&lt;br/&gt;
==========================&lt;br/&gt;
&lt;br/&gt;
--- [relocInfo.cpp]&lt;br/&gt;
==========================&lt;br/&gt;
+void Relocation::clone_into(void* ptr[], size_t size) const {&lt;br/&gt;
+  ShouldNotReachHere();&lt;br/&gt;
+}&lt;br/&gt;
+&lt;br/&gt;
==========================&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&amp;lt;OR&amp;gt;&lt;br/&gt;
[3.2]. Remove &amp;#39;RelocationHolder(Relocation*)&amp;#39; if it is unused!&lt;br/&gt;
Another proposal - Can we altogether delete this arg-constructor of RelocationHolder (please tell me if I am missing something here)&lt;br/&gt;
--- [relocInfo.hpp]&lt;br/&gt;
==========================&lt;br/&gt;
-  inline RelocationHolder(Relocation* r);   // make a copy&lt;br/&gt;
..........&lt;br/&gt;
-inline RelocationHolder::RelocationHolder(Relocation* r) {&lt;br/&gt;
-  // wordwise copy from r (ok if it copies garbage after r)&lt;br/&gt;
-  for (int i = 0; i &amp;lt; _relocbuf_size; i++) {&lt;br/&gt;
-    _relocbuf[i] = ((void**)r)[i];&lt;br/&gt;
-  }&lt;br/&gt;
-}&lt;br/&gt;
==========================&lt;br/&gt;
&lt;br/&gt;
with following changes?&lt;br/&gt;
--- [src/cpu/sparc/vm/macroAssembler_sparc.hpp]&lt;br/&gt;
==========================&lt;br/&gt;
class AddressLiteral VALUE_OBJ_CLASS_SPEC {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;......&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;RelocationHolder _rspec;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;.......&lt;br/&gt;
-  AddressLiteral() : _address(NULL), _rspec(NULL) {}&lt;br/&gt;
+  AddressLiteral() : _address(NULL), _rspec() {}&lt;br/&gt;
==========================&lt;br/&gt;
&lt;br/&gt;
--- [src/cpu/x86/vm/assembler_x86.cpp]&lt;br/&gt;
==========================&lt;br/&gt;
void Assembler::jmp_literal(address dest, RelocationHolder const&amp;amp; rspec) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;.........&lt;br/&gt;
-  emit_data(disp, rspec.reloc(), call32_operand);&lt;br/&gt;
+  emit_data(disp, rspec, call32_operand);&lt;br/&gt;
==========================&lt;br/&gt;
&lt;br/&gt;
--- [src/share/vm/code/relocInfo.hpp]&lt;br/&gt;
==========================&lt;br/&gt;
class trampoline_stub_Relocation : public Relocation {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;.......&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;static RelocationHolder spec(address static_call) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;RelocationHolder rh = newHolder();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return (new (rh) trampoline_stub_Relocation(static_call));&lt;br/&gt;
-   return (new (rh) trampoline_stub_Relocation(static_call));&lt;br/&gt;
+   new (rh) trampoline_stub_Relocation(static_call);&lt;br/&gt;
+   return rh;&lt;br/&gt;
==========================&lt;br/&gt;
</comment>
                            <comment id="14113088" author="rraghavan" created="Mon, 28 Aug 2017 03:54:35 -0700"  >Thanks to review pointers from Kim Barrett, identified following as changes to be done for complete fix for RelocationHolder / Relocation implementation.&lt;br/&gt;
(Extracts from email threads)&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;[1]. &amp;#39;changes in operator Relocation::new(), RelocationHolder::RelocationHolder()&amp;#39;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;[2]. &amp;#39;RelocationHolder::reloc() related&amp;#39;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;[3]. &amp;#39;fixing RelocationHolder(Relocation*)&amp;#39;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;[3.1]. Adding clone_into()  &amp;lt;OR&amp;gt;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;[3.2]. Remove &amp;#39;RelocationHolder(Relocation*)&amp;#39; if it is unused!&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
[1]. &amp;#39;changes in operator Relocation::new(), RelocationHolder::RelocationHolder()&amp;#39;&lt;br/&gt;
&amp;gt; There are several problems here:&lt;br/&gt;
&amp;gt;     void* operator new(size_t size, const RelocationHolder&amp;amp; holder) throw() {&lt;br/&gt;
&amp;gt;       if (size &amp;gt; sizeof(holder._relocbuf)) guarantee_size();&lt;br/&gt;
&amp;gt;       assert((void* const *)holder.reloc() == &amp;amp;holder._relocbuf[0], &amp;quot;ptrs must agree&amp;quot;);&lt;br/&gt;
&amp;gt;       return holder.reloc();&lt;br/&gt;
&amp;gt;     }&lt;br/&gt;
&amp;gt; This is presently called in two very different contexts.&lt;br/&gt;
&amp;gt; (1) RelocationHolder rh = newHolder(); new (rh) &amp;lt;relocation_class&amp;gt;(...);&lt;br/&gt;
&amp;gt; In this case, the holder is a fully constructed RelocationHolder&lt;br/&gt;
&amp;gt; object, with holder.reloc() returning a pointer to a fully constructed&lt;br/&gt;
&amp;gt; Relocation object.  Using that pointer as-is will result in&lt;br/&gt;
&amp;gt; constructing the new Relocation over the existing one, which is&lt;br/&gt;
&amp;gt; undefined behavior.  The old object should be destroyed before reusing&lt;br/&gt;
&amp;gt; the memory for the new object.&lt;br/&gt;
&amp;gt; (2) new (*this) Relocation() -- in RelocationHolder()&lt;br/&gt;
&amp;gt; In this case, the holder is being constructed.  holder.reloc() is&lt;br/&gt;
&amp;gt; returning uninitialized memory cast to Relocation*.&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; In (1) we need Relocation::operator new() to call the destructor for&lt;br/&gt;
&amp;gt; the object returned by holder.reloc().  In (2) we can&amp;#39;t call that&lt;br/&gt;
&amp;gt; destructor because there&amp;#39;s no object there to destroy.&lt;br/&gt;
&amp;gt; My suggestion for (2) is that RelocationHolder() be changed to&lt;br/&gt;
&amp;gt;    RelocationHolder::RelocationHolder() {&lt;br/&gt;
&amp;gt;      STATIC_ASSERT(sizeof(Relocation) &amp;lt;= sizeof(_relocbuf));&lt;br/&gt;
&amp;gt;      new (_relocbuf) Relocation();&lt;br/&gt;
&amp;gt;    }&lt;br/&gt;
&amp;gt; To then deal with (1), change the end of Relocation::operator new() to&lt;br/&gt;
&amp;gt;    holder.reloc()-&amp;gt;~Relocation();&lt;br/&gt;
&amp;gt;    return holder._relocbuf;&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
[2]. &amp;#39;RelocationHolder::reloc() related&amp;#39;&lt;br/&gt;
&amp;gt; Another problem in that operator new definition is that&lt;br/&gt;
&amp;gt; RelocationHolder::reloc() is silently const-discarding, which is&lt;br/&gt;
&amp;gt; itself problematic.  So we have a const holder argument that is having&lt;br/&gt;
&amp;gt; it&amp;#39;s internals modified out from under it, which is bad.&lt;br/&gt;
&amp;gt; I suggest there should be two members:&lt;br/&gt;
&amp;gt;    Relocation* reloc() { return (Relocation*)_relocbuf; }&lt;br/&gt;
&amp;gt;    const Relocation* reloc() const { return (const Relocation*)_relocbuf; }&lt;br/&gt;
&amp;gt; and fix Relocation::operator new() to have the holder parameter be a&lt;br/&gt;
&amp;gt; non-const reference rather than a const reference.&lt;br/&gt;
&amp;gt; I haven&amp;#39;t looked to see if there are other places that would be&lt;br/&gt;
&amp;gt; affected by proper const handling by reloc(), so there might be&lt;br/&gt;
&amp;gt; additional changes needed with that.&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
[3]. &amp;#39;fixing RelocationHolder(Relocation*)&amp;#39;&lt;br/&gt;
&lt;br/&gt;
[3.1]. Adding clone_into()&lt;br/&gt;
&amp;gt; We still have the problem of RelocationHolder(Relocation*).  This is&lt;br/&gt;
&amp;gt; presently assuming (1) all classes derived from Relocation are trivialy&lt;br/&gt;
&amp;gt; copyable, and (2) it is okay to read beyond the end of a Relocation&lt;br/&gt;
&amp;gt; object. The first might be true, but isn&amp;#39;t a good assumption. The&lt;br/&gt;
&amp;gt; second is not true.&lt;br/&gt;
&amp;gt; To deal with this, I suggest adding a clone_into virtual function to&lt;br/&gt;
&amp;gt; Relocation, e.g. something like&lt;br/&gt;
&amp;gt;    virtual void clone_into(void* ptr, size_t size) const.&lt;br/&gt;
&amp;gt; Each subclass implements this as a placement new copy construct of&lt;br/&gt;
&amp;gt; itself into ptr, after first verifying that size &amp;gt;= sizeof the&lt;br/&gt;
&amp;gt; subclass.  Then RelocationHolder(Relocation* reloc) calls&lt;br/&gt;
&amp;gt;    reloc-&amp;gt;clone_into(_relocbuf, sizeof(_relocbuf));&lt;br/&gt;
&lt;br/&gt;
&amp;lt;OR&amp;gt;&lt;br/&gt;
[3.2]. Remove &amp;#39;RelocationHolder(Relocation*)&amp;#39; if it is unused!&lt;br/&gt;
Another proposal - Can we altogether delete this arg-constructor of RelocationHolder if it is unused! &lt;br/&gt;
</comment>
                            <comment id="14086757" author="thartmann" created="Mon, 22 May 2017 02:56:00 -0700"  >Hi Rahul,&lt;br/&gt;
&lt;br/&gt;
please have a look if your time allows. Should be straight forward to fix.&lt;br/&gt;
&lt;br/&gt;
Thanks,&lt;br/&gt;
Tobias</comment>
                            <comment id="14086755" author="thartmann" created="Mon, 22 May 2017 02:54:48 -0700"  >ILW = Potential copy of unaccessible memory, never showed up, no workaround = MLH = P4</comment>
                            <comment id="14086753" author="thartmann" created="Mon, 22 May 2017 02:53:10 -0700"  >Yes, I agree that copying after &amp;#39;r&amp;#39; is a bug. Converting.</comment>
                            <comment id="13966451" author="dholmes" created="Wed, 29 Jun 2016 00:16:25 -0700"  >Isn&amp;#39;t copying after &amp;#39;r&amp;#39; a bug?</comment>
                            <comment id="13966169" author="kbarrett" created="Tue, 28 Jun 2016 11:34:05 -0700"  >An earlier version of the report described what I mistakenly thought was a bug.</comment>
                            <comment id="13966134" author="dpochepk" created="Tue, 28 Jun 2016 11:00:47 -0700"  >[~kbarrett] Isn&amp;#39;t it an enhancement?</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10002">
                    <name>Duplicate</name>
                                            <outwardlinks description="duplicates">
                                        <issuelink>
            <issuekey id="4890614">JDK-8160354</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                            <issuelinktype id="10003">
                    <name>Relates</name>
                                            <outwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="4890551">JDK-8160310</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="4940108">JDK-8187676</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="5089858">JDK-8298912</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="5030080">JDK-8253311</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="5088567">JDK-8297830</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="5089859">JDK-8298913</issuekey>
        </issuelink>
                            </outwardlinks>
                                                                <inwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="4890614">JDK-8160354</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="5090026">JDK-8299022</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="72104" name="8160404_02.diff" size="15321" author="rraghavan" created="Mon, 28 Aug 2017 07:26:43 -0700"/>
                            <attachment id="73778" name="8160404_03.diff" size="26841" author="rraghavan" created="Tue, 28 Nov 2017 02:24:58 -0800"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_10000" key="com.atlassian.jira.plugin.system.customfieldtypes:multiselect">
                        <customfieldname>CPU</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="17008"><![CDATA[generic]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_11700" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_10600" key="com.oracle.jira.javabugsystem-jira-plugin:jbs-fixedBackportedCustomfield">
                        <customfieldname>Fixed</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                            <customfield id="customfield_10005" key="com.atlassian.jira.plugin.system.customfieldtypes:multiselect">
                        <customfieldname>OS</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="17010"><![CDATA[generic]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                            <customfield id="customfield_11100" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i2234v:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_11004" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10006" key="com.atlassian.jira.plugin.system.customfieldtypes:select">
                        <customfieldname>Resolved In Build</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="17305"><![CDATA[b03]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10008" key="com.oracle.jira.jira-subcomponent-plugin:oracle-subComponentField">
                        <customfieldname>Subcomponent</customfieldname>
                        <customfieldvalues>
                             <customfieldvalue key="208"><![CDATA[compiler]]></customfieldvalue> 
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_10601" key="com.oracle.jira.javabugsystem-jira-plugin:jbs-targetBackportedCustomfield">
                        <customfieldname>Targeted</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    </customfields>
    </item>
</channel>
</rss>