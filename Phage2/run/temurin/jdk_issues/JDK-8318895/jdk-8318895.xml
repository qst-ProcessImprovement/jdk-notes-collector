<!-- 
RSS generated by JIRA (9.12.27#9120027-sha1:edc4490121e366e9e7bd2213d532dbe7e028fc5d) at Tue Sep 30 10:37:29 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>Java Bug System</title>
    <link>https://bugs.openjdk.org</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-us</language>    <build-info>
        <version>9.12.27</version>
        <build-number>9120027</build-number>
        <build-date>02-09-2025</build-date>
    </build-info>


<item>
            <title>[JDK-8318895] Deoptimization results in incorrect lightweight locking stack</title>
                <link>https://bugs.openjdk.org/browse/JDK-8318895</link>
                <project id="10100" key="JDK">JDK</project>
                    <description>While working on recursive-locking support for lightweight locking (-XX:LockingMode=2), we hit an assert that we have an inconsistent lock stack.&lt;br/&gt;
&lt;br/&gt;
One of the problematic tests is the following:&lt;br/&gt;
```&lt;br/&gt;
class EARelockingArgEscapeLWLockedInCalleeFrame_2Target extends EATestCaseBaseTarget {&lt;br/&gt;
...&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public void dontinline_testMethod() {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;XYVal l1 = new XYVal(1, 1);       // ArgEscape&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;XYVal l2 = new XYVal(4, 2);       // NoEscape, scalar replaced&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;synchronized (l1) {                   // eliminated&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;synchronized (l2) {               // eliminated&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;l1.dontinline_sync_method(this);  // l1 escapes&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;iResult = l2.x + l2.y;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
```&lt;br/&gt;
&lt;br/&gt;
The test runs the above method enough time to for it to get C2 compiled. Then it attaches a debugger and adds a breakpoint deeper inside dontlinine_sync_method.&lt;br/&gt;
&lt;br/&gt;
What we see in gdb is that `l1` is an existing object that has been pushed onto the deoptee thread&amp;#39;s locking stack because of the dontinline_sync_method call. We then try to &amp;quot;replay&amp;quot; `synchronized (l1)` and `synchronized (l2)` in Deoptimization::relock_objects. This gives us the incorrect lock order [l1, l1, l2] while the actual code has the [l1, l2, l1] lock order. This then messes up the lock stack in the unlock path when we perform our recursive lock handling.&lt;br/&gt;
&lt;br/&gt;
The lightweight code in openjdk/jdk works because the recursive lock gets inflated and removed from the lock stack. However, I can get the upstream lightweight locking to assert by removing the recursive locking in the test case:&lt;br/&gt;
&lt;br/&gt;
```&lt;br/&gt;
class EARelockingArgEscapeLWLockedInCalleeFrame_2Target extends EATestCaseBaseTarget {&lt;br/&gt;
...&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public void dontinline_testMethod() {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;XYVal l1 = new XYVal(1, 1);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;XYVal l2 = new XYVal(4, 2);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;XYVal l3 = new XYVal(5, 3);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;synchronized (l1) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;synchronized (l2) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;l3.dontinline_sync_method(this);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;iResult = l2.x + l2.y;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
```&lt;br/&gt;
&lt;br/&gt;
This asserts with the following:&lt;br/&gt;
```&lt;br/&gt;
#  Internal Error (/home/stefank/git/jdk/open/src/hotspot/share/runtime/lockStack.inline.hpp:86), pid=265437, tid=265440&lt;br/&gt;
#  assert(contains(o)) failed: entry must be present: 0x00000000ffa00130&lt;br/&gt;
...&lt;br/&gt;
V  [libjvm.so+0x1743709]  LockStack::remove(oop)+0x3e9  (lockStack.inline.hpp:86)&lt;br/&gt;
V  [libjvm.so+0x173f78d]  ObjectSynchronizer::exit(oop, BasicLock*, JavaThread*)+0x2fd  (synchronizer.cpp:590)&lt;br/&gt;
V  [libjvm.so+0xe7667c]  InterpreterRuntime::monitorexit(BasicObjectLock*)+0x18c  (interpreterRuntime.cpp:779)&lt;br/&gt;
j  EARelockingArgEscapeLWLockedInCalleeFrame_2Target.dontinline_testMethod()V+47&lt;br/&gt;
j  EATestCaseBaseTarget.run()V+64</description>
                <environment></environment>
        <key id="5113290">JDK-8318895</key>
            <summary>Deoptimization results in incorrect lightweight locking stack</summary>
                <type id="1" iconUrl="https://bugs.openjdk.org/secure/viewavatar?size=xsmall&amp;avatarId=14703&amp;avatarType=issuetype">Bug</type>
                                            <priority id="3" iconUrl="https://bugs.openjdk.org/images/jbsImages/p3.png">P3</priority>
                        <status id="5" iconUrl="https://bugs.openjdk.org/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="success"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="rkennke">Roman Kennke</assignee>
                                    <reporter username="stefank">Stefan Karlsson</reporter>
                        <labels>
                            <label>LM_LIGHTWEIGHT</label>
                            <label>amazon-interest</label>
                            <label>deopt</label>
                            <label>jdk21u-fix-SQE-ok</label>
                            <label>jdk21u-fix-request</label>
                            <label>jdk21u-fix-yes</label>
                            <label>lilliput</label>
                            <label>sync</label>
                    </labels>
                <created>Thu, 26 Oct 2023 04:49:01 -0700</created>
                <updated>Wed, 10 Jul 2024 10:18:02 -0700</updated>
                            <resolved>Mon, 13 Nov 2023 07:05:30 -0800</resolved>
                                    <version>21</version>
                    <version>22</version>
                    <version>repo-lilliput-17</version>
                    <version>repo-lilliput-21</version>
                                    <fixVersion>22</fixVersion>
                                    <component>hotspot</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>14</watches>
                                                                                                                <comments>
                            <comment id="14663779" author="roboduke" created="Tue, 9 Apr 2024 00:21:46 -0700"  >A pull request was submitted for review.&lt;br/&gt;
URL: &lt;a href=&quot;https://git.openjdk.org/lilliput-jdk17u/pull/77&quot;&gt;https://git.openjdk.org/lilliput-jdk17u/pull/77&lt;/a&gt;&lt;br/&gt;
Date: 2024-04-09 07:17:10 +0000</comment>
                            <comment id="14644617" author="dholmes" created="Mon, 29 Jan 2024 18:59:06 -0800"  >This fix seems incorrect - see &lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8324881&quot; title=&quot;ObjectSynchronizer::inflate(Thread* current...) is invoked for non-current thread &quot; class=&quot;issue-link&quot; data-issue-key=&quot;JDK-8324881&quot;&gt;&lt;strike&gt;JDK-8324881&lt;/strike&gt;&lt;/a&gt;.&lt;br/&gt;
&lt;br/&gt;
Correction: I see now that this fix simply duplicates pre-existing &amp;quot;brokenness&amp;quot;.</comment>
                            <comment id="14628823" author="roboduke" created="Fri, 24 Nov 2023 04:04:30 -0800"  >[jdk21u-fix-request] Approval Request from Roman Kennke&lt;br/&gt;
This change fixes a critical bug in lightweight-locking. It has been in mainline for more than 2 weeks and has not accrued any bug-tail. The fix only affects lightweight locking code-paths. Lightweight locking has been introduced in jdk21, but is not enabled by default.</comment>
                            <comment id="14628821" author="roboduke" created="Fri, 24 Nov 2023 03:57:14 -0800"  >A pull request was submitted for review.&lt;br/&gt;
URL: &lt;a href=&quot;https://git.openjdk.org/jdk21u/pull/400&quot;&gt;https://git.openjdk.org/jdk21u/pull/400&lt;/a&gt;&lt;br/&gt;
Date: 2023-11-24 11:50:40 +0000</comment>
                            <comment id="14625708" author="dcubed" created="Mon, 13 Nov 2023 07:04:58 -0800"  >Fix was pushed while main issue was targeted to &amp;#39;23&amp;#39;. Reset the main issue to fixed in &amp;#39;22&amp;#39; and copied the Robo Duke entry here.</comment>
                            <comment id="14625707" author="dcubed" created="Mon, 13 Nov 2023 07:04:23 -0800"  >Dukebot added a comment - 2 days ago&lt;br/&gt;
Changeset: ea1ffa34&lt;br/&gt;
Author: Roman Kennke &amp;lt;&lt;a href=&apos;mailto:rkennke@openjdk.org&apos;&gt;rkennke@openjdk.org&lt;/a&gt;&amp;gt;&lt;br/&gt;
Date: 2023-11-10 15:28:27 +0000&lt;br/&gt;
URL: &lt;a href=&quot;https://git.openjdk.org/jdk/commit/ea1ffa34192448317ce9a61a3588b0dee3a2ef44&quot;&gt;https://git.openjdk.org/jdk/commit/ea1ffa34192448317ce9a61a3588b0dee3a2ef44&lt;/a&gt;</comment>
                            <comment id="14625356" author="dlong" created="Thu, 9 Nov 2023 14:42:12 -0800"  >OK, that makes sense.  Thanks.</comment>
                            <comment id="14625348" author="rrich" created="Thu, 9 Nov 2023 13:40:17 -0800"  >&amp;gt; ... Storing it into a static ...&lt;br/&gt;
&lt;br/&gt;
That store is done using JVMTI. Escape analysis ignores JVMTI. It does so for good reason because every object can escape through JVMTI.&lt;br/&gt;
&lt;br/&gt;
&lt;a href=&quot;https://github.com/reinrich/jdk/commit/b72b3b3d7d1b5927811ae49e3ddea01d298dcb85&quot;&gt;https://github.com/reinrich/jdk/commit/b72b3b3d7d1b5927811ae49e3ddea01d298dcb85&lt;/a&gt; is a test case that would fail without eager relocking.&lt;br/&gt;
L1722 does the store into the field (in that example it&amp;#39;s not static).&lt;br/&gt;
With &lt;a href=&quot;https://github.com/reinrich/jdk/commit/f7a90c13e27e9fe38c892f069bd8d58484f59445&quot;&gt;https://github.com/reinrich/jdk/commit/f7a90c13e27e9fe38c892f069bd8d58484f59445&lt;/a&gt; you can disable eager relocking with -XX:+UseNewCode.&lt;br/&gt;
&lt;br/&gt;
The following will provoke the failure:&lt;br/&gt;
make test TEST=&amp;quot;test/jdk/com/sun/jdi/EATests.java&amp;quot; TEST_VM_OPTS=&amp;quot;-XX:+UseNewCode&amp;quot;&lt;br/&gt;
</comment>
                            <comment id="14625322" author="dlong" created="Thu, 9 Nov 2023 11:24:37 -0800"  >I don&amp;#39;t think that scenario is possible, but if it was possible, it could happen without JVMTI being involved.&lt;br/&gt;
In order for the lock to be eliminated, the object can&amp;#39;t escape.  Storing it into a static so another thread can find it is the definition of escape.</comment>
                            <comment id="14625174" author="rrich" created="Thu, 9 Nov 2023 02:34:50 -0800"  >&amp;gt; &amp;gt; The eager relocking is needed because it has to be done before the object escapes the current thread through JVMTI.&lt;br/&gt;
&amp;gt; &lt;br/&gt;
&amp;gt; [~rrich] I can see why we need to allocate the eliminated locals so JVMTI to access them, but I don&amp;#39;t see why we need to relock eagerly. Can you elaborate a little more on what could go wrong if we don&amp;#39;t? &lt;br/&gt;
&lt;br/&gt;
E.g. the reference of an object could be stored into a static field where another application thread finds it. The second thread could use synchronized methods to change the state of the object. The first thread might observe an inconsistent state of the object because of the eliminated locking.&lt;br/&gt;
&lt;br/&gt;
I think I could add a test case for this to EATests.java</comment>
                            <comment id="14624995" author="roboduke" created="Wed, 8 Nov 2023 11:06:24 -0800"  >A pull request was submitted for review.&lt;br/&gt;
URL: &lt;a href=&quot;https://git.openjdk.org/jdk/pull/16568&quot;&gt;https://git.openjdk.org/jdk/pull/16568&lt;/a&gt;&lt;br/&gt;
Date: 2023-11-08 19:00:53 +0000</comment>
                            <comment id="14624994" author="dlong" created="Wed, 8 Nov 2023 11:01:17 -0800"  >&amp;gt;  The eager relocking is needed because it has to be done before the object escapes the current thread through JVMTI. &lt;br/&gt;
&lt;br/&gt;
[~rrich] I can see why we need to allocate the eliminated locals so JVMTI to access them, but I don&amp;#39;t see why we need to relock eagerly.  Can you elaborate a little more on what could go wrong if we don&amp;#39;t?</comment>
                            <comment id="14624959" author="rrich" created="Wed, 8 Nov 2023 08:07:57 -0800"  >I see, thanks.&lt;br/&gt;
&lt;br/&gt;
&amp;gt; If it &amp;#39;s the case that with `exec_mode == Unpack_none` there are no locked objects in any callee frames&lt;br/&gt;
&lt;br/&gt;
It&amp;#39;s the other way round: just with `exec_mode == Unpack_none` there might be callee frames with locked objects and therefore it is necessary to inflate with LM_LIGHTWEIGHT.&lt;br/&gt;
With the other modes the relocking is only ever done in the context of the top frame. It should not be necessary to inflate as far as I can tell.&lt;br/&gt;
</comment>
                            <comment id="14624939" author="JIRAUSER20303" created="Wed, 8 Nov 2023 07:27:55 -0800"  >&amp;gt; I thought inflating would only be needed for `exec_mode == Unpack_none` though(?)&lt;br/&gt;
&lt;br/&gt;
This was purely a defensive implementation, I have very little knowledge of the deoptimization code. Inflating a locked object is always correct, and restores a correct lock stack. &lt;br/&gt;
If it&amp;#39;s the case that with `exec_mode == Unpack_none` there are no locked objects in any callee frames then then inflating should not be necessary as long as the re-locks are done in the correct order. &lt;br/&gt;
The current code (comments) does not make this clear, as it only fixes eliminated recursive locks and mentions that they only exists with `exec_mode == Unpack_none`. It was not clear to me that there are no locked objects further up/down (the callee direction) the call stack.</comment>
                            <comment id="14624931" author="coleenp" created="Wed, 8 Nov 2023 06:57:52 -0800"  >Hi [~rkennke] can you take over this fix?&lt;br/&gt;
&lt;br/&gt;
I have some note that there might be more to it (I wrote om.wait enter...)</comment>
                            <comment id="14624929" author="rrich" created="Wed, 8 Nov 2023 06:55:42 -0800"  >We&amp;#39;ve discussed this internally and came to the same conclusion that relocking with LM_LIGHTWEIGHT should inflate the locks.&lt;br/&gt;
Seeing that it&amp;#39;s already implemented delights me very much :) Thanks a lot!&lt;br/&gt;
I thought inflating would only be needed for `exec_mode == Unpack_none` though(?)</comment>
                            <comment id="14624884" author="JIRAUSER20303" created="Wed, 8 Nov 2023 04:48:11 -0800"  >In the current recursive ligthweight prototype we have been using &lt;a href=&quot;https://github.com/openjdk/jdk/commit/2a3d50ccba46b005d3944d76597a797ad3a9a130&quot;&gt;https://github.com/openjdk/jdk/commit/2a3d50ccba46b005d3944d76597a797ad3a9a130&lt;/a&gt; as a fix for this issue.&lt;br/&gt;
</comment>
                            <comment id="14624834" author="rkennke" created="Wed, 8 Nov 2023 03:41:07 -0800"  >I believe the best that we can do is to inflate the rematerialized lock and remove all related entries from the lock-stack. I don&amp;#39;t think this would be much of a performance concern, lightweight (or legacy) locking is only beneficial when locks are uncontended *and* churned (i.e. short-lived and created en-masse), and it helps mostly because it avoids the overhead of allocating the lock and reducing the load on deflation. But we are already deopting - that path is slow anyway and inflating the monitor there, once, surely doesn&amp;#39;t hurt much. (Uncontended) locking monitors as such should be as fast as LW locks because we have fast-paths for that in C2, and it&amp;#39;s really only a CAS.&lt;br/&gt;
&lt;br/&gt;
If you agree with that assessment, I would take this bug and provide a fix. Please let me know!</comment>
                            <comment id="14623966" author="rrich" created="Mon, 6 Nov 2023 01:07:55 -0800"  >&amp;gt; &amp;gt; That said, I think I don&amp;#39;t understand enough about how we eliminate in the first place.and why we need to re-materialize. Is it the case that any locks in earlier frames cannot be held by any other thread, so the objects being locked are isolated in accessibility to the one thread? If that were the case then re-locking out of order would be harmless because the locking would effectively be a no-op anyway.&lt;br/&gt;
&lt;br/&gt;
&amp;gt; Yes, either the owner is an object local to the current thread (no other thread knows about it because it didn&amp;#39;t escape), or it&amp;#39;s a nested lock so the thread already owns it. The re-locking is still needed because the interpreter is going to try to unlock those monitors. What isn&amp;#39;t needed, in my opinion, is doing the relocking eagerly with callees still on the stack.&lt;br/&gt;
&lt;br/&gt;
The eager relocking is needed because it has to be done before the object escapes the current thread through JVMTI.&lt;br/&gt;
&lt;br/&gt;
&amp;gt; Why is this not a problem with legacy locking? &lt;br/&gt;
&lt;br/&gt;
Legacy locking eliminates locking operations but not the locks in the frames.&lt;br/&gt;
It might be possible to do the same with light weight locking: allocate all locks needed when entering a compiled method and pop them when leaving again.&lt;br/&gt;
</comment>
                            <comment id="14623964" author="rrich" created="Mon, 6 Nov 2023 00:53:47 -0800"  >An Example&lt;br/&gt;
&lt;br/&gt;
Frame M1 (C2 compiled)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;elim. locking of o1&lt;br/&gt;
Frame M2                   &amp;lt;- top of stack&lt;br/&gt;
&amp;nbsp;&amp;nbsp;locks o1&lt;br/&gt;
&lt;br/&gt;
- M1 allocates o1&lt;br/&gt;
- M1 calls M2 and passes o1 as parameter&lt;br/&gt;
- C2 (or another jit) proves by escape analysis that o1 is local to the current thread but passed as argument to M2 (`ArgEscape`).&lt;br/&gt;
&amp;nbsp;&amp;nbsp;C2 eliminates locking of o1 based on this.&lt;br/&gt;
- M2 locks o1 (non recursively)&lt;br/&gt;
&lt;br/&gt;
Now JVMTI agent retrieves o1 from frame M2. This invalidates the assumption that o1 is local to the thread which allocated it. o1 is relocked before it is passed to the JVMTI agent.&lt;br/&gt;
&lt;br/&gt;
For relocking the stack is walked. At frame M1 it is found that `ArgEscape` parameters are passed. This is the condition to trigger relocking (`cvf-&amp;gt;arg_escape()` at &lt;a href=&quot;https://github.com/openjdk/jdk/blob/c146685ca9354ce4bf99c9b262119a4643df1e69/src/hotspot/share/runtime/escapeBarrier.cpp#L101-L102)&quot;&gt;https://github.com/openjdk/jdk/blob/c146685ca9354ce4bf99c9b262119a4643df1e69/src/hotspot/share/runtime/escapeBarrier.cpp#L101-L102)&lt;/a&gt;.&lt;br/&gt;
But o1 is locked in M2 which is a callee frame. With legacy locking the lock in frame M2 is converted to a recursive legacy lock by setting the displaced header to null. Before the original displaced header is copied to the legacy lock in M1. The address of the legacy lock in M1 is installed in o1&amp;#39;s mark word (see &lt;a href=&quot;https://github.com/openjdk/jdk/blob/c146685ca9354ce4bf99c9b262119a4643df1e69/src/hotspot/share/runtime/deoptimization.cpp#L1621-L1627)&quot;&gt;https://github.com/openjdk/jdk/blob/c146685ca9354ce4bf99c9b262119a4643df1e69/src/hotspot/share/runtime/deoptimization.cpp#L1621-L1627)&lt;/a&gt;.&lt;br/&gt;
</comment>
                            <comment id="14623484" author="dlong" created="Thu, 2 Nov 2023 13:32:00 -0700"  >&amp;gt; Do you mean that we can rematerialize Y with rematerializing frames preceding Y? That sounds completely broken.&lt;br/&gt;
&lt;br/&gt;
Yes, that is the way the code currently works, unless I read it wrong.  See VM_GetOrSetLocal::doit_prologue(), where it causes eager deoptimization of a specific depth (frame).&lt;br/&gt;
&lt;br/&gt;
&amp;gt; If we&amp;#39;ve eliminated locks for X, Y and Z and we need to re-materialize them, the surely we need to re-materialze from the outer frames down to the one we need?&lt;br/&gt;
&lt;br/&gt;
Yes, that would make sense, if we truly cared about lock order at all times.  But it appears lightweight locking is the only locking mode that really cares.&lt;br/&gt;
&lt;br/&gt;
&amp;gt;That said, I think I don&amp;#39;t understand enough about how we eliminate in the first place.and why we need to re-materialize. Is it the case that any locks in earlier frames cannot be held by any other thread, so the objects being locked are isolated in accessibility to the one thread? If that were the case then re-locking out of order would be harmless because the locking would effectively be a no-op anyway. &lt;br/&gt;
&lt;br/&gt;
Yes, either the owner is an object local to the current thread (no other thread knows about it because it didn&amp;#39;t escape), or it&amp;#39;s a nested lock so the thread already owns it.  The re-locking is still needed because the interpreter is going to try to unlock those monitors.  What isn&amp;#39;t needed, in my opinion, is doing the relocking eagerly with callees still on the stack.&lt;br/&gt;
&lt;br/&gt;
&amp;gt; Why is this not a problem with legacy locking?&lt;br/&gt;
&lt;br/&gt;
Legacy doesn&amp;#39;t track lock order anywhere, other than BasicObjectLock records on the stack, and those records are in the correct order.  It&amp;#39;s only lightweight LockStack that gets out of sync.  Or maybe there is a deadlock-detection feature that might detect this problem in legacy mode?  I haven&amp;#39;t looked to see howThreadMXBean.findMonitorDeadlockedThreads() gets its ordered list of monitors.&lt;br/&gt;
&lt;br/&gt;
&amp;gt; If the order of locks is legitimately not critical, should we disable the checking until we have a better idea? &lt;br/&gt;
&lt;br/&gt;
Right, it wasn&amp;#39;t critical for legacy, or this problem would have been noticed sooner.  It still might be considered a desirable santity check.  I think it is worth investigating a solution where JVMTI only rematerializes the locals eagerly, and allows the relocking to be done lazily, but I feel like that could be considered an enhancement.</comment>
                            <comment id="14623354" author="rkennke" created="Thu, 2 Nov 2023 04:58:06 -0700"  >Why is this not a problem with legacy locking?&lt;br/&gt;
If the order of locks is legitimately not critical, should we disable the checking until we have a better idea?</comment>
                            <comment id="14623153" author="dholmes" created="Wed, 1 Nov 2023 21:31:49 -0700"  >That said, I think I don&amp;#39;t understand enough about how we eliminate in the first place.and why we need to re-materialize. Is it the case that any locks in earlier frames cannot be held by any other thread, so the objects being locked are isolated in accessibility to the one thread? If that were the case then re-locking out of order would be harmless because the locking would effectively be a no-op anyway.</comment>
                            <comment id="14623151" author="dholmes" created="Wed, 1 Nov 2023 21:20:42 -0700"  >I think this is re-exposing the concerns I had about EA and lock elimination that I should have, but didn&amp;#39;t, investigate further back in 2019:&lt;br/&gt;
&lt;br/&gt;
&lt;a href=&quot;https://mail.openjdk.org/pipermail/hotspot-runtime-dev/2019-December/037583.html&quot;&gt;https://mail.openjdk.org/pipermail/hotspot-runtime-dev/2019-December/037583.html&lt;/a&gt;</comment>
                            <comment id="14623148" author="dholmes" created="Wed, 1 Nov 2023 21:12:08 -0700"  >Do you mean that we can rematerialize Y with rematerializing frames preceding Y? That sounds completely broken. If we&amp;#39;ve eliminated locks for X, Y and Z and we need to re-materialize them, the surely we need to re-materialze from the outer frames down to the one we need?</comment>
                            <comment id="14623145" author="dlong" created="Wed, 1 Nov 2023 20:22:59 -0700"  >&amp;gt;  If it knows the set of monitors it needs to re-lock, surely we can access that in the correct order ?? &lt;br/&gt;
&lt;br/&gt;
Yes, the C2 frames know which C2 locks go in which order, but how do we find locks for an arbitrary frame in LockStack, which has no frame boundaries?  If X calls Y calls Z, and Y is the one being rematerialized by JVMTI, then Y needs to insert its locks after those of X but before those of Z.</comment>
                            <comment id="14623126" author="dholmes" created="Wed, 1 Nov 2023 16:47:31 -0700"  >&amp;gt; Any C2 monitors that were eliminated are relocked eagerly at the time of the JVMTI call&lt;br/&gt;
&lt;br/&gt;
If it knows the set of monitors it needs to re-lock, surely we can access that in the correct order ??</comment>
                            <comment id="14623105" author="stefank" created="Wed, 1 Nov 2023 14:02:19 -0700"  >FWIW, we inflate these problematic locks in the branch that adds support for recursive lightweight locking.</comment>
                            <comment id="14623099" author="dlong" created="Wed, 1 Nov 2023 13:29:47 -0700"  >It looks like there are a couple different problems here.  &lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8227745&quot; title=&quot;Enable Escape Analysis for Better Performance in the Presence of JVMTI Agents&quot; class=&quot;issue-link&quot; data-issue-key=&quot;JDK-8227745&quot;&gt;&lt;strike&gt;JDK-8227745&lt;/strike&gt;&lt;/a&gt; allows JVMTI calls to rematerialize compiled frame state at an arbitrary call depth.  Any C2 monitors that were eliminated are relocked eagerly at the time of the JVMTI call, rather than lazily when control reaches that frame.  This allows broken lock order, as seen in the lightweight locking LockStack, between compiled frames.  Even if we fix the JVMTI problem,&lt;br/&gt;
there is also a lock order problem when relocking monitors within compiled frames.  However, compiled frames know the lock order, so in theory the locks could be inserted into the LockStack in the correct order if there was an API to do that.  So we have both an inter- and intra-compiled-frame problem, and it is only visible to lightweight locking.&lt;br/&gt;
I don&amp;#39;t see any easy way to insert locks into the LockStack in the correct order for JVMTI.  The entire LockStack would probably need to be cleared and recomputed.&lt;br/&gt;
The easiest solution is probably to inflate the locks, so they are removed from the LockStack.</comment>
                            <comment id="14622497" author="mseledtsov" created="Tue, 31 Oct 2023 11:16:20 -0700"  >ILW = HLM = P3</comment>
                            <comment id="14621549" author="stefank" created="Fri, 27 Oct 2023 00:29:34 -0700"  >[~dholmes] Yes, you are correct. My attempt to copy-n-paste failed me. I&amp;#39;ll update the summary.</comment>
                            <comment id="14621506" author="dholmes" created="Thu, 26 Oct 2023 19:28:32 -0700"  >[~stefank] is there a typo in the example - the second code fragment, purportedly without the recursive locking, appears identical to the first?&lt;br/&gt;
&lt;br/&gt;
So IIUC given:&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;synchronized (l1) { // eliminated&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;synchronized (l2) { // eliminated &lt;br/&gt;
&lt;br/&gt;
the deoptimizer reifies these elimiated actions in the wrong order.</comment>
                            <comment id="14621324" author="stefank" created="Thu, 26 Oct 2023 05:55:25 -0700"  >A reproducer can be found here:&lt;br/&gt;
&lt;a href=&quot;https://github.com/openjdk/jdk/compare/master...stefank:jdk:8318895_reproducer&quot;&gt;https://github.com/openjdk/jdk/compare/master...stefank:jdk:8318895_reproducer&lt;/a&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10200">
                    <name>Backport</name>
                                            <outwardlinks description="backported by">
                                        <issuelink>
            <issuekey id="5114543">JDK-8319926</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                            <issuelinktype id="10003">
                    <name>Relates</name>
                                            <outwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="4995612">JDK-8227745</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="5080595">JDK-8291555</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="5109863">JDK-8315880</issuekey>
        </issuelink>
                            </outwardlinks>
                                                                <inwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="5114842">JDK-8320196</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="5120257">JDK-8324881</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_11700" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_10600" key="com.oracle.jira.javabugsystem-jira-plugin:jbs-fixedBackportedCustomfield">
                        <customfieldname>Fixed</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_11100" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i33msj:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_11004" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10006" key="com.atlassian.jira.plugin.system.customfieldtypes:select">
                        <customfieldname>Resolved In Build</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="17436"><![CDATA[b24]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10008" key="com.oracle.jira.jira-subcomponent-plugin:oracle-subComponentField">
                        <customfieldname>Subcomponent</customfieldname>
                        <customfieldvalues>
                             <customfieldvalue key="192"><![CDATA[runtime]]></customfieldvalue> 
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_10601" key="com.oracle.jira.javabugsystem-jira-plugin:jbs-targetBackportedCustomfield">
                        <customfieldname>Targeted</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    </customfields>
    </item>
</channel>
</rss>