<!-- 
RSS generated by JIRA (9.12.27#9120027-sha1:edc4490121e366e9e7bd2213d532dbe7e028fc5d) at Tue Sep 30 19:13:30 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>Java Bug System</title>
    <link>https://bugs.openjdk.org</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-us</language>    <build-info>
        <version>9.12.27</version>
        <build-number>9120027</build-number>
        <build-date>02-09-2025</build-date>
    </build-info>


<item>
            <title>[JDK-8307486] ProcessTools.java should wait until vthread is completed before checking exceptions</title>
                <link>https://bugs.openjdk.org/browse/JDK-8307486</link>
                <project id="10100" key="JDK">JDK</project>
                    <description>Test java/foreign/enablenativeaccess/TestEnableNativeAccessDynamic.java&lt;br/&gt;
fails when executed with virtual thread factory.&lt;br/&gt;
&lt;br/&gt;
It is a known problem that virtual threads that they doesn&amp;#39;t support permissions.&lt;br/&gt;
&lt;br/&gt;
To reproduce run:&lt;br/&gt;
make -- run-test JTREG_VERBOSE=all JTREG_RETAIN=all  JTREG_TEST_THREAD_FACTORY=Virtual  TEST=java/foreign/enablenativeaccess/TestEnableNativeAccessDynamic.java&lt;br/&gt;
&lt;br/&gt;
The outpu of process: &lt;br/&gt;
java -cp .. -ea -esa --enable-preview --enable-native-access=ALL-UNNAMED jdk.test.lib.process.ProcessTools Virtual NativeAccessDynamicMain /home/lmesnik/ws/jdk-8307307/build/linux-x64/test-support/jtreg_open_test_jdk_java_foreign_enablenativeaccess/classes/0/java/foreign/enablenativeaccess/TestEnableNativeAccessDynamic.d/modules panama_module/org.openjdk.foreigntest.PanamaMainDirect false panama_enable_native_access_fail&lt;br/&gt;
Trying to get Linker&lt;br/&gt;
&lt;br/&gt;
There is no expected exception while also no output for further actions.</description>
                <environment></environment>
        <key id="5100162">JDK-8307486</key>
            <summary>ProcessTools.java should wait until vthread is completed before checking exceptions</summary>
                <type id="1" iconUrl="https://bugs.openjdk.org/secure/viewavatar?size=xsmall&amp;avatarId=14703&amp;avatarType=issuetype">Bug</type>
                                            <priority id="4" iconUrl="https://bugs.openjdk.org/images/jbsImages/p4.png">P4</priority>
                        <status id="5" iconUrl="https://bugs.openjdk.org/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="success"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="lmesnik">Leonid Mesnik</assignee>
                                    <reporter username="lmesnik">Leonid Mesnik</reporter>
                        <labels>
                    </labels>
                <created>Thu, 4 May 2023 12:43:21 -0700</created>
                <updated>Tue, 16 May 2023 16:10:04 -0700</updated>
                            <resolved>Tue, 9 May 2023 09:39:29 -0700</resolved>
                                    <version>21</version>
                                    <fixVersion>21</fixVersion>
                                    <component>hotspot</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>5</watches>
                                                                                                                <comments>
                            <comment id="14580270" author="dukebot" created="Tue, 9 May 2023 09:39:26 -0700"  >Changeset: 3aff5eac&lt;br/&gt;
Author:    Leonid Mesnik &amp;lt;&lt;a href=&apos;mailto:lmesnik@openjdk.org&apos;&gt;lmesnik@openjdk.org&lt;/a&gt;&amp;gt;&lt;br/&gt;
Date:      2023-05-09 16:36:21 +0000&lt;br/&gt;
URL:       &lt;a href=&quot;https://git.openjdk.org/jdk/commit/3aff5eacbd90cc5fc791c9c96b8d114caee9ddb5&quot;&gt;https://git.openjdk.org/jdk/commit/3aff5eacbd90cc5fc791c9c96b8d114caee9ddb5&lt;/a&gt;&lt;br/&gt;
</comment>
                            <comment id="14579997" author="roboduke" created="Mon, 8 May 2023 16:24:21 -0700"  >A pull request was submitted for review.&lt;br/&gt;
URL: &lt;a href=&quot;https://git.openjdk.org/jdk/pull/13873&quot;&gt;https://git.openjdk.org/jdk/pull/13873&lt;/a&gt;&lt;br/&gt;
Date: 2023-05-08 23:16:51 +0000</comment>
                            <comment id="14579882" author="lmesnik" created="Mon, 8 May 2023 12:19:42 -0700"  >[~mcimadamore], [~alanb] Thank you for finding the root cause of the problem!&lt;br/&gt;
The processtools should be updated to wait for vthread completion.</comment>
                            <comment id="14579425" author="alanb" created="Fri, 5 May 2023 09:47:48 -0700"  >[~lmesnik] In test/lib/jdk/test/lib/process/ProcessTools.java I see:&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if (tg.uncaughtThrowable != null) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;throw new RuntimeException(tg.uncaughtThrowable);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;vthread.join();&lt;br/&gt;
&lt;br/&gt;
The join needs to be before checking the UHE, otherwise it won&amp;#39;t re-throw.</comment>
                            <comment id="14579414" author="mcimadamore" created="Fri, 5 May 2023 08:53:00 -0700"  >Could it be a missing join? Since virtual threads are daemon, the VM will exit before any of them will get a chance to run into the illegal access. E.g. for testing I used this class:&lt;br/&gt;
&lt;br/&gt;
```&lt;br/&gt;
import java.io.File;&lt;br/&gt;
import java.lang.module.ModuleFinder;&lt;br/&gt;
import java.net.URL;&lt;br/&gt;
import java.net.URLClassLoader;&lt;br/&gt;
import java.nio.file.Path;&lt;br/&gt;
import java.nio.file.Paths;&lt;br/&gt;
import java.util.Arrays;&lt;br/&gt;
import java.util.List;&lt;br/&gt;
import java.util.stream.Collectors;&lt;br/&gt;
import java.util.stream.Stream;&lt;br/&gt;
&lt;br/&gt;
//   java --enable-native-access=ALL-UNNAMED NativeAccessDynamicMain &amp;lt;module-path&amp;gt; &amp;lt;mod/class&amp;gt; &amp;lt;true|false&amp;gt; [main-args]&lt;br/&gt;
public class Foo {&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public static void main(String[] args) throws Throwable {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Thread thread = Thread.ofVirtual().start(() -&amp;gt; {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;try {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;run(args);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;} catch (Throwable ex) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;throw new AssertionError(ex);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;});&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;thread.join();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public static void run(String[] args) throws Exception {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;String modulePath = args[0];&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;String moduleAndClsName = args[1];&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;boolean enableNativeAccess = Boolean.parseBoolean(args[2]);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;String[] mainArgs = args.length &amp;gt; 2? Arrays.copyOfRange(args, 3, args.length) : new String[0];&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;int idx = moduleAndClsName.indexOf(&amp;#39;/&amp;#39;);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;String moduleName = moduleAndClsName.substring(0, idx);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;String className = moduleAndClsName.substring(idx+1);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Path[] paths = Stream.of(modulePath.split(File.pathSeparator))&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;.map(Paths::get)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;.toArray(Path[]::new);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ModuleFinder mf = ModuleFinder.of(paths);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;var mrefs = mf.findAll();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if (mrefs.isEmpty()) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;throw new RuntimeException(&amp;quot;No modules module path: &amp;quot; + modulePath);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;var rootMods = mrefs.stream().&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;map(mr-&amp;gt;mr.descriptor().name()).&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;collect(Collectors.toSet());&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ModuleLayer boot = ModuleLayer.boot();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;var conf = boot.configuration().&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;resolve(mf, ModuleFinder.of(), rootMods);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;String firstMod = rootMods.iterator().next();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;URLClassLoader cl = new URLClassLoader(new URL[] { paths[0].toFile().toURL() });&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ModuleLayer.Controller controller = boot.defineModulesWithOneLoader(conf, List.of(boot), cl);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ModuleLayer layer = controller.layer();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Module mod = layer.findModule(firstMod).get();&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// conditionally grant native access to the dynamic module created&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if (enableNativeAccess) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;controller.enableNativeAccess(mod);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Class mainCls = Class.forName(mod, className);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;var main = mainCls.getMethod(&amp;quot;main&amp;quot;, String[].class);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;main.invoke(null, (Object)mainArgs);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
}&lt;br/&gt;
```&lt;br/&gt;
&lt;br/&gt;
If I remove the join from the main method, then I can see behavior that is similar to the one reported (e.g. no exception).&lt;br/&gt;
&lt;br/&gt;
</comment>
                            <comment id="14579412" author="lmesnik" created="Fri, 5 May 2023 08:45:55 -0700"  >Let me check, might be exception was swallowed by test executor.&lt;br/&gt;
</comment>
                            <comment id="14579411" author="mcimadamore" created="Fri, 5 May 2023 08:43:18 -0700"  >If I run the very same test that is mentioned in the description from a virtual thread, I get this:&lt;br/&gt;
&lt;br/&gt;
```&lt;br/&gt;
Exception in thread &amp;quot;&amp;quot; java.lang.AssertionError: java.lang.reflect.InvocationTargetException&lt;br/&gt;
	at Foo.lambda$main$0(Foo.java:20)&lt;br/&gt;
	at java.base/java.lang.VirtualThread.run(VirtualThread.java:311)&lt;br/&gt;
Caused by: java.lang.reflect.InvocationTargetException&lt;br/&gt;
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:118)&lt;br/&gt;
	at java.base/java.lang.reflect.Method.invoke(Method.java:578)&lt;br/&gt;
	at Foo.run(Foo.java:65)&lt;br/&gt;
	at Foo.lambda$main$0(Foo.java:18)&lt;br/&gt;
	... 1 more&lt;br/&gt;
Caused by: java.lang.IllegalCallerException: Illegal native access from: module panama_module&lt;br/&gt;
	at java.base/java.lang.Module.ensureNativeAccess(Module.java:317)&lt;br/&gt;
	at java.base/java.lang.System$2.ensureNativeAccess(System.java:2453)&lt;br/&gt;
	at java.base/jdk.internal.reflect.Reflection.ensureNativeAccess(Reflection.java:118)&lt;br/&gt;
	at java.base/java.lang.foreign.Linker.nativeLinker(Linker.java:450)&lt;br/&gt;
	at panama_module/org.openjdk.foreigntest.PanamaMain.main(PanamaMain.java:31)&lt;br/&gt;
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)&lt;br/&gt;
	... 4 more&lt;br/&gt;
&lt;br/&gt;
Process finished with exit code 0&lt;br/&gt;
```&lt;br/&gt;
&lt;br/&gt;
Which seems to indicate that the virtual thread indeed fails with the expected exception (which here I wrapped into an AssertionError).</comment>
                            <comment id="14579404" author="mcimadamore" created="Fri, 5 May 2023 08:22:06 -0700"  >Ok, the issue seems to refer to adding native access permissions to a dynamic module layer.</comment>
                            <comment id="14579402" author="mcimadamore" created="Fri, 5 May 2023 08:17:45 -0700"  >Also, if I run with &amp;quot;--enable-native-access=java.base&amp;quot; I get this:&lt;br/&gt;
&lt;br/&gt;
Exception in thread &amp;quot;&amp;quot; java.lang.IllegalCallerException: Illegal native access from: unnamed module @7c7f33d8&lt;br/&gt;
	at java.base/java.lang.Module.ensureNativeAccess(Module.java:317)&lt;br/&gt;
	at java.base/java.lang.System$2.ensureNativeAccess(System.java:2453)&lt;br/&gt;
	at java.base/jdk.internal.reflect.Reflection.ensureNativeAccess(Reflection.java:118)&lt;br/&gt;
	at java.base/java.lang.foreign.Linker.nativeLinker(Linker.java:450)&lt;br/&gt;
	at TestVirtual.callLinker(TestVirtual.java:10)&lt;br/&gt;
	at java.base/java.lang.VirtualThread.run(VirtualThread.java:311)&lt;br/&gt;
&lt;br/&gt;
Which also seems correct (as, because of the command line option, the unnamed module is no longer trusted with native code).</comment>
                            <comment id="14579401" author="mcimadamore" created="Fri, 5 May 2023 08:16:05 -0700"  >I tried this:&lt;br/&gt;
&lt;br/&gt;
```&lt;br/&gt;
import java.lang.foreign.Linker;&lt;br/&gt;
&lt;br/&gt;
public class TestVirtual {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public static void main(String[] args) throws Throwable {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Thread thread = Thread.ofVirtual().start(TestVirtual::callLinker);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;thread.join();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;static void callLinker() {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Linker.nativeLinker();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
}&lt;br/&gt;
```&lt;br/&gt;
&lt;br/&gt;
This program runs, and prints:&lt;br/&gt;
&lt;br/&gt;
WARNING: A restricted method in java.lang.foreign.Linker has been called&lt;br/&gt;
WARNING: java.lang.foreign.Linker::nativeLinker has been called by the unnamed module&lt;br/&gt;
WARNING: Use --enable-native-access=ALL-UNNAMED to avoid a warning for this module&lt;br/&gt;
&lt;br/&gt;
All seems to be as expected?</comment>
                            <comment id="14579182" author="lmesnik" created="Thu, 4 May 2023 12:45:16 -0700"  >I think you could try to check how &lt;br/&gt;
&amp;nbsp;Linker.nativeLinker();&lt;br/&gt;
works when executed in virtual thread.&lt;br/&gt;
&lt;br/&gt;
If it works like expected, feel free just to close this issue,</comment>
                    </comments>
                    <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_11700" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_10600" key="com.oracle.jira.javabugsystem-jira-plugin:jbs-fixedBackportedCustomfield">
                        <customfieldname>Fixed</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_11100" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i31e43:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_11004" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10006" key="com.atlassian.jira.plugin.system.customfieldtypes:select">
                        <customfieldname>Resolved In Build</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="17415"><![CDATA[b22]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10008" key="com.oracle.jira.jira-subcomponent-plugin:oracle-subComponentField">
                        <customfieldname>Subcomponent</customfieldname>
                        <customfieldvalues>
                             <customfieldvalue key="225"><![CDATA[test]]></customfieldvalue> 
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_10601" key="com.oracle.jira.javabugsystem-jira-plugin:jbs-targetBackportedCustomfield">
                        <customfieldname>Targeted</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    </customfields>
    </item>
</channel>
</rss>