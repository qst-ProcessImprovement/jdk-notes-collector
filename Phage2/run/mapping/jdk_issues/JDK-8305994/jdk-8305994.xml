<!-- 
RSS generated by JIRA (9.12.27#9120027-sha1:edc4490121e366e9e7bd2213d532dbe7e028fc5d) at Tue Sep 30 18:33:16 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>Java Bug System</title>
    <link>https://bugs.openjdk.org</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-us</language>    <build-info>
        <version>9.12.27</version>
        <build-number>9120027</build-number>
        <build-date>02-09-2025</build-date>
    </build-info>


<item>
            <title>[JDK-8305994] Guarantee eventual async monitor deflation</title>
                <link>https://bugs.openjdk.org/browse/JDK-8305994</link>
                <project id="10100" key="JDK">JDK</project>
                    <description>One of our systems reported a steady increase in memory usage after migration from JDK 11 to JDK 17. NMT logs clearly show the growing &amp;quot;Object Monitors&amp;quot; section, where the population of monitors is nearly 11M, taking several GBs of RSS.&lt;br/&gt;
&lt;br/&gt;
Async monitor deflation is supposed to deal with this, by triggering the cleanup when `MonitorUsedDeflationThreshold` (`MUDT`) is reached. But the apparent problem with that heuristics is that `MUDT` is the percent of &amp;quot;ceiling&amp;quot;, which is derived roughly as `max(#threads*AvgMonitorsPerThreadEstimate, #max_monitors_ever_observed)`, plus additive adjustments when deflation does not make progress. For the systems that run thousands of threads, we can have a very high ceiling. &lt;br/&gt;
&lt;br/&gt;
Also, AFAIU, the ceiling can get arbitrarily high, if we had historical spike in the number of monitors, or we did some past async deflations without a progress. The ceiling seems to never go down! (Which is a good thing in buildings, but not in this heuristics code.) So even if we set `MUDT` to lowest value, 1, the ceiling might get so large eventually, the heuristics would never fire after some point.&lt;br/&gt;
&lt;br/&gt;
Back-envelope calculation: even without involving the historical ceiling adjustments, just the static calculation for the system with 13K threads (real-life number) and default `AMPTE` = 1024, yields the ceiling of about 12M. Which means the default `MUDT` = 90 would not trigger cleanup until we have at least 11M monitors, which at ~200 bytes per monitor translates to &amp;gt;2 GB of native memory.&lt;br/&gt;
&lt;br/&gt;
This started to be a problem in JDK 17, because the work done in JDK 15..16 (&lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8153224&quot; title=&quot;Monitor deflation prolong safepoints&quot; class=&quot;issue-link&quot; data-issue-key=&quot;JDK-8153224&quot;&gt;&lt;strike&gt;JDK-8153224&lt;/strike&gt;&lt;/a&gt;, &lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8246476&quot; title=&quot;remove AsyncDeflateIdleMonitors option and the safepoint based deflation mechanism&quot; class=&quot;issue-link&quot; data-issue-key=&quot;JDK-8246476&quot;&gt;&lt;strike&gt;JDK-8246476&lt;/strike&gt;&lt;/a&gt;) gradually removed the path that did the monitor deflation on safepoint cleanups. So the JDK 11 applications got their monitors cleanup with the eventual safepoints from e.g. GC, *and* from the special cleanup safepoints triggered by monitor used thresholds, checked every `GuaranteedSafepointInterval`. But for JDK 17, the deflation is now only triggered by monitor used threshold checked every `AsyncDeflationInterval`, and &amp;quot;used threshold&amp;quot; might not be reached for quite some time. The worst case would be threads spiking to use all these monitors, then never using them again, and never using new ones, so the used threshold is never reached, and monitors stay inflated forever.&lt;br/&gt;
&lt;br/&gt;
I have a minimal example showing this behavior:&lt;br/&gt;
&lt;br/&gt;
```&lt;br/&gt;
import java.util.concurrent.CountDownLatch;&lt;br/&gt;
&lt;br/&gt;
public class Monitors {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;static final int THREAD_COUNT  = Integer.getInteger(&amp;quot;threads&amp;quot;, 2000);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;static final int MONITOR_COUNT = Integer.getInteger(&amp;quot;monitorsPerThread&amp;quot;, 800);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;static final CountDownLatch STARTED = new CountDownLatch(THREAD_COUNT);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;static final CountDownLatch LOCKED  = new CountDownLatch(THREAD_COUNT);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;static final CountDownLatch HANG    = new CountDownLatch(1);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;public static void main(String... args) throws Exception {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.println(&amp;quot;Initializing&amp;quot;);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;for (int c = 0; c &amp;lt; THREAD_COUNT; c++) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Thread t = new Thread(() -&amp;gt; {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;try {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;STARTED.countDown();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;STARTED.await();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;} catch (InterruptedException e) {}&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;for (int l = 0; l &amp;lt; MONITOR_COUNT; l++) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;try {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Object o = new Object();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;synchronized (o) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;o.wait(1);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;} catch (InterruptedException e) {}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;try {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;LOCKED.countDown();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;HANG.await();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;} catch (InterruptedException e) {}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;});&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;t.start();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;STARTED.await();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.println(&amp;quot;Started&amp;quot;);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;LOCKED.await();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.println(&amp;quot;Locked&amp;quot;);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.in.read();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;HANG.countDown();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&lt;br/&gt;
}&lt;br/&gt;
```&lt;br/&gt;
&lt;br/&gt;
Run with:&lt;br/&gt;
&lt;br/&gt;
```&lt;br/&gt;
$ java -XX:NativeMemoryTracking=summary -Xss256k Monitors.java&lt;br/&gt;
Initializing&lt;br/&gt;
Started&lt;br/&gt;
Locked&lt;br/&gt;
&lt;br/&gt;
&amp;lt;in another terminal&amp;gt;&lt;br/&gt;
$ ps x -o pid,rss,command | grep java&lt;br/&gt;
67999 704656 .../java -XX:NativeMemoryTracking=summary -Xss256k Monitors.java&lt;br/&gt;
&lt;br/&gt;
$ jcmd 67999 VM.native_memory&lt;br/&gt;
...&lt;br/&gt;
-           Object Monitors (reserved=325001KB, committed=325001KB)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;(malloc=325001KB #1600007) &lt;br/&gt;
```&lt;br/&gt;
&lt;br/&gt;
So, out of 704M of RSS, 325M is taken by inflated object monitors, and there is 1.6M of them (2000 threads, 800 monitors each).&lt;br/&gt;
&lt;br/&gt;
I see these ways out of this:&lt;br/&gt;
&lt;br/&gt;
0. Ask users who know about this problem to drop their `MUDT` to much lower value, so that deflation would be triggered more often. This mitigates the issue, but this does not change the default behavior, which means other users are still exposed to this problem.&lt;br/&gt;
&lt;br/&gt;
1. Drop `MUDT` to much lower default value, so that cleanups are more frequent. I think this is safe to do from latency perspective, because the deflation would still be performed asynchronously. The problem with the arbitrarily high ceiling is still present. This might also have throughput regressions since deflater thread would be more active in normal conditions.&lt;br/&gt;
&lt;br/&gt;
2. Drop `AMPTE` to much lower default value, so that monitor population ceiling is not that large. This have the same implications as lowering `MUDT`.&lt;br/&gt;
&lt;br/&gt;
3. Amend VM to request async deflation from safepoint, for example calling a light-weight version of `ObjectSynchronizer::request_deflate_idle_monitors` from safepoint cleanup path. This would be similar to the behavior of the JDK 11 -- piggybacking the cleanup requests on safepoint invocations, but with the benefit of being completely asynchronous.&lt;br/&gt;
&lt;br/&gt;
4. Introduce the additional `GuaranteedAsyncDeflationInterval`, which would normally be larger than `AsyncDeflationInterval`, but which would trigger the deflation even when threshold is not reached. Some large default value, like 60s, should serve long-running systems well without incurring significant work on the deflater thread.&lt;br/&gt;
&lt;br/&gt;
I like (4) quite a bit better, because it acts like a safety rail should the normal heuristics fail.&lt;br/&gt;
The threshold heuristics fixes can then proceed at leisurely pace, all the while being covered by this safety net.</description>
                <environment></environment>
        <key id="5098411">JDK-8305994</key>
            <summary>Guarantee eventual async monitor deflation</summary>
                <type id="7" iconUrl="https://bugs.openjdk.org/secure/viewavatar?size=xsmall&amp;avatarId=14707&amp;avatarType=issuetype">Enhancement</type>
                                            <priority id="4" iconUrl="https://bugs.openjdk.org/images/jbsImages/p4.png">P4</priority>
                        <status id="5" iconUrl="https://bugs.openjdk.org/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="success"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="shade">Aleksey Shipilev</assignee>
                                    <reporter username="shade">Aleksey Shipilev</reporter>
                        <labels>
                            <label>amazon-interest</label>
                            <label>jdk17u-fix-request</label>
                            <label>jdk17u-fix-yes</label>
                            <label>jdk20u-fix-SQE-ok</label>
                            <label>jdk20u-fix-request</label>
                            <label>jdk20u-fix-yes</label>
                            <label>sync</label>
                    </labels>
                <created>Fri, 14 Apr 2023 02:04:15 -0700</created>
                <updated>Wed, 10 Apr 2024 01:46:37 -0700</updated>
                            <resolved>Mon, 24 Apr 2023 10:03:54 -0700</resolved>
                                    <version>17</version>
                    <version>20</version>
                    <version>21</version>
                                    <fixVersion>21</fixVersion>
                                    <component>hotspot</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>6</watches>
                                                                                                                <comments>
                            <comment id="14578379" author="shade" created="Tue, 2 May 2023 10:56:26 -0700"  >Fix Request (20u, 17u)&lt;br/&gt;
&lt;br/&gt;
This fix provides the safety net in the face of heuristics failure to deflate the monitors. This would show up as the slow memory leak with &amp;quot;Object Monitors&amp;quot; NMT growing up. The patch applies cleanly to 20u, applies with minor addition to 17u (see related PRs). Testing, including new regression test, passes. &lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8305994&quot; title=&quot;Guarantee eventual async monitor deflation&quot; class=&quot;issue-link&quot; data-issue-key=&quot;JDK-8305994&quot;&gt;&lt;strike&gt;JDK-8305994&lt;/strike&gt;&lt;/a&gt;, &lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8306774&quot; title=&quot;Make runtime/Monitor/GuaranteedAsyncDeflationIntervalTest.java more reliable&quot; class=&quot;issue-link&quot; data-issue-key=&quot;JDK-8306774&quot;&gt;&lt;strike&gt;JDK-8306774&lt;/strike&gt;&lt;/a&gt;, &lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8306825&quot; title=&quot;Monitor deflation might be accidentally disabled by zero intervals&quot; class=&quot;issue-link&quot; data-issue-key=&quot;JDK-8306825&quot;&gt;&lt;strike&gt;JDK-8306825&lt;/strike&gt;&lt;/a&gt; all go in together to fix related issues at once.</comment>
                            <comment id="14578217" author="roboduke" created="Tue, 2 May 2023 02:55:31 -0700"  >A pull request was submitted for review.&lt;br/&gt;
URL: &lt;a href=&quot;https://git.openjdk.org/jdk17u-dev/pull/1316&quot;&gt;https://git.openjdk.org/jdk17u-dev/pull/1316&lt;/a&gt;&lt;br/&gt;
Date: 2023-05-02 09:47:38 +0000</comment>
                            <comment id="14576170" author="roboduke" created="Mon, 24 Apr 2023 11:29:09 -0700"  >A pull request was submitted for review.&lt;br/&gt;
URL: &lt;a href=&quot;https://git.openjdk.org/jdk20u/pull/61&quot;&gt;https://git.openjdk.org/jdk20u/pull/61&lt;/a&gt;&lt;br/&gt;
Date: 2023-04-24 18:01:40 +0000</comment>
                            <comment id="14576157" author="shade" created="Mon, 24 Apr 2023 11:06:24 -0700"  >New test depends on &lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8291418&quot; title=&quot;adjust monitor deflation logging and deflate_idle_monitors use&quot; class=&quot;issue-link&quot; data-issue-key=&quot;JDK-8291418&quot;&gt;&lt;strike&gt;JDK-8291418&lt;/strike&gt;&lt;/a&gt; logging messages.</comment>
                            <comment id="14576128" author="dukebot" created="Mon, 24 Apr 2023 10:03:52 -0700"  >Changeset: 6b81342c&lt;br/&gt;
Author:    Aleksey Shipilev &amp;lt;&lt;a href=&apos;mailto:shade@openjdk.org&apos;&gt;shade@openjdk.org&lt;/a&gt;&amp;gt;&lt;br/&gt;
Date:      2023-04-24 17:02:59 +0000&lt;br/&gt;
URL:       &lt;a href=&quot;https://git.openjdk.org/jdk/commit/6b81342c2215041dbb7e9020a67cdc56976c97b1&quot;&gt;https://git.openjdk.org/jdk/commit/6b81342c2215041dbb7e9020a67cdc56976c97b1&lt;/a&gt;&lt;br/&gt;
</comment>
                            <comment id="14574780" author="shade" created="Tue, 18 Apr 2023 10:47:19 -0700"  >Yes, thanks for that. I am just scoping out this RFE. Since we have the issue with the current heuristics that went unnoticed through testing and reviews, and it affects real at-scale deployments today, maybe we should think laterally here. First provide the safety net (this RFE) to guarantee deflation in the cases smart heuristics fails, then try to make heuristics even smarter (future RFEs), under the protection of that safety net.</comment>
                            <comment id="14574765" author="dcubed" created="Tue, 18 Apr 2023 10:09:53 -0700"  >[~shade] I&amp;#39;m just adding historical context here.</comment>
                            <comment id="14573912" author="shade" created="Fri, 14 Apr 2023 13:05:27 -0700"  >The issue that we are looking at has to do with MUDT*AMPTE*#threads is not reached until very late for heavily-threaded workloads. We do not enter the NoAsyncDeflationProgressMax handling block either in production use case, or on the model example in this issue, judging by `-Xlog:monitorinflation` logs. So while I think the threshold heuristics needs some further thinking about, it would be a future, more complicated exercise than this one.&lt;br/&gt;
&lt;br/&gt;
What this RFE does is providing the safety net in case the normal threshold-based heuristics fails in this or other ways.</comment>
                            <comment id="14573902" author="dcubed" created="Fri, 14 Apr 2023 12:22:16 -0700"  >The following issue was used to tweak the way that&lt;br/&gt;
MonitorUsedDeflationThreshold (MUDT) gets used in JDK17:&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8226416&quot; title=&quot;MonitorUsedDeflationThreshold can cause repeated async deflation requests&quot; class=&quot;issue-link&quot; data-issue-key=&quot;JDK-8226416&quot;&gt;&lt;strike&gt;JDK-8226416&lt;/strike&gt;&lt;/a&gt; MonitorUsedDeflationThreshold can cause repeated async deflation requests&lt;br/&gt;
&lt;br/&gt;
It&amp;#39;s helpful to understand where the AsyncDeflationProgressMax&lt;br/&gt;
and the _no_progress_cnt stuff comes from and why...</comment>
                            <comment id="14573801" author="roboduke" created="Fri, 14 Apr 2023 03:59:48 -0700"  >A pull request was submitted for review.&lt;br/&gt;
URL: &lt;a href=&quot;https://git.openjdk.org/jdk/pull/13474&quot;&gt;https://git.openjdk.org/jdk/pull/13474&lt;/a&gt;&lt;br/&gt;
Date: 2023-04-14 10:53:31 +0000</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10200">
                    <name>Backport</name>
                                            <outwardlinks description="backported by">
                                        <issuelink>
            <issuekey id="5100021">JDK-8307361</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="5100214">JDK-8307534</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="5100975">JDK-8308131</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="5110356">JDK-8316312</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                            <issuelinktype id="10002">
                    <name>Duplicate</name>
                                                                <inwardlinks description="duplicates">
                                        <issuelink>
            <issuekey id="5045739">JDK-8264420</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                            <issuelinktype id="10003">
                    <name>Relates</name>
                                            <outwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="5080448">JDK-8291418</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="5099417">JDK-8306825</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="4993721">JDK-8226416</issuekey>
        </issuelink>
                            </outwardlinks>
                                                                <inwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="5099293">JDK-8306774</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="4874799">JDK-8153224</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_11700" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_10600" key="com.oracle.jira.javabugsystem-jira-plugin:jbs-fixedBackportedCustomfield">
                        <customfieldname>Fixed</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_11100" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i313qr:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_11004" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10006" key="com.atlassian.jira.plugin.system.customfieldtypes:select">
                        <customfieldname>Resolved In Build</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="17351"><![CDATA[b20]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10008" key="com.oracle.jira.jira-subcomponent-plugin:oracle-subComponentField">
                        <customfieldname>Subcomponent</customfieldname>
                        <customfieldvalues>
                             <customfieldvalue key="192"><![CDATA[runtime]]></customfieldvalue> 
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_10601" key="com.oracle.jira.javabugsystem-jira-plugin:jbs-targetBackportedCustomfield">
                        <customfieldname>Targeted</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    </customfields>
    </item>
</channel>
</rss>