<!-- 
RSS generated by JIRA (9.12.27#9120027-sha1:edc4490121e366e9e7bd2213d532dbe7e028fc5d) at Tue Sep 30 10:50:41 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>Java Bug System</title>
    <link>https://bugs.openjdk.org</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-us</language>    <build-info>
        <version>9.12.27</version>
        <build-number>9120027</build-number>
        <build-date>02-09-2025</build-date>
    </build-info>


<item>
            <title>[JDK-8313816] Accessing jmethodID might lead to spurious crashes</title>
                <link>https://bugs.openjdk.org/browse/JDK-8313816</link>
                <project id="10100" key="JDK">JDK</project>
                    <description>In a profiler library (&lt;a href=&quot;https://github.com/DataDog/java-profiler&quot;&gt;https://github.com/DataDog/java-profiler&lt;/a&gt;) we are using JVMTI GetStackTrace to obtain a stacktrace of an allocation which is then tracked for a longer time.&lt;br/&gt;
&lt;br/&gt;
I know that jmethodID is by spec guranteed to be valid only while the declaring class is strongly referenced but that condition is rarely met in practice. There is actually quite a lot of code around making it possible to use a jmethodID even if the declaring class is gone - one would not get any information for such jmethodID but it is not supposed to crash JVM when used.&lt;br/&gt;
&lt;br/&gt;
The crash has the following trace&lt;br/&gt;
&lt;br/&gt;
```&lt;br/&gt;
#&lt;br/&gt;
# A fatal error has been detected by the Java Runtime Environment:&lt;br/&gt;
#&lt;br/&gt;
#  SIGSEGV (0xb) at pc=0x00007f3f86175daf, pid=3423779, tid=3423802&lt;br/&gt;
#&lt;br/&gt;
# JRE version: OpenJDK Runtime Environment Temurin-20.0.1+9 (20.0.1+9) (build 20.0.1+9)&lt;br/&gt;
# Java VM: OpenJDK 64-Bit Server VM Temurin-20.0.1+9 (20.0.1+9, mixed mode, sharing, tiered, compressed oops, compressed class ptrs, parallel gc, linux-amd64)&lt;br/&gt;
# Problematic frame:&lt;br/&gt;
# V  [libjvm.so+0xc46daf]  Method::checked_resolve_jmethod_id(_jmethodID*)+0xf&lt;br/&gt;
#&lt;br/&gt;
# Core dump will be written. Default location: /usr/local/app/core.3423779&lt;br/&gt;
#&lt;br/&gt;
# JFR recording file will be written. Location: /usr/local/app/hs_err_pid3423779.jfr&lt;br/&gt;
#&lt;br/&gt;
# If you would like to submit a bug report, please visit:&lt;br/&gt;
#   &lt;a href=&quot;https://github.com/adoptium/adoptium-support/issues&quot;&gt;https://github.com/adoptium/adoptium-support/issues&lt;/a&gt;&lt;br/&gt;
#&lt;br/&gt;
```&lt;br/&gt;
&lt;br/&gt;
Attaching full log for posterity.</description>
                <environment></environment>
        <key id="5107491">JDK-8313816</key>
            <summary>Accessing jmethodID might lead to spurious crashes</summary>
                <type id="1" iconUrl="https://bugs.openjdk.org/secure/viewavatar?size=xsmall&amp;avatarId=14703&amp;avatarType=issuetype">Bug</type>
                                            <priority id="3" iconUrl="https://bugs.openjdk.org/images/jbsImages/p3.png">P3</priority>
                        <status id="5" iconUrl="https://bugs.openjdk.org/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="success"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="jbachorik">Jaroslav Bachor&#237;k</assignee>
                                    <reporter username="jbachorik">Jaroslav Bachor&#237;k</reporter>
                        <labels>
                            <label>amazon-interest</label>
                            <label>datadog-interest</label>
                            <label>jdk11u-fix-request</label>
                            <label>jdk11u-fix-yes</label>
                            <label>jdk17u-fix-request</label>
                            <label>jdk17u-fix-yes</label>
                            <label>jdk21u-fix-request</label>
                            <label>jdk21u-fix-yes</label>
                    </labels>
                <created>Sun, 6 Aug 2023 17:38:13 -0700</created>
                <updated>Fri, 22 Dec 2023 03:22:00 -0800</updated>
                            <resolved>Wed, 29 Nov 2023 09:32:18 -0800</resolved>
                                    <version>11</version>
                    <version>17</version>
                    <version>20</version>
                    <version>21</version>
                                    <fixVersion>22</fixVersion>
                                    <component>hotspot</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>12</watches>
                                                                                                                <comments>
                            <comment id="14635707" author="goetz" created="Wed, 20 Dec 2023 01:55:37 -0800"  >You are right, it is not explicitly stated there (except that you should fix in head first, which it says here &lt;a href=&quot;https://wiki.openjdk.org/display/JDKUpdates/JDK11u)&quot;&gt;https://wiki.openjdk.org/display/JDKUpdates/JDK11u)&lt;/a&gt;. I added this.</comment>
                            <comment id="14635416" author="jbachorik" created="Tue, 19 Dec 2023 04:24:17 -0800"  >I went through the linked document and also &lt;a href=&quot;https://openjdk.org/guide/#backporting&quot;&gt;https://openjdk.org/guide/#backporting&lt;/a&gt; and &lt;a href=&quot;https://openjdk.org/projects/jdk-updates/approval.html&quot;&gt;https://openjdk.org/projects/jdk-updates/approval.html&lt;/a&gt; and I really can not find anything about the prerequisite of the backport having been integrated in a later version before labelling it for backport in an earlier version.&lt;br/&gt;
I am not arguing about the process as it is upon the maintainer to decide what is best for them but it would be nice to have this prerequisite mentioned in the documents somewhere.</comment>
                            <comment id="14635366" author="goetz" created="Tue, 19 Dec 2023 02:28:01 -0800"  >@Jaroslav, I check the issues everyday. If they are not ready for approval, I remove the tags, else my workload of rechecking will be too big.  This is documented in &lt;a href=&quot;https://wiki.openjdk.org/display/JDKUpdates/How+to+contribute+or+backport+a+fix&quot;&gt;https://wiki.openjdk.org/display/JDKUpdates/How+to+contribute+or+backport+a+fix&lt;/a&gt;&lt;br/&gt;
The change is pending for approval in 21.</comment>
                            <comment id="14634894" author="roboduke" created="Mon, 18 Dec 2023 01:41:24 -0800"  >A pull request was submitted for review.&lt;br/&gt;
URL: &lt;a href=&quot;https://git.openjdk.org/jdk21u-dev/pull/56&quot;&gt;https://git.openjdk.org/jdk21u-dev/pull/56&lt;/a&gt;&lt;br/&gt;
Date: 2023-12-18 09:33:57 +0000</comment>
                            <comment id="14634890" author="jbachorik" created="Mon, 18 Dec 2023 01:27:14 -0800"  >@goetz Any particular reason for removing the jdk11u-fix-request and jdk17u-fix-request labels?</comment>
                            <comment id="14634389" author="sgehwolf" created="Thu, 14 Dec 2023 10:21:29 -0800"  >Removing OpenJDK 21u approval request since this needs a jdk21u-dev PR first.</comment>
                            <comment id="14632631" author="roboduke" created="Fri, 8 Dec 2023 03:27:14 -0800"  >[jdk17u-fix-request] Approval Request from Jaroslav Bachorik&lt;br/&gt;
Please, approve this backport of a fix improving stability of stack sampling profilers. The changed code is relevant only to retransformed method and the change itself is very simple - just nulling out any dangling pointers.</comment>
                            <comment id="14632618" author="roboduke" created="Fri, 8 Dec 2023 02:37:27 -0800"  >[jdk21u-fix-request] Approval Request from Jaroslav Bachorik&lt;br/&gt;
</comment>
                            <comment id="14632617" author="roboduke" created="Fri, 8 Dec 2023 02:37:13 -0800"  >[jdk11u-fix-request] Approval Request from Jaroslav Bachorik&lt;br/&gt;
Please, approve this backport of a fix improving stability of stack sampling profilers. The changed code is relevant only to retransformed method and the change itself is very simple - just nulling out any dangling pointers.</comment>
                            <comment id="14630666" author="roboduke" created="Fri, 1 Dec 2023 08:47:02 -0800"  >A pull request was submitted for review.&lt;br/&gt;
URL: &lt;a href=&quot;https://git.openjdk.org/jdk21u/pull/411&quot;&gt;https://git.openjdk.org/jdk21u/pull/411&lt;/a&gt;&lt;br/&gt;
Date: 2023-11-29 18:13:14 +0000</comment>
                            <comment id="14630618" author="roboduke" created="Fri, 1 Dec 2023 07:00:20 -0800"  >A pull request was submitted for review.&lt;br/&gt;
URL: &lt;a href=&quot;https://git.openjdk.org/jdk17u-dev/pull/2001&quot;&gt;https://git.openjdk.org/jdk17u-dev/pull/2001&lt;/a&gt;&lt;br/&gt;
Date: 2023-11-29 18:35:30 +0000</comment>
                            <comment id="14630617" author="roboduke" created="Fri, 1 Dec 2023 06:59:06 -0800"  >A pull request was submitted for review.&lt;br/&gt;
URL: &lt;a href=&quot;https://git.openjdk.org/jdk11u-dev/pull/2321&quot;&gt;https://git.openjdk.org/jdk11u-dev/pull/2321&lt;/a&gt;&lt;br/&gt;
Date: 2023-11-30 17:03:06 +0000</comment>
                            <comment id="14630000" author="dukebot" created="Wed, 29 Nov 2023 09:32:17 -0800"  >Changeset: cdd1a6e8&lt;br/&gt;
Author:    Jaroslav Bachorik &amp;lt;&lt;a href=&apos;mailto:jbachorik@openjdk.org&apos;&gt;jbachorik@openjdk.org&lt;/a&gt;&amp;gt;&lt;br/&gt;
Date:      2023-11-29 17:29:52 +0000&lt;br/&gt;
URL:       &lt;a href=&quot;https://git.openjdk.org/jdk/commit/cdd1a6e851bcaf4a25d4a405b8ee0b0d5b83a4a9&quot;&gt;https://git.openjdk.org/jdk/commit/cdd1a6e851bcaf4a25d4a405b8ee0b0d5b83a4a9&lt;/a&gt;&lt;br/&gt;
</comment>
                            <comment id="14627004" author="roboduke" created="Thu, 16 Nov 2023 12:35:09 -0800"  >A pull request was submitted for review.&lt;br/&gt;
URL: &lt;a href=&quot;https://git.openjdk.org/jdk/pull/16662&quot;&gt;https://git.openjdk.org/jdk/pull/16662&lt;/a&gt;&lt;br/&gt;
Date: 2023-11-14 17:56:09 +0000</comment>
                            <comment id="14626263" author="jbachorik" created="Tue, 14 Nov 2023 11:27:17 -0800"  >I have changed the issue type back to bug as the root cause is actually incomplete handling of a corner case.&lt;br/&gt;
&lt;br/&gt;
In short, if a class gets retransformed while a particular method is on stack and a stacktrace containing the frame pointing to that method is captured at that time and an attempt to use the jmethodid of such a frame will result in crash in `Method::checked_resolve_jmethod_id` call,&lt;br/&gt;
&lt;br/&gt;
I was able to craft a JTREG test exhibiting the crash and am currently preparing PR addressing this problem (&lt;a href=&quot;https://github.com/openjdk/jdk/pull/16662&quot;&gt;https://github.com/openjdk/jdk/pull/16662&lt;/a&gt;)</comment>
                            <comment id="14603116" author="jbachorik" created="Wed, 9 Aug 2023 23:10:29 -0700"  >A side note - it is quite interesting that ASGCT is not triggering this issue en-mass.&lt;br/&gt;
It is also generating the stacktraces with frames identified by jmethodIDs and because we are obtaining those stacktraces in a signal handler we really can not do anything else but store it and process later - resolving jmethodID to method FQN is not really possible in a signal handler. Yet, we haven&amp;#39;t seen a single crash reported for the data generated by ASGCT.</comment>
                            <comment id="14603114" author="jbachorik" created="Wed, 9 Aug 2023 23:05:27 -0700"  >[~apangin] Yes, you are correct, this particular log is showing an issue in the profiler (and I think you fixed that issue a while ago). &lt;br/&gt;
I have a collection of hs_err logs for crashes in checked_resolve_jmethod_id and I managed to pick the least interesting one to attach to this issue :/&lt;br/&gt;
&lt;br/&gt;
I could attach them to this issue or file a new one - what would you prefer [~dholmes]?&lt;br/&gt;
&lt;br/&gt;
[~coleenp]&lt;br/&gt;
&amp;gt; Maybe the agent caller should save the name and information from the methods that it needs to guard against the Methods that the jmethodIDs are pointing to&lt;br/&gt;
&lt;br/&gt;
This sounds interesting. I will try that.</comment>
                            <comment id="14602968" author="coleenp" created="Wed, 9 Aug 2023 06:55:10 -0700"  >Yes:&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;// Method::clear_jmethod_ids only sets the jmethod_ids to null without&lt;br/&gt;
&amp;nbsp;&amp;nbsp;// releasing the memory for related JNIMethodBlocks and JNIMethodBlockNodes.&lt;br/&gt;
&amp;nbsp;&amp;nbsp;// This is done intentionally because native code (e.g. JVMTI agent) holding&lt;br/&gt;
&amp;nbsp;&amp;nbsp;// jmethod_ids may access them after the associated classes and class loader&lt;br/&gt;
&amp;nbsp;&amp;nbsp;// are unloaded. The Java Native Interface Specification says &amp;quot;method ID&lt;br/&gt;
&amp;nbsp;&amp;nbsp;// does not prevent the VM from unloading the class from which the ID has&lt;br/&gt;
&amp;nbsp;&amp;nbsp;// been derived. After the class is unloaded, the method or field ID becomes&lt;br/&gt;
&amp;nbsp;&amp;nbsp;// invalid&amp;quot;. In real world usages, the native code may rely on jmethod_ids&lt;br/&gt;
&amp;nbsp;&amp;nbsp;// being null after class unloading. Hence, it is unsafe to free the memory&lt;br/&gt;
&amp;nbsp;&amp;nbsp;// from the VM side without knowing when native code is going to stop using&lt;br/&gt;
&amp;nbsp;&amp;nbsp;// them.&lt;br/&gt;
&lt;br/&gt;
We don&amp;#39;t have JNIMethodBlockNodes anymore though.</comment>
                            <comment id="14602779" author="dholmes" created="Tue, 8 Aug 2023 16:40:05 -0700"  >[~coleenp] are you saying that the actual jMethodIDs are pointers to type-stable-memory that is never released or reused?</comment>
                            <comment id="14602687" author="coleenp" created="Tue, 8 Aug 2023 10:41:26 -0700"  >[~apangin] You&amp;#39;re correct in that after the class is unloaded, the slots are cleared. But they are never reused (causing what looks like a leak).  If you try to get the Method* of a cleared jmethodID, you&amp;#39;ll get nullptr and can do an error check on that.&lt;br/&gt;
&lt;br/&gt;
If JVMTI GetStackTrace gets an array of jmethodID, they should be not unloaded because they&amp;#39;re on the stack.  Maybe the agent caller should save the name and information from the methods that it needs to guard against the Methods that the jmethodIDs are pointing to. I don&amp;#39;t know this part of JVMTI very well.</comment>
                            <comment id="14602571" author="apangin" created="Tue, 8 Aug 2023 04:34:26 -0700"  >As I can see, slots in JNIMethodBlock that jmethodIDs point to, are first marked as &amp;quot;empty&amp;quot; during class unloading, and the actual deallocation of `Method` structures happen later after a safepoint. A safepoint between clearing and deallocation guarantees that an application does not access released memory. In the worst case, a JVM TI function called on a stale jmethodID either returns JVMTI_ERROR_INVALID_METHODID or resolves a different method (if a slot has been reused), but it should never crash the JVM.&lt;br/&gt;
&lt;br/&gt;
If it doesn&amp;#39;t work this way - this is apparently a JVM bug that needs to be fixed. Please correct me if my understanding is wrong.&lt;br/&gt;
&lt;br/&gt;
In this particular case, however, the issue is clearly in the agent, not in the JDK. Note the value of RDI register which holds jmethodID argument: 0x000000000000000c. This is just garbage, it cannot be a stale jmethodID returned by the JVM.</comment>
                            <comment id="14602501" author="dholmes" created="Tue, 8 Aug 2023 00:48:00 -0700"  >&amp;gt;  Being able to crash JVM by obtaining a stacktrace via JVMTI and then trying to use the jmethodids returned in that stacktrace, possibly in the same call, does not sound like an enhancement.&lt;br/&gt;
&lt;br/&gt;
If you are obtaining the stacktrace of another thread and do nothing to ensure the other thread can&amp;#39;t continue such that any classes in its stack become unreferenced and so can be unloaded, then you have a buggy app - sorry. The spec is very clear on this.&lt;br/&gt;
&lt;br/&gt;
&amp;gt; I accept invalid jmethodids - but not even being able to check for whether a jmethodid is invalid sounds like a bug.&lt;br/&gt;
&lt;br/&gt;
I agree it is a hole in the JVM TI specification, but a missing feature is not itself a bug. In the current context anything that is done to make the VM more resilient wrt. invalid jmehtodIDs is an enhancement.&lt;br/&gt;
&lt;br/&gt;
[~apangin] Hotspot has very limited protection against stale jmethodIds.</comment>
                            <comment id="14602457" author="apangin" created="Mon, 7 Aug 2023 19:06:26 -0700"  >@jbachorik Why do you think this is a bug in the JVM and not in your agent? The crash dump suggests it&amp;#39;s the latter: the value passed to JVM TI function is not a valid pointer. Also, I haven&amp;#39;t seen such crashes with async-profiler for a long time.&lt;br/&gt;
&lt;br/&gt;
As I commented in the PR, HotSpot already has protection against stale jmethodIDs, and the proposed change does seem not fix anything.</comment>
                            <comment id="14602446" author="roboduke" created="Mon, 7 Aug 2023 17:14:33 -0700"  >A pull request was submitted for review.&lt;br/&gt;
URL: &lt;a href=&quot;https://git.openjdk.org/jdk/pull/15171&quot;&gt;https://git.openjdk.org/jdk/pull/15171&lt;/a&gt;&lt;br/&gt;
Date: 2023-08-07 00:50:30 +0000</comment>
                            <comment id="14602444" author="jbachorik" created="Mon, 7 Aug 2023 16:45:17 -0700"  >[~dholmes] I am sorry, I am not buying this. Being able to crash JVM by obtaining a stacktrace via JVMTI and then trying to use the jmethodids returned in that stacktrace, possibly in the same call, does not sound like an enhancement.&lt;br/&gt;
I accept invalid jmethodids - but not even being able to check for whether a jmethodid is invalid sounds like a bug.&lt;br/&gt;
&lt;br/&gt;
I went over the places where the Method is being released and in almost all the places the jmethodid is updated to point to NULL, which is detectable by JVMTI and I would get jvmtiError instead of JVM crash (which is a very desirable outcome). &lt;br/&gt;
This place is in the metadata repository cleanup where class and method structures are deallocated without the corresponding jmethodids being NULLed, leaving all the holders at risk of potentially accessing memory after being freed.&lt;br/&gt;
&lt;br/&gt;
I have opened a PR with the proposed fix (&lt;a href=&quot;https://github.com/openjdk/jdk/pull/15171&quot;&gt;https://github.com/openjdk/jdk/pull/15171&lt;/a&gt;) - this is a best effort fix since I am not able to reliably reproduce the crash, but considering the expected and actual behaviour I think the gist of the fix is correct.</comment>
                            <comment id="14602136" author="dholmes" created="Sun, 6 Aug 2023 18:21:07 -0700"  >This is not a bug as behaviour is within spec. I&amp;#39;ve changed to an enhancement request but there is no plan to try and make jmethodIds more resilient in this regard. </comment>
                            <comment id="14602109" author="dholmes" created="Sun, 6 Aug 2023 18:12:17 -0700"  >[~jbachorik] This issue has been raised a number of times and the position is still the same - the spec puts the burden on the programmer to maintain the validity of jmethodIds and yes the VM can crash if the application doesn&amp;#39;t do this. The spec was recently updated to make this even clearer: &lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8268416&quot; title=&quot;Clarify invalid method and field ID in JNI specification&quot; class=&quot;issue-link&quot; data-issue-key=&quot;JDK-8268416&quot;&gt;&lt;strike&gt;JDK-8268416&lt;/strike&gt;&lt;/a&gt;. Also see &lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8268406&quot; title=&quot;Deallocate jmethodID native memory&quot; class=&quot;issue-link&quot; data-issue-key=&quot;JDK-8268406&quot;&gt;&lt;strike&gt;JDK-8268406&lt;/strike&gt;&lt;/a&gt;.</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10200">
                    <name>Backport</name>
                                            <outwardlinks description="backported by">
                                        <issuelink>
            <issuekey id="5117687">JDK-8322635</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="5117746">JDK-8322689</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="5117747">JDK-8322690</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="105023" name="hs_err_jmethodid.log" size="153625" author="jbachorik" created="Sun, 6 Aug 2023 17:37:56 -0700"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_11700" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_10600" key="com.oracle.jira.javabugsystem-jira-plugin:jbs-fixedBackportedCustomfield">
                        <customfieldname>Fixed</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_11100" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i32n1n:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_11004" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10006" key="com.atlassian.jira.plugin.system.customfieldtypes:select">
                        <customfieldname>Resolved In Build</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="17357"><![CDATA[b26]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10008" key="com.oracle.jira.jira-subcomponent-plugin:oracle-subComponentField">
                        <customfieldname>Subcomponent</customfieldname>
                        <customfieldvalues>
                             <customfieldvalue key="372"><![CDATA[jvmti]]></customfieldvalue> 
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_10601" key="com.oracle.jira.javabugsystem-jira-plugin:jbs-targetBackportedCustomfield">
                        <customfieldname>Targeted</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    </customfields>
    </item>
</channel>
</rss>