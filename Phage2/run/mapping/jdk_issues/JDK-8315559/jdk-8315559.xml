<!-- 
RSS generated by JIRA (9.12.27#9120027-sha1:edc4490121e366e9e7bd2213d532dbe7e028fc5d) at Tue Sep 30 11:37:13 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>Java Bug System</title>
    <link>https://bugs.openjdk.org</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-us</language>    <build-info>
        <version>9.12.27</version>
        <build-number>9120027</build-number>
        <build-date>02-09-2025</build-date>
    </build-info>


<item>
            <title>[JDK-8315559] Delay TempSymbol cleanup to avoid symbol table churn</title>
                <link>https://bugs.openjdk.org/browse/JDK-8315559</link>
                <project id="10100" key="JDK">JDK</project>
                    <description>Dacapo pmd benchmark (`java -jar dacapo-9.12-MR1.jar --size large --iterations 20 pmd`) regressed 5-20% on all platforms.&lt;br/&gt;
&lt;br/&gt;
This is caused by &lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8313678&quot; title=&quot;SymbolTable can leak Symbols during cleanup&quot; class=&quot;issue-link&quot; data-issue-key=&quot;JDK-8313678&quot;&gt;&lt;strike&gt;JDK-8313678&lt;/strike&gt;&lt;/a&gt;, which fixed a symbol leak, but the leak was actually beneficial to performance in some cases as it allowed cheap temp symbol re-use instead of churning symbols with the associated cleanup and recreation cost.&lt;br/&gt;
&lt;br/&gt;
</description>
                <environment></environment>
        <key id="5109503">JDK-8315559</key>
            <summary>Delay TempSymbol cleanup to avoid symbol table churn</summary>
                <type id="1" iconUrl="https://bugs.openjdk.org/secure/viewavatar?size=xsmall&amp;avatarId=14703&amp;avatarType=issuetype">Bug</type>
                                            <priority id="3" iconUrl="https://bugs.openjdk.org/images/jbsImages/p3.png">P3</priority>
                        <status id="5" iconUrl="https://bugs.openjdk.org/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="success"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="ogillespie">Oli Gillespie</assignee>
                                    <reporter username="ecaspole">Eric Caspole</reporter>
                        <labels>
                            <label>amazon-interest</label>
                            <label>jdk17u-fix-request</label>
                            <label>jdk17u-fix-yes</label>
                            <label>jdk21u-fix-request</label>
                            <label>jdk21u-fix-yes</label>
                            <label>perf-regression</label>
                    </labels>
                <created>Fri, 1 Sep 2023 12:27:04 -0700</created>
                <updated>Mon, 3 Jun 2024 07:34:03 -0700</updated>
                            <resolved>Mon, 4 Dec 2023 04:27:28 -0800</resolved>
                                    <version>17.0.9</version>
                    <version>21.0.1</version>
                    <version>22</version>
                                    <fixVersion>22</fixVersion>
                                    <component>hotspot</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>9</watches>
                                                                                                                <comments>
                            <comment id="14667281" author="roboduke" created="Tue, 23 Apr 2024 01:39:34 -0700"  >[jdk17u-fix-request] Approval Request from olivergillespie&lt;br/&gt;
Fixes non-trivial performance regression in class-loading (dacapo pmd). Not clean due to file movement but simple to merge. Confirmed that the performance regression is present before the change and fixed after, using the original benchmark. Medium risk as it affects Symbol creation, but has been working in tip and 21 for a few months with no associated issues.</comment>
                            <comment id="14666988" author="roboduke" created="Mon, 22 Apr 2024 08:38:37 -0700"  >A pull request was submitted for review.&lt;br/&gt;
URL: &lt;a href=&quot;https://git.openjdk.org/jdk17u-dev/pull/2424&quot;&gt;https://git.openjdk.org/jdk17u-dev/pull/2424&lt;/a&gt;&lt;br/&gt;
Date: 2024-04-22 15:35:14 +0000</comment>
                            <comment id="14640226" author="sgehwolf" created="Mon, 15 Jan 2024 09:44:12 -0800"  >This should have more time in mainline before backporting to 21.</comment>
                            <comment id="14639108" author="roboduke" created="Wed, 10 Jan 2024 07:22:26 -0800"  >[jdk21u-fix-request] Approval Request from olivergillespie&lt;br/&gt;
Re-requesting now that it has baked in mainline for a few months, and for parity with 21.0.4-oracle. The backport fixes a performance regression in class-loading which showed up as 5-20% regression in Dacapo pmd benchmark. It is not trivial code, so there is some risk, but with the baking I think it&amp;#39;s reasonable. No special testing performed.</comment>
                            <comment id="14638612" author="roboduke" created="Tue, 9 Jan 2024 08:51:44 -0800"  >A pull request was submitted for review.&lt;br/&gt;
URL: &lt;a href=&quot;https://git.openjdk.org/jdk21u-dev/pull/154&quot;&gt;https://git.openjdk.org/jdk21u-dev/pull/154&lt;/a&gt;&lt;br/&gt;
Date: 2024-01-09 16:46:27 +0000</comment>
                            <comment id="14630989" author="dukebot" created="Mon, 4 Dec 2023 04:27:27 -0800"  >Changeset: d23f4f12&lt;br/&gt;
Author:    Oli Gillespie &amp;lt;&lt;a href=&apos;mailto:ogillespie@openjdk.org&apos;&gt;ogillespie@openjdk.org&lt;/a&gt;&amp;gt;&lt;br/&gt;
Committer: Coleen Phillimore &amp;lt;&lt;a href=&apos;mailto:coleenp@openjdk.org&apos;&gt;coleenp@openjdk.org&lt;/a&gt;&amp;gt;&lt;br/&gt;
Date:      2023-12-04 12:25:51 +0000&lt;br/&gt;
URL:       &lt;a href=&quot;https://git.openjdk.org/jdk/commit/d23f4f12adf1ea26b8c340efe2c3854e50b68301&quot;&gt;https://git.openjdk.org/jdk/commit/d23f4f12adf1ea26b8c340efe2c3854e50b68301&lt;/a&gt;&lt;br/&gt;
</comment>
                            <comment id="14621602" author="roboduke" created="Fri, 27 Oct 2023 04:00:48 -0700"  >A pull request was submitted for review.&lt;br/&gt;
URL: &lt;a href=&quot;https://git.openjdk.org/jdk/pull/16398&quot;&gt;https://git.openjdk.org/jdk/pull/16398&lt;/a&gt;&lt;br/&gt;
Date: 2023-10-27 10:55:16 +0000</comment>
                            <comment id="14621569" author="JIRAUSER20804" created="Fri, 27 Oct 2023 01:35:27 -0700"  >Thanks. I agree it would be better just for temp symbols, but if that doesn&amp;#39;t work easily I don&amp;#39;t think it&amp;#39;s fatal - constant pool entries will be quickly pushed out of the queue if there is high volume temp symbol creation due to the push-pop behaviour when the queue fills up. The main downside I see with handling *all* symbols is the unnecessary overhead of extra queue operations.</comment>
                            <comment id="14621382" author="coleenp" created="Thu, 26 Oct 2023 08:53:19 -0700"  >I like the simplicity of keeping the bounded queue to 100 and not triggering cleanup, but draining the queue if we do have concurrent cleanup.  I like the prototype so far, hopefully it moves cleanly to TempNewSymbol because constant pool loads would use up all the entries in the queue and they&amp;#39;re never unloaded until class unloading time.</comment>
                            <comment id="14621363" author="JIRAUSER20804" created="Thu, 26 Oct 2023 08:06:57 -0700"  >Thanks for looking at it :) Since you&amp;#39;re okay with it in principle I&amp;#39;ll convert it to a PR and we can discuss the code details there. I&amp;#39;ll look at restricting it to TempNewSymbol.&lt;br/&gt;
&lt;br/&gt;
For the cleanup, what I meant was:&lt;br/&gt;
The queue insert logic keeps the queue size bounded (I&amp;#39;m using 100 for testing). So at most we&amp;#39;ll have 100 half-leaked entries.&lt;br/&gt;
If we don&amp;#39;t want a possibly indefinite retention of 100 entries, we could trigger has_work whenever the queue is not empty, but I tried that and it seems to trigger it too often, degrading performance.&lt;br/&gt;
We could have a threshold for concurrent cleanup somewhere between 0 and 100, but then is it really much benefit over the already bounded queue?</comment>
                            <comment id="14621359" author="coleenp" created="Thu, 26 Oct 2023 07:43:19 -0700"  >+    add_to_cleanup_delay_queue(sym); // TODO: only temp symbols?&lt;br/&gt;
&lt;br/&gt;
This might make sense.  Move the code to be used by TempNewSymbol.</comment>
                            <comment id="14621358" author="coleenp" created="Thu, 26 Oct 2023 07:36:04 -0700"  >Yes this patch is quite simple.  It increments refcount of recently added symbols for some amount of time and decrements them sometime later.  So you never return a symbol with a zero refcount (always refcount would be at least 2).&lt;br/&gt;
I like it.  The queue belongs in the .cpp file since nothing else refers to it.&lt;br/&gt;
&lt;br/&gt;
Not sure I understand your last sentence.  Cleanup won&amp;#39;t be triggered as often because lookup won&amp;#39;t find as many 0 refcount symbols.  But you could trigger has_work if the queue gets to some threshold of the symbol table size.&lt;br/&gt;
&lt;br/&gt;
Having a NonBlockingQueue is good that so we don&amp;#39;t need another CHT.</comment>
                            <comment id="14621270" author="JIRAUSER20804" created="Thu, 26 Oct 2023 02:59:37 -0700"  >I have prototyped Aleksey&amp;#39;s initial idea of a queue which delays symbol death, see attached symbol-delay-queue.patch. It brings performance back in line with the original code before the leak fix in my two tests (dacapo pmd and my `findLoadedClass(&amp;quot;does-not-exist&amp;quot; + Integer.valueOf(1)); ` benchmark above). I liked the idea because it feels relatively simple/non-invasive - I&amp;#39;m not sure I understand enough to try the second CHT idea. Two key things are missing - operate only on temp symbols, and consider async cleanup. Triggering async cleanup based on the queue being non-empty seems to be too often. I&amp;#39;m not sure if it&amp;#39;s needed, the queue is tightly bounded in number of entries but the entries could theoretically be large.</comment>
                            <comment id="14620161" author="coleenp" created="Mon, 23 Oct 2023 05:56:17 -0700"  >I think allowing Symbol revival would cause some hard to track down bugs, since entries are asynchronously deleted.  We had bugs like that when implementing this table.  Symbols going away unexpectedly.</comment>
                            <comment id="14619638" author="coleenp" created="Thu, 19 Oct 2023 12:52:37 -0700"  >Aleksey&amp;#39;s idea is interesting.  Here&amp;#39;s my interpretation: Instead of TempNewSymbol destructor decrementing the refcount, it could add the SymbolCleanup { Symbol*, refcount } node to a second CHT.  At class unloading time, or when the table hits a threshold, run through this table, decrement Symbol.refcounts number of node.refcount times, and clear out the table.  Trigger this from the ServiceThread_lock.&lt;br/&gt;
&lt;br/&gt;
Another asynchronous moving part but might help a lot with transient symbols that are eventually used.&lt;br/&gt;
&lt;br/&gt;
[~ogillespie] Would you like to prototype this?</comment>
                            <comment id="14619523" author="JIRAUSER20804" created="Thu, 19 Oct 2023 07:58:23 -0700"  >I think I understand now how we have &amp;#39;collisions&amp;#39; with just one symbol and why removing the sync cleanup path hurts performance (you probably already know this, but I needed to learn a bit more to understand fully).&lt;br/&gt;
&lt;br/&gt;
Back-to-back calls to TempSymbol SymbolTable::new_symbol(&amp;quot;foo&amp;quot;) always creates multiple entries, even if sync cleanup is removed. That&amp;#39;s because once a symbol is dead, it can never be revived (by choice to avoid concurrency issues - &lt;a href=&quot;https://github.com/openjdk/jdk/blob/master/src/hotspot/share/oops/symbol.cpp#L299)&quot;&gt;https://github.com/openjdk/jdk/blob/master/src/hotspot/share/oops/symbol.cpp#L299)&lt;/a&gt;. So without sync cleanup, we create a bad situation where the bucket for that symbol grows very long with &amp;#39;equal but dead&amp;#39; symbols that we have to trawl through all of before concluding that in fact we need to create a new symbol after all - plus the async cleanup has way more work to do with all the duplicate dead symbols.&lt;br/&gt;
After the first call, the bucket now has an existing (but dead) entry for the given string, which will reliably trigger the original leak on the next call, conveniently stopping the delete/create churn by creating one canonical entry that will never die and stops further entries being created. So my original leak test can actually use the same string twice to demonstrate the leak, not just two different strings with the same hashcode.&lt;br/&gt;
&lt;br/&gt;
Removing the &amp;#39;no revival allowed&amp;#39; safety net *and* sync cleanups actually gives me good performance, so I think that&amp;#39;s good evidence for my explanation. But I still don&amp;#39;t know the best option, not sure if it&amp;#39;s worth considering allowing symbol revival, or if you think Aleksey&amp;#39;s keepalive queue would be interesting to see?</comment>
                            <comment id="14618344" author="coleenp" created="Mon, 16 Oct 2023 05:25:06 -0700"  >Not cleaning up during add (allowing the service thread to do the work) is 10% worse than reverting all the changes from &lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8313670&quot; title=&quot;Simplify shared lib name handling code in some tests&quot; class=&quot;issue-link&quot; data-issue-key=&quot;JDK-8313670&quot;&gt;&lt;strike&gt;JDK-8313670&lt;/strike&gt;&lt;/a&gt;.</comment>
                            <comment id="14617877" author="coleenp" created="Thu, 12 Oct 2023 13:24:32 -0700"  >I am sending a build through performance testing that doesn&amp;#39;t clean on the insert path, and lets the service thread do all the work.  I don&amp;#39;t know if that change would help.</comment>
                            <comment id="14617872" author="shade" created="Thu, 12 Oct 2023 13:07:44 -0700"  >Oli and me discussed this today, and one thing that pops into mind is somehow delaying the removal of temporary symbols from symbol table. The wrinkle is that there is both sync (delete_in_bucket called from get path) and async (service thread) parts. So if we are able to maybe delay the synchronous cleanup, and let the async cleanup to act is enough?&lt;br/&gt;
&lt;br/&gt;
Without introducing Symbol age and other intrusive rewrites, we can _maybe_ go to SymbolTable::new_symbol, and on the path that inserts an new symbol, we _also_ increment the refcount and put that symbol on the global NonblockingQueue. Then a service thread comes in for async cleanup, pops symbols from the queue, decreases their refcounts, and thus makes &amp;quot;temp/garbage&amp;quot; symbols to be eligible for deletion. So the temp symbols would have a window between two async cleanups to be reused?&lt;br/&gt;
&lt;br/&gt;
Not sure if Oli wants to prototype it.</comment>
                            <comment id="14617860" author="coleenp" created="Thu, 12 Oct 2023 12:58:50 -0700"  >My test that does essentially the same thing gets similar results with -XX:+PrintStrimgTableStatistics:&lt;br/&gt;
&lt;br/&gt;
With leak Fixed:&lt;br/&gt;
Number of literals      :     16881 =   5255432 bytes, avg 311.000&lt;br/&gt;
Total footprint         :           =   5787672 bytes&lt;br/&gt;
&lt;br/&gt;
With Leak:&lt;br/&gt;
Number of literals      :     26043 =   8113976 bytes, avg 311.000&lt;br/&gt;
Total footprint         :           =   8792808 bytes&lt;br/&gt;
&lt;br/&gt;
I think fixing this leak is a Good Thing.&lt;br/&gt;
&lt;br/&gt;
The leak for the same symbol is that lookup for class loading has a TempNewSymbol, so the first instance is reclaimed for the lookup for AppClassLoader (is_dead=true), then the second call for PlatformLoader, adds the same name which gets an additional refcount while calling delete_in_bucket for the first name.&lt;br/&gt;
&lt;br/&gt;
I think without extensive rewrite, this performance problem for this dacapo benchmark may be the cost of correctness, but I&amp;#39;m still trying to think of some way to mitigate it.</comment>
                            <comment id="14617789" author="JIRAUSER20804" created="Thu, 12 Oct 2023 08:54:04 -0700"  >I am trying to understand the overhead a bit more deeply. I created this benchmark which I think reproduces the issue.&lt;br/&gt;
&lt;br/&gt;
```&lt;br/&gt;
MyClassLoader cl = new MyClassLoader();&lt;br/&gt;
&lt;br/&gt;
@Benchmark&lt;br/&gt;
public Class findLoadedClass() {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return cl.find();&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
static class MyClassLoader extends ClassLoader {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public Class find() {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return findLoadedClass(&amp;quot;does-not-exist&amp;quot; + Integer.valueOf(1));&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
}&lt;br/&gt;
```&lt;br/&gt;
&lt;br/&gt;
I&amp;#39;ve attached a flame graph of this running with and without the leak fix. We can see that SymbolTable::do_add_if_needed is the big difference, with most of the cost being delete_in_bucket. I don&amp;#39;t fully understand it, the original leak requires a collision between two symbols, but this repro works with just one symbol.</comment>
                            <comment id="14617741" author="JIRAUSER20804" created="Thu, 12 Oct 2023 06:02:36 -0700"  >Yes, I had an application running Groovy 4 which was leaking memory at a significant overall rate due to this, combined with a bug/issue in Groovy which can cause churn of LambdaForms classes (&lt;a href=&quot;https://issues.apache.org/jira/browse/GROOVY-11152&quot;&gt;https://issues.apache.org/jira/browse/GROOVY-11152&lt;/a&gt;). However in well-behaved applications I don&amp;#39;t expect this to be a bad leak, so I wouldn&amp;#39;t say the leak fix is high priority. Also my application has avoided the issue by using Groovy 3, anyway, so it won&amp;#39;t affect me personally if we decide to revert. That being said, I wonder how realistic/important the pmd benchmark is in this case - it&amp;#39;s only repeated failed classloading with the same name which is improved by the accidental cache, right? Successful loading shouldn&amp;#39;t be affected as I understand it, and that seems the more important case to optimize. As an aside, I&amp;#39;ve often thought caching of negative results from classloaders would be useful for performance, I&amp;#39;ve seen a lot of applications which repeatedly look for classes that will never be there, and I would guess an unchanging classpath is the most common situation.&lt;br/&gt;
</comment>
                            <comment id="14617731" author="coleenp" created="Thu, 12 Oct 2023 04:59:44 -0700"  >[~ogillespie] Was there an observed problem running an application that made you discover this leak?  I see you backported the fix.</comment>
                            <comment id="14617493" author="coleenp" created="Wed, 11 Oct 2023 04:55:47 -0700"  >&lt;br/&gt;
Making JVM_FindLoadedClass leak symbols reduces the dead symbols to 54171.  Still a lot.  It seems that this leak for transient symbols was good for performance.&lt;br/&gt;
&lt;br/&gt;
When we moved Symbol out of PermGen over a decade ago, we settled on an implementation that allowed us to use Symbol* directly and had refcounting so that unused Symbols could be reclaimed from the SymbolTable. This design and implementation has been buggy for years.  Most Symbols are never reclaimed, the percentage was like 5% when we were reclaiming symbols at a safepoint.  Now with the CHT, we&amp;#39;re more eager about reclaiming symbols, which is a good thing.  But fixing this leak makes them work a bit too well.&lt;br/&gt;
&lt;br/&gt;
Maybe it&amp;#39;s time for an alternate design?  Bring back SymbolHandle for on stack use in the VM, and make it work like methodHandles for reclamation?  Like MetadataOnStackMark?  This requires work during a safepoint (pause) but we&amp;#39;d probably almost never do it.</comment>
                            <comment id="14617283" author="coleenp" created="Tue, 10 Oct 2023 13:19:12 -0700"  >&lt;br/&gt;
It looks like class loading is affected by patching up this leak. When looking up a class, we call JVM_FindLoadedClass for the hierarchy of class loaders.  That function has a TempNewSymbol to deallocate a Symbol after searching for whether its loaded.  With the leak fixed, each time we look up a symbol, it&amp;#39;s deallocated rather than reused.&lt;br/&gt;
&lt;br/&gt;
With the patch I have  1102485 total dead symbols.  Without the patch I have 2663.  I added logging to the is_dead function.</comment>
                            <comment id="14617165" author="JIRAUSER20804" created="Tue, 10 Oct 2023 06:49:50 -0700"  >Very good point - my patch reintroduces the leak, so your idea that we&amp;#39;re detecting more dead symbols with the leak fix seems reasonable. I added logging to is_dead and I observe around 200,000 `true` returns per Dacapo iteration, compared to 0 (after a few warmup rounds) with the additional equals call. I also observe around 70,000 SymbolTable::do_add_if_needed calls, again compared to 0 before. Here are the top matches:&lt;br/&gt;
&lt;br/&gt;
```&lt;br/&gt;
net/sourceforge/pmd/ast/RuntimeException&lt;br/&gt;
java/util/RuntimeException&lt;br/&gt;
net/sourceforge/pmd/ast/JJTFORINIT&lt;br/&gt;
net/sourceforge/pmd/SimpleJavaNode&lt;br/&gt;
net/sourceforge/pmd/ast/LookaheadSuccess&lt;br/&gt;
&amp;nbsp;&amp;nbsp;...&lt;br/&gt;
```&lt;br/&gt;
&lt;br/&gt;
So could this mean we&amp;#39;re seeing high symbol churn in the benchmark when the leak is fixed, and before with the leak we were accidentally caching the symbols, saving time deleting and re-creating them? I&amp;#39;m not sure how that idea fits with your CLEAN_DEAD_HIGH_WATER_MARK patch though, I would expect that to help in this case.</comment>
                            <comment id="14617146" author="coleenp" created="Tue, 10 Oct 2023 05:01:26 -0700"  >[~ogillespie] This is really interesting, and is consistent with my findings as well.&lt;br/&gt;
&lt;br/&gt;
On linux-x64:&lt;br/&gt;
&lt;br/&gt;
Reverting all the changes for &lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8313670&quot; title=&quot;Simplify shared lib name handling code in some tests&quot; class=&quot;issue-link&quot; data-issue-key=&quot;JDK-8313670&quot;&gt;&lt;strike&gt;JDK-8313670&lt;/strike&gt;&lt;/a&gt; vs master (sources with changes) : -5.55%&lt;br/&gt;
Reverting all the changes vs. your first fix to add another parameter to equals: -5.65%&lt;br/&gt;
Reverting all the changes vs. a fix to keep is_dead() function but use the original is_dead parameter for equals: -6.40%&lt;br/&gt;
Reverting all the changes vs. above with calling bucket_delete only on the slow lookup (with some threshold for triggering the service thread less frequently) : -9.17%&lt;br/&gt;
&lt;br/&gt;
I really thought the performance problem was the lookup calling both equals then is_dead() but the results don&amp;#39;t improve with changing that.  I also thought there were more dead Symbols detected because the leak is fixed.  This is a diff for #3 above, which doesn&amp;#39;t help.&lt;br/&gt;
&lt;br/&gt;
&lt;a href=&quot;https://github.com/openjdk/jdk/pull/16118&quot;&gt;https://github.com/openjdk/jdk/pull/16118&lt;/a&gt;&lt;br/&gt;
&lt;br/&gt;
I&amp;#39;ll try your patch.  I don&amp;#39;t have any explanation why this is happening.  I was going to suggest that correctness (no leaks) is costing us 5% performance.&lt;br/&gt;
&lt;br/&gt;
edit: The patch to add &amp;#39;equals&amp;#39; in delete_in_bucket reintroduces the leak (and fails the gtest you added).&lt;br/&gt;
</comment>
                            <comment id="14617130" author="JIRAUSER20804" created="Tue, 10 Oct 2023 04:00:46 -0700"  >In my testing (x86), it seems we can &amp;#39;fix&amp;#39; the regression with this patch. I have no idea why, but it seems to indicate that the issue is not the new is_dead function but the removal of the equals call.&lt;br/&gt;
&lt;br/&gt;
diff --git a/src/hotspot/share/utilities/concurrentHashTable.inline.hpp b/src/hotspot/share/utilities/concurrentHashTable.inline.hpp&lt;br/&gt;
index b222d379b72..ae256a5ef20 100644&lt;br/&gt;
--- a/src/hotspot/share/utilities/concurrentHashTable.inline.hpp&lt;br/&gt;
+++ b/src/hotspot/share/utilities/concurrentHashTable.inline.hpp&lt;br/&gt;
@@ -545,6 +545,7 @@ inline void ConcurrentHashTable&amp;lt;CONFIG, F&amp;gt;::&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;Node* const volatile * rem_n_prev = bucket-&amp;gt;first_ptr();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;Node* rem_n = bucket-&amp;gt;first();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;while (rem_n != nullptr) {&lt;br/&gt;
+    lookup_f.equals(rem_n-&amp;gt;value()); // ???&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if (lookup_f.is_dead(rem_n-&amp;gt;value())) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ndel[dels++] = rem_n;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Node* next_node = rem_n-&amp;gt;next();</comment>
                            <comment id="14616454" author="shade" created="Fri, 6 Oct 2023 05:49:00 -0700"  >This one is indeed puzzling. From the profiles, I notice that: a) even after 20 iterations we have plenty of C2 compiles; b) there are lots of exceptions thrown from pmd code; c) there is considerable contention on internal pmd locks. I am beginning to suspect the either of these three things got worse somehow. </comment>
                            <comment id="14615067" author="coleenp" created="Fri, 29 Sep 2023 13:54:53 -0700"  >So far, I&amp;#39;ve found that the regression seems to be caused by delete_in_bucket() calling the new is_dead() function rather than calling equals(&amp;amp;is_dead).  The is_dead() function does little but possibly because of the number of calls for table insertions, there&amp;#39;s some cache misses that show a performance regression.  I don&amp;#39;t really understand it.&lt;br/&gt;
If I revert the change, the performance is measurably better.  If I revert most of the change and keep is_dead() function, the performance is not better.</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10200">
                    <name>Backport</name>
                                            <outwardlinks description="backported by">
                                        <issuelink>
            <issuekey id="5122759">JDK-8326985</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="5124602">JDK-8328502</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="5130899">JDK-8333441</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                            <issuelinktype id="10003">
                    <name>Relates</name>
                                                                <inwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="5107305">JDK-8313678</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="5116047">JDK-8321276</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="106779" name="8315559-flame-comparison.png" size="269908" author="ogillespie" created="Thu, 12 Oct 2023 08:56:54 -0700"/>
                            <attachment id="106902" name="symbol-delay-queue.patch" size="4657" author="ogillespie" created="Thu, 26 Oct 2023 03:00:03 -0700"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_11700" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_10600" key="com.oracle.jira.javabugsystem-jira-plugin:jbs-fixedBackportedCustomfield">
                        <customfieldname>Fixed</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    <customfield id="customfield_10003" key="com.atlassian.jira.plugin.system.customfieldtypes:select">
                        <customfieldname>Introduced In Build</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="17460"><![CDATA[b11]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                    <customfield id="customfield_11100" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i32zgr:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_11004" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10006" key="com.atlassian.jira.plugin.system.customfieldtypes:select">
                        <customfieldname>Resolved In Build</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="17419"><![CDATA[b27]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10008" key="com.oracle.jira.jira-subcomponent-plugin:oracle-subComponentField">
                        <customfieldname>Subcomponent</customfieldname>
                        <customfieldvalues>
                             <customfieldvalue key="192"><![CDATA[runtime]]></customfieldvalue> 
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_10601" key="com.oracle.jira.javabugsystem-jira-plugin:jbs-targetBackportedCustomfield">
                        <customfieldname>Targeted</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    </customfields>
    </item>
</channel>
</rss>