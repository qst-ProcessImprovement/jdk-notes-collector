<!-- 
RSS generated by JIRA (9.12.27#9120027-sha1:edc4490121e366e9e7bd2213d532dbe7e028fc5d) at Tue Sep 30 14:27:57 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>Java Bug System</title>
    <link>https://bugs.openjdk.org</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-us</language>    <build-info>
        <version>9.12.27</version>
        <build-number>9120027</build-number>
        <build-date>02-09-2025</build-date>
    </build-info>


<item>
            <title>[JDK-8297638] Memory leak in case of many started-dead threads</title>
                <link>https://bugs.openjdk.org/browse/JDK-8297638</link>
                <project id="10100" key="JDK">JDK</project>
                    <description>The full description is in the bug &lt;a href=&quot;https://youtrack.jetbrains.com/issue/IDEA-305777/Memory-leak-from-com.jetbrains.jdi.VirtualMachineImpl-when-debugging-programs&quot;&gt;https://youtrack.jetbrains.com/issue/IDEA-305777/Memory-leak-from-com.jetbrains.jdi.VirtualMachineImpl-when-debugging-programs&lt;/a&gt;.&lt;br/&gt;
In short: if the program is creating a lot of short living threads and just being run under the debugger with enabled threadStart and threadDeath events enabled, jdi will consume more and more memory until OOM.&lt;br/&gt;
The problem is split into two places:&lt;br/&gt;
1. VirtualMachineImpl.processBatchedDisposes is invoked only inside waitForTargetReply, so if no commands are sent to the debugger it will never be called and batchedDisposeRequests may grow too big&lt;br/&gt;
2. unreachable listeners are removed from VMState.listeners only when something is happening with the debugger (VMState.processVMAction is called), which is not happening in our case, so listeners list grows and grows&lt;br/&gt;
&lt;br/&gt;
We&amp;#39;ve fixed this in IntelliJ jdi fork this way: &lt;a href=&quot;https://github.com/JetBrains/intellij-deps-jdi/commit/ca1b639d9fd648dd075f258517fdd1635d0eec2d&quot;&gt;https://github.com/JetBrains/intellij-deps-jdi/commit/ca1b639d9fd648dd075f258517fdd1635d0eec2d&lt;/a&gt;&lt;br/&gt;
&lt;a href=&quot;https://github.com/JetBrains/intellij-deps-jdi/commit/0b6b28d83e4ceaf3a550ebbf1eaeaf23b650f1c7&quot;&gt;https://github.com/JetBrains/intellij-deps-jdi/commit/0b6b28d83e4ceaf3a550ebbf1eaeaf23b650f1c7&lt;/a&gt;&lt;br/&gt;
&lt;br/&gt;
probably worth fixing in openjdk as well</description>
                <environment></environment>
        <key id="5088325">JDK-8297638</key>
            <summary>Memory leak in case of many started-dead threads</summary>
                <type id="1" iconUrl="https://bugs.openjdk.org/secure/viewavatar?size=xsmall&amp;avatarId=14703&amp;avatarType=issuetype">Bug</type>
                                            <priority id="4" iconUrl="https://bugs.openjdk.org/images/jbsImages/p4.png">P4</priority>
                        <status id="5" iconUrl="https://bugs.openjdk.org/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="success"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="cjplummer">Chris Plummer</assignee>
                                    <reporter username="eushakov">Egor Ushakov</reporter>
                        <labels>
                            <label>capbug</label>
                    </labels>
                <created>Fri, 25 Nov 2022 05:23:45 -0800</created>
                <updated>Wed, 13 Aug 2025 06:02:16 -0700</updated>
                            <resolved>Fri, 17 Mar 2023 17:26:08 -0700</resolved>
                                                    <fixVersion>21</fixVersion>
                                    <component>core-svc</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>10</watches>
                                                                                                                <comments>
                            <comment id="14567900" author="dukebot" created="Fri, 17 Mar 2023 17:26:07 -0700"  >Changeset: f8482c20&lt;br/&gt;
Author:    Chris Plummer &amp;lt;&lt;a href=&apos;mailto:cjplummer@openjdk.org&apos;&gt;cjplummer@openjdk.org&lt;/a&gt;&amp;gt;&lt;br/&gt;
Date:      2023-03-18 00:23:58 +0000&lt;br/&gt;
URL:       &lt;a href=&quot;https://git.openjdk.org/jdk/commit/f8482c20f4f55d4fc5b304a33c87775b5acfe2b8&quot;&gt;https://git.openjdk.org/jdk/commit/f8482c20f4f55d4fc5b304a33c87775b5acfe2b8&lt;/a&gt;&lt;br/&gt;
</comment>
                            <comment id="14567867" author="cjplummer" created="Fri, 17 Mar 2023 13:17:04 -0700"  >Since the initial recommended fix is working and well tested, I will be pushing it. I filed &lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8304432&quot; title=&quot;Provide better fix for 8297638: &amp;quot;Memory leak in case of many started-dead threads&amp;quot;&quot; class=&quot;issue-link&quot; data-issue-key=&quot;JDK-8304432&quot;&gt;JDK-8304432&lt;/a&gt; for Alan&amp;#39;s suggestion to use a WeakHashmap.</comment>
                            <comment id="14552512" author="roboduke" created="Wed, 18 Jan 2023 12:13:48 -0800"  >A pull request was submitted for review.&lt;br/&gt;
URL: &lt;a href=&quot;https://git.openjdk.org/jdk/pull/12081&quot;&gt;https://git.openjdk.org/jdk/pull/12081&lt;/a&gt;&lt;br/&gt;
Date: 2023-01-18 20:06:33 +0000</comment>
                            <comment id="14550550" author="cjplummer" created="Wed, 11 Jan 2023 20:12:35 -0800"  >Here&amp;#39;s a simpler test case that doesn&amp;#39;t require com.google.common.* or org.slf4j.Logger classes. Run with:&lt;br/&gt;
&lt;br/&gt;
import java.util.concurrent.ExecutorService;&lt;br/&gt;
import java.util.concurrent.Executors;&lt;br/&gt;
import java.util.concurrent.Semaphore;&lt;br/&gt;
import java.util.concurrent.ThreadFactory;&lt;br/&gt;
import java.util.concurrent.atomic.LongAdder;&lt;br/&gt;
&lt;br/&gt;
public class PTTest&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;private final ThreadFactory blockingTasksThreadFactory = new ThreadFactory() {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;@Override&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public Thread newThread(Runnable runnable) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Thread thread = Executors.defaultThreadFactory().newThread(runnable);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return thread;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;};&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;private final ExecutorService blockingTasksExecutor = Executors.&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;newThreadPerTaskExecutor(blockingTasksThreadFactory);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public static void main(String[] args) throws InterruptedException&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;PTTest testcase = new PTTest();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;testcase.run();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public void run() throws InterruptedException&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Semaphore semaphore = new Semaphore(500);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;LongAdder adder = new LongAdder();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;while (true) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;semaphore.acquire();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;blockingTasksExecutor.submit(() -&amp;gt; {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;adder.increment();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;long sum = adder.sum();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if ((sum % 1000) == 0)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.println(&amp;quot;Progress: &amp;quot; + sum);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;try {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Thread.sleep(50);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;catch (InterruptedException e) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;throw new RuntimeException(e);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;} finally {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;semaphore.release();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;});&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
}&lt;br/&gt;
</comment>
                            <comment id="14547247" author="cjplummer" created="Wed, 21 Dec 2022 11:11:38 -0800"  >It tried to reproduce this in jdb, but couldn&amp;#39;t until I did some hacking on jdb. VirtualMachineImpl.processBatchedDisposes() is constantly being called. ThreadStartEvent triggers the following:&lt;br/&gt;
&lt;br/&gt;
	at jdk.jdi/com.sun.tools.jdi.VirtualMachineImpl.processBatchedDisposes(VirtualMachineImpl.java:1328)&lt;br/&gt;
	at jdk.jdi/com.sun.tools.jdi.VirtualMachineImpl.waitForTargetReply(VirtualMachineImpl.java:1180)&lt;br/&gt;
	at jdk.jdi/com.sun.tools.jdi.PacketStream.waitForReply(PacketStream.java:89)&lt;br/&gt;
	at jdk.jdi/com.sun.tools.jdi.JDWP$VirtualMachine$Resume.waitForReply(JDWP.java:614)&lt;br/&gt;
	at jdk.jdi/com.sun.tools.jdi.VirtualMachineImpl.resume(VirtualMachineImpl.java:503)&lt;br/&gt;
	at jdk.jdi/com.sun.tools.jdi.EventSetImpl.resume(EventSetImpl.java:838)&lt;br/&gt;
	at jdk.jdi/com.sun.tools.example.debug.tty.EventHandler.run(EventHandler.java:82)&lt;br/&gt;
	at java.base/java.lang.Thread.run(Thread.java:1623)&lt;br/&gt;
&lt;br/&gt;
This is partly due to using the SUSPEND_ALL policy on the event request. I changed this to SUSPEND_NONE, and did so for ThreadDeathRequest also. I also had to change jdb to not call VirtualMachine.resume() when the EventSet indicates SUSPEND_NONE. That got rid of the above triggering of processBatchedDisposes(), and also sped things up by about 100x. I then ran into the following call to processBatchedDisposes()&lt;br/&gt;
&lt;br/&gt;
	at jdk.jdi/com.sun.tools.jdi.VirtualMachineImpl.processBatchedDisposes(VirtualMachineImpl.java:1328)&lt;br/&gt;
	at jdk.jdi/com.sun.tools.jdi.VirtualMachineImpl.waitForTargetReply(VirtualMachineImpl.java:1180)&lt;br/&gt;
	at jdk.jdi/com.sun.tools.jdi.PacketStream.waitForReply(PacketStream.java:89)&lt;br/&gt;
	at jdk.jdi/com.sun.tools.jdi.JDWP$ThreadReference$IsVirtual.waitForReply(JDWP.java:6050)&lt;br/&gt;
	at jdk.jdi/com.sun.tools.jdi.JDWP$ThreadReference$IsVirtual.process(JDWP.java:6031)&lt;br/&gt;
	at jdk.jdi/com.sun.tools.jdi.ThreadReferenceImpl.isVirtual(ThreadReferenceImpl.java:615)&lt;br/&gt;
	at jdk.jdi/com.sun.tools.example.debug.tty.ThreadInfo.addThread(ThreadInfo.java:88)&lt;br/&gt;
	at jdk.jdi/com.sun.tools.example.debug.tty.EventHandler.threadStartEvent(EventHandler.java:315)&lt;br/&gt;
	at jdk.jdi/com.sun.tools.example.debug.tty.EventHandler.handleEvent(EventHandler.java:149)&lt;br/&gt;
	at jdk.jdi/com.sun.tools.example.debug.tty.EventHandler.run(EventHandler.java:78)&lt;br/&gt;
	at java.base/java.lang.Thread.run(Thread.java:1623)&lt;br/&gt;
&lt;br/&gt;
This is due to virtual thread support that was added to jdb. We now frequently have to send a ThreadReference.IsVirtual command. Since the test does not use virtual threads, I simply commented all of this code out. After doing that I was able to reproduce the memory leak and eventual OOME. It only took a few minutes (525k threads) when I ran with -Xmx64m.&lt;br/&gt;
&lt;br/&gt;
After applying the patches I started seeing calls to processBatchedDisposes() due to the changes in processQueue():&lt;br/&gt;
&lt;br/&gt;
	at jdk.jdi/com.sun.tools.jdi.VirtualMachineImpl.processBatchedDisposes(VirtualMachineImpl.java:1328)&lt;br/&gt;
	at jdk.jdi/com.sun.tools.jdi.VirtualMachineImpl.processQueue(VirtualMachineImpl.java:1386)&lt;br/&gt;
	at jdk.jdi/com.sun.tools.jdi.VirtualMachineImpl.objectMirror(VirtualMachineImpl.java:1393)&lt;br/&gt;
	at jdk.jdi/com.sun.tools.jdi.VirtualMachineImpl.threadMirror(VirtualMachineImpl.java:1498)&lt;br/&gt;
	at jdk.jdi/com.sun.tools.jdi.PacketStream.readThreadReference(PacketStream.java:457)&lt;br/&gt;
	at jdk.jdi/com.sun.tools.jdi.JDWP$Event$Composite$Events$ThreadStart.&amp;lt;init&amp;gt;(JDWP.java:8522)&lt;br/&gt;
	at jdk.jdi/com.sun.tools.jdi.JDWP$Event$Composite$Events.&amp;lt;init&amp;gt;(JDWP.java:7870)&lt;br/&gt;
	at jdk.jdi/com.sun.tools.jdi.JDWP$Event$Composite.&amp;lt;init&amp;gt;(JDWP.java:8905)&lt;br/&gt;
	at jdk.jdi/com.sun.tools.jdi.EventSetImpl.build(EventSetImpl.java:646)&lt;br/&gt;
	at jdk.jdi/com.sun.tools.jdi.EventQueueImpl.removeUnfiltered(EventQueueImpl.java:212)&lt;br/&gt;
	at jdk.jdi/com.sun.tools.jdi.EventQueueImpl.removeInternal(EventQueueImpl.java:125)&lt;br/&gt;
	at jdk.jdi/com.sun.tools.jdi.InternalEventHandler.run(InternalEventHandler.java:61)&lt;br/&gt;
	at java.base/java.lang.Thread.run(Thread.java:1623)&lt;br/&gt;
&lt;br/&gt;
So hopefully this is what the patches were trying to accomplish. The test got through 34,502,000 threads without any sign of leaking. No OOME, and top showed the memory usage as constant once the test warmed up.&lt;br/&gt;
&lt;br/&gt;
Still to do is writing a standalone test (not one that requires running with jdb or IDEA), and then I still need to better understand the changes and consider Alan&amp;#39;s suggestion.</comment>
                            <comment id="14542444" author="alanb" created="Sun, 4 Dec 2022 04:27:11 -0800"  >It looks like this dates back to JDK 8, maybe longer. In the bug report, the IDE/debugger is running on a JDK 17 build (the target VM is JDK 19 but that doesn&amp;#39;t matter for this issue).  One approach to try is replacing listeners with a WeakHashMap (with a value of type Boolean, unused) so that additions will automatically expunge stale refs. That should help removeListener implementations too, as they are currently O(n).</comment>
                            <comment id="14540616" author="eushakov" created="Mon, 28 Nov 2022 06:30:02 -0800"  >yes, just attach the debugger and enable ThreadStartEvent and ThreadDeathEvent, then just leave the program working for some time</comment>
                            <comment id="14540524" author="cjplummer" created="Sun, 27 Nov 2022 23:55:31 -0800"  >Ok. I&amp;#39;m just going to launch it with the command line. Any special command line arguments? I assume at the very least I need to enable the debug agent.</comment>
                            <comment id="14540516" author="ddamodaran" created="Sun, 27 Nov 2022 23:06:12 -0800"  >[~cjplummer] The same testcase (attached zip) which was used for &lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8296463&quot; title=&quot;Memory leak in JVM_StartThread with the integration of Virtual threads&quot; class=&quot;issue-link&quot; data-issue-key=&quot;JDK-8296463&quot;&gt;&lt;strike&gt;JDK-8296463&lt;/strike&gt;&lt;/a&gt; should work here. Additional thing is to attach a debugger at the startup. &lt;br/&gt;
[~eushakov] Please confirm this. &lt;br/&gt;
</comment>
                            <comment id="14540507" author="cjplummer" created="Sun, 27 Nov 2022 21:41:26 -0800"  >[~eushakov] Can you attach a test case. I noticed the jetbrains issue references an &amp;quot;attached project&amp;quot;, but I don&amp;#39;t have access to it (it says &amp;quot;There is 1 attachment that is not visible to you&amp;quot;).</comment>
                            <comment id="14540462" author="dholmes" created="Sat, 26 Nov 2022 19:23:29 -0800"  >[~ddamodaran] yes &lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8296463&quot; title=&quot;Memory leak in JVM_StartThread with the integration of Virtual threads&quot; class=&quot;issue-link&quot; data-issue-key=&quot;JDK-8296463&quot;&gt;&lt;strike&gt;JDK-8296463&lt;/strike&gt;&lt;/a&gt; would be a factor here - as per the update to the JetBrains bug report. I don&amp;#39;t know if mainline OpenJDK has the same JDI issue.</comment>
                            <comment id="14540457" author="ddamodaran" created="Sat, 26 Nov 2022 10:49:58 -0800"  >[~dholmes] This issue seems to be related to &lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8296463&quot; title=&quot;Memory leak in JVM_StartThread with the integration of Virtual threads&quot; class=&quot;issue-link&quot; data-issue-key=&quot;JDK-8296463&quot;&gt;&lt;strike&gt;JDK-8296463&lt;/strike&gt;&lt;/a&gt;. The scenario is a bit different (a debugger must be attached) but ultimately the same users will be impacted by both issues.</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10600">
                    <name>Causes</name>
                                            <outwardlinks description="causes">
                                        <issuelink>
            <issuekey id="5136893">JDK-8338482</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                            <issuelinktype id="10003">
                    <name>Relates</name>
                                            <outwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="5096547">JDK-8304436</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="5096564">JDK-8304449</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="5096540">JDK-8304432</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="101816" name="ThreadsHang.zip" size="5565" author="ddamodaran" created="Sun, 27 Nov 2022 23:06:38 -0800"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_11700" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_10600" key="com.oracle.jira.javabugsystem-jira-plugin:jbs-fixedBackportedCustomfield">
                        <customfieldname>Fixed</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_11100" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i2ze37:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_11004" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10006" key="com.atlassian.jira.plugin.system.customfieldtypes:select">
                        <customfieldname>Resolved In Build</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="17352"><![CDATA[b15]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10008" key="com.oracle.jira.jira-subcomponent-plugin:oracle-subComponentField">
                        <customfieldname>Subcomponent</customfieldname>
                        <customfieldvalues>
                             <customfieldvalue key="370"><![CDATA[debugger]]></customfieldvalue> 
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_10601" key="com.oracle.jira.javabugsystem-jira-plugin:jbs-targetBackportedCustomfield">
                        <customfieldname>Targeted</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    </customfields>
    </item>
</channel>
</rss>