<!-- 
RSS generated by JIRA (9.12.27#9120027-sha1:edc4490121e366e9e7bd2213d532dbe7e028fc5d) at Tue Sep 30 22:47:48 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>Java Bug System</title>
    <link>https://bugs.openjdk.org</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-us</language>    <build-info>
        <version>9.12.27</version>
        <build-number>9120027</build-number>
        <build-date>02-09-2025</build-date>
    </build-info>


<item>
            <title>[JDK-8358764] (sc) SocketChannel.close when thread blocked in read causes connection to be reset (win)</title>
                <link>https://bugs.openjdk.org/browse/JDK-8358764</link>
                <project id="10100" key="JDK">JDK</project>
                    <description>A DESCRIPTION OF THE PROBLEM :&lt;br/&gt;
Receiving connection reset error on client end when socket.close() is called.&lt;br/&gt;
&lt;br/&gt;
Steps&lt;br/&gt;
- One thread runs through out application lifetime, whose purpose is to accept the incoming socket connection. (similar code gist as ServerThread.class attached)&lt;br/&gt;
- After accepting the socket connection a new thread is created and handed over with the accepted socket. The new thread uses the socket input and output stream to read and write data.&lt;br/&gt;
- Some other thread can decide based on circumstances to terminate the socket using socket.close().&lt;br/&gt;
&lt;br/&gt;
When socket.close() is called:&lt;br/&gt;
&lt;br/&gt;
Java 11: On socket.close() call, sends RST packet to the client, thus connection reset error on client end.&lt;br/&gt;
Java 8: On socket.close() call, sends FIN packet to the client, thus no issue observed on client end.&lt;br/&gt;
&lt;br/&gt;
Note: Please ignore the thread sleep and all sort of duppy code attached. Its just for issue reproduction purpose. The real application is a proxy kinda server which accepts connection and forwards data to some other connection. The other connection once done with data instructs to close the accepted connection.&lt;br/&gt;
&lt;br/&gt;
REGRESSION : Last worked in version 8&lt;br/&gt;
&lt;br/&gt;
STEPS TO FOLLOW TO REPRODUCE THE PROBLEM :&lt;br/&gt;
Run the provided sample code(test case code) in Java 8 and Java 11 to see the connection reset error.&lt;br/&gt;
Three class:&lt;br/&gt;
ServerThread.class&lt;br/&gt;
Client.class&lt;br/&gt;
Main.class&lt;br/&gt;
&lt;br/&gt;
EXPECTED VERSUS ACTUAL BEHAVIOR :&lt;br/&gt;
EXPECTED -&lt;br/&gt;
Connection reset error should not appear as there is no data to read&lt;br/&gt;
ACTUAL -&lt;br/&gt;
Connection reset error&lt;br/&gt;
&lt;br/&gt;
---------- BEGIN SOURCE ----------&lt;br/&gt;
// server thread class&lt;br/&gt;
&lt;br/&gt;
import java.net.*;&lt;br/&gt;
import java.io.*;&lt;br/&gt;
import java.nio.channels.SelectionKey;&lt;br/&gt;
import java.nio.channels.Selector;&lt;br/&gt;
import java.nio.channels.ServerSocketChannel;&lt;br/&gt;
import java.nio.channels.SocketChannel;&lt;br/&gt;
import java.nio.channels.spi.SelectorProvider;&lt;br/&gt;
import java.util.Set;&lt;br/&gt;
&lt;br/&gt;
public class ServerThread extends Thread {&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;private final int port;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;private Socket s = null;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;private InputStream in = null;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// Constructor with port &lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public ServerThread(int port) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;this.port = port;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public Socket getSocket() {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return this.s;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public void run() {&lt;br/&gt;
&lt;br/&gt;
// Starts server and accept connection &lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;try {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Selector socketSelector = SelectorProvider.provider().openSelector();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;serverSocketChannel.configureBlocking(false);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;InetSocketAddress inetSocketAddress = new InetSocketAddress(&amp;quot;127.0.0.1&amp;quot;, port);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;serverSocketChannel.socket().bind(inetSocketAddress);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;serverSocketChannel.register(socketSelector, SelectionKey.OP_ACCEPT);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;socketSelector.select();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Set&amp;lt;SelectionKey&amp;gt; selectedKeys = socketSelector.selectedKeys();&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;for (SelectionKey selectionKey : selectedKeys) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if (selectionKey.isAcceptable()) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ServerSocketChannel sSC =&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;(ServerSocketChannel) selectionKey.channel();&lt;br/&gt;
&lt;br/&gt;
// Accept the connection &lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;SocketChannel socketChannel = sSC.accept();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;s = socketChannel.socket();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.println(&amp;quot;Client accepted&amp;quot;);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;s.setKeepAlive(true);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;s.setTcpNoDelay(true);&lt;br/&gt;
&lt;br/&gt;
// Takes input from the client socket &lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;in = s.getInputStream();&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;int m = 0;&lt;br/&gt;
// Reads message from client &lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;while (m != -1) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;try {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;m = in.read(new byte[16]);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.println(m);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;} catch (IOException i) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.println(&amp;quot;Got exception in server thread: &amp;quot; + i);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;break;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.println(&amp;quot;Closing connection&amp;quot;);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;selectedKeys.clear();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;} catch (IOException i) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.println(&amp;quot;Got from server thread &amp;quot; + i);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
}&lt;br/&gt;
--------------------------------------------------------------------------------------&lt;br/&gt;
// client class&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;import java.io .*;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;import java.net .*;&lt;br/&gt;
&lt;br/&gt;
public class Client {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;private Socket s = null;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;private InputStream in = null;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// Constructor to put IP address and port &lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public Client(String addr, int port) {&lt;br/&gt;
// Establish a connection &lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;try {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;s = new Socket(addr, port);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;in = s.getInputStream();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.println(&amp;quot;Connected&amp;quot;);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;} catch (UnknownHostException u) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.println(u);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;} catch (IOException i) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.println(i);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&lt;br/&gt;
// String to read message from input &lt;br/&gt;
//String m = &amp;quot;&amp;quot;; &lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;int m = 0;&lt;br/&gt;
// Keep reading until &amp;quot;Over&amp;quot; is input &lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;while (m != -1) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;try {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;m = in.read(new byte[16]);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.println(m);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;} catch (IOException i) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.println(&amp;quot;Got exception in client: &amp;quot; + i);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;break;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&lt;br/&gt;
// Close the connection &lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;try {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;s.close();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;} catch (IOException i) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.println(i);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
}&lt;br/&gt;
-------------------------------------------------------------------------------------&lt;br/&gt;
// main class&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;import java.io.IOException;&lt;br/&gt;
&lt;br/&gt;
public class Main {&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public static void main(String[] args) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ServerThread s = new ServerThread(5000);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;s.start();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Thread t = new Thread(() -&amp;gt; {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;try {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Thread.sleep(10000);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;s.getSocket().close();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;} catch (IOException e) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.println(&amp;quot;Got IO exception&amp;quot;);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;} catch (InterruptedException e) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.println(&amp;quot;Got InterruptedException&amp;quot;);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;});&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;t.start();&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Thread t1 = new Thread(() -&amp;gt; {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;try {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Thread.sleep(5000);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Client c = new Client(&amp;quot;127.0.0.1&amp;quot;, 5000);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;} catch (InterruptedException e) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.println(&amp;quot;Got InterruptedException&amp;quot;);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;});&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;t1.start();&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
} &lt;br/&gt;
---------- END SOURCE ----------&lt;br/&gt;
&lt;br/&gt;
</description>
                <environment></environment>
        <key id="5160694">JDK-8358764</key>
            <summary>(sc) SocketChannel.close when thread blocked in read causes connection to be reset (win)</summary>
                <type id="1" iconUrl="https://bugs.openjdk.org/secure/viewavatar?size=xsmall&amp;avatarId=14703&amp;avatarType=issuetype">Bug</type>
                                            <priority id="3" iconUrl="https://bugs.openjdk.org/images/jbsImages/p3.png">P3</priority>
                        <status id="5" iconUrl="https://bugs.openjdk.org/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="success"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="alanb">Alan Bateman</assignee>
                                    <reporter username="webbuggrp">Webbug Group</reporter>
                        <labels>
                            <label>21bpr-critical-approved</label>
                            <label>CPU25_10-critical-SQE-OK</label>
                            <label>CPU25_10-critical-approved</label>
                            <label>additional-information-requested</label>
                            <label>dcsrk</label>
                            <label>hgupdate-sync</label>
                            <label>jdk21u-fix-request</label>
                            <label>jdk21u-fix-yes</label>
                            <label>regression</label>
                            <label>reproducer-yes</label>
                            <label>webbug</label>
                    </labels>
                <created>Thu, 5 Jun 2025 05:44:42 -0700</created>
                <updated>Mon, 8 Sep 2025 02:52:12 -0700</updated>
                            <resolved>Wed, 11 Jun 2025 07:12:28 -0700</resolved>
                                    <version>11</version>
                    <version>24</version>
                                    <fixVersion>26</fixVersion>
                                    <component>core-libs</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>9</watches>
                                                                                                                <comments>
                            <comment id="14813003" author="roboduke" created="Mon, 1 Sep 2025 08:32:07 -0700"  >A pull request was submitted for review.&lt;br/&gt;
Branch: master&lt;br/&gt;
URL: &lt;a href=&quot;https://git.openjdk.org/jdk21u-dev/pull/2137&quot;&gt;https://git.openjdk.org/jdk21u-dev/pull/2137&lt;/a&gt;&lt;br/&gt;
Date: 2025-09-01 15:21:53 +0000</comment>
                            <comment id="14812975" author="sgehwolf" created="Mon, 1 Sep 2025 06:31:58 -0700"  >Fix Request (OpenJDK 21u):&lt;br/&gt;
Please approve this change for JDK 21u. Currently I&amp;#39;m targeting 21.0.10 to ensure longer soak time before getting it released. It&amp;#39;s a medium risk change since it&amp;#39;s touching a core component of the JDK. However, the main change is in a code path that pertains to the blocking mode implementation in SocketChannelImpl and affecting Windows only. The fix should be largely a no-op on other platforms. Since this regression wasn&amp;#39;t seen until recently it can be argued that it&amp;#39;s not an often-used configuration. JDK 25 patch is not clean. Patch has been reviewed by Thomas St&amp;#xFC;fe. Testing done on windows reproduces the issue. Fixed with the product changes included as well. jdk_nio, jdk_net test pass.</comment>
                            <comment id="14801686" author="jpai" created="Tue, 22 Jul 2025 04:34:03 -0700"  >&amp;gt; We start to see a lot of timeouts (on macOS, AIX, Linux) in java/nio/channels/SocketChannel/OpenLeak.java since June 11th 2025, could it be related ? &lt;br/&gt;
&lt;br/&gt;
Given what that test does, I don&amp;#39;t see that test timeout being related to this current issue.&lt;br/&gt;
&lt;br/&gt;
&amp;gt; I opened &lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8362581&quot;&gt;https://bugs.openjdk.org/browse/JDK-8362581&lt;/a&gt; . &lt;br/&gt;
&lt;br/&gt;
I added a comment there. I&amp;#39;ll take a look in our CI to see whether this test&amp;#39;s duration has increased for us too.</comment>
                            <comment id="14799729" author="mbaesken" created="Fri, 18 Jul 2025 00:35:40 -0700"  >We start to see a lot of timeouts (on macOS, AIX, Linux) in  java/nio/channels/SocketChannel/OpenLeak.java  since June 11th 2025, could it be related ? &lt;br/&gt;
&lt;br/&gt;
I opened  &lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8362581&quot;&gt;https://bugs.openjdk.org/browse/JDK-8362581&lt;/a&gt; .</comment>
                            <comment id="14789884" author="roboduke" created="Sun, 15 Jun 2025 11:30:51 -0700"  >A pull request was submitted for review.&lt;br/&gt;
Branch: jdk25&lt;br/&gt;
URL: &lt;a href=&quot;https://git.openjdk.org/jdk/pull/25813&quot;&gt;https://git.openjdk.org/jdk/pull/25813&lt;/a&gt;&lt;br/&gt;
Date: 2025-06-15 06:14:08 +0000</comment>
                            <comment id="14788657" author="dukebot" created="Wed, 11 Jun 2025 07:12:27 -0700"  >Changeset: e5196fc2&lt;br/&gt;
Branch: master&lt;br/&gt;
Author:    Alan Bateman &amp;lt;&lt;a href=&apos;mailto:alanb@openjdk.org&apos;&gt;alanb@openjdk.org&lt;/a&gt;&amp;gt;&lt;br/&gt;
Date:      2025-06-11 14:09:45 +0000&lt;br/&gt;
URL:       &lt;a href=&quot;https://git.openjdk.org/jdk/commit/e5196fc24d2ec9e581af7803ac47036111fee029&quot;&gt;https://git.openjdk.org/jdk/commit/e5196fc24d2ec9e581af7803ac47036111fee029&lt;/a&gt;&lt;br/&gt;
</comment>
                            <comment id="14788272" author="roboduke" created="Tue, 10 Jun 2025 06:38:57 -0700"  >A pull request was submitted for review.&lt;br/&gt;
Branch: master&lt;br/&gt;
URL: &lt;a href=&quot;https://git.openjdk.org/jdk/pull/25700&quot;&gt;https://git.openjdk.org/jdk/pull/25700&lt;/a&gt;&lt;br/&gt;
Date: 2025-06-09 19:17:16 +0000</comment>
                            <comment id="14787534" author="alanb" created="Sat, 7 Jun 2025 12:14:46 -0700"  >The JDK has worked around this Windows issue for a long time by shutting down the connection for writing before closing. Right now, it doesn&amp;#39;t do this when the SocketChannel is configured blocking (most uses of SocketChannel are non-blocking so that might explain why there hasn&amp;#39;t been bugs on the behavior change in JDK 11). I have a tentative change that do the shutdown but need to work around the impact on other platforms.</comment>
                            <comment id="14787493" author="jpai" created="Sat, 7 Jun 2025 01:16:52 -0700"  >I&amp;#39;ve attached a AcceptedSocketCloseTest.java which reproduces this issue. Run it as:&lt;br/&gt;
&lt;br/&gt;
javac AcceptedSocketCloseTest.java&lt;br/&gt;
java AcceptedSocketCloseTest&lt;br/&gt;
&lt;br/&gt;
and only on Windows you will notice an additional exception (stacktrace) of the form:&lt;br/&gt;
&lt;br/&gt;
client received exception: java.net.SocketException: Connection reset&lt;br/&gt;
java.net.SocketException: Connection reset&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at java.base/sun.nio.ch.NioSocketImpl.implRead(NioSocketImpl.java:316)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at java.base/sun.nio.ch.NioSocketImpl.read(NioSocketImpl.java:354)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at java.base/sun.nio.ch.NioSocketImpl$1.read(NioSocketImpl.java:798)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at java.base/java.net.Socket$SocketInputStream.implRead(Socket.java:974)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at java.base/java.net.Socket$SocketInputStream.read(Socket.java:964)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at java.base/java.io.InputStream.read(InputStream.java:222)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at AcceptedSocketCloseTest$Client.run(AcceptedSocketCloseTest.java:xxx)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at java.base/java.lang.Thread.run(Thread.java:1474)</comment>
                            <comment id="14787492" author="jpai" created="Sat, 7 Jun 2025 01:14:55 -0700"  >Hello Alan,&lt;br/&gt;
&lt;br/&gt;
&amp;gt; [~jpai] Thanks for the analysis but just to say that your comment &amp;quot;tryClose() returns an incorrect result&amp;quot; isn&amp;#39;t quite right. &lt;br/&gt;
&lt;br/&gt;
I think I did not phrase that correctly. What I meant to say was that the implementation of tryClose() (on Windows) doesn&amp;#39;t appear to be matching what the javadoc on that method states:&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;/**&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;* Closes the socket if there are no I/O operations in progress and the&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;* channel is not registered with a Selector.&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;*/&lt;br/&gt;
&lt;br/&gt;
In the case of Windows, the current implementation of that method closes the socket even when I/O operations are in progress and the channel is registered with a Selector.</comment>
                            <comment id="14787491" author="alanb" created="Sat, 7 Jun 2025 01:08:32 -0700"  >[~jpai] Thanks for the analysis but just to say that your comment &amp;quot;tryClose() returns an incorrect result&amp;quot; isn&amp;#39;t quite right.  Windows does not have a means to pre close (no dup2 equivalent). There have been several requests to Microsoft over the years on this but they never went anywhere. So on Windows, tryClose must close the socket. We can look at expanding the set of scenarios where a shutdown is done before close, that would reduce the cases where an abortive close results from an async close of the channel.</comment>
                            <comment id="14787486" author="jpai" created="Sat, 7 Jun 2025 00:21:48 -0700"  >I had a look at this today. The issue is reproducible on Windows (even against mainline JDK). This only happens with a Socket that&amp;#39;s returned through a SocketChannel. Normal ServerSocket/Socket do not exhibit this issue. I am not very familiar with the SocketChannel code, but I think we might have an issue, on Windows, in SocketChannelImpl.tryClose()&amp;#39;s implementation which detects whether or not a read/write operation is in progress to decide whether to first shutdown the output (SHUT_WR) on the Socket&amp;#39;s file descriptor. Details follow.&lt;br/&gt;
&lt;br/&gt;
The code path is as follows:&lt;br/&gt;
&lt;br/&gt;
- Client side uses java.net.Socket to initiate a connection to an address that&amp;#39;s listened to by a ServerSocketChannel&lt;br/&gt;
- ServerSocketChannel.accept().socket() accepts an incoming connection and returns a Socket instance&lt;br/&gt;
- The server thread then uses the Socket to initiate a blocking read on that Socket&amp;#39;s InputStream:&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;final ServerSocketChannel ssc = (ServerSocketChannel) selectionKey.channel();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;final Socket accepted = ssc.accept().socket();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;final InputStream in = accepted.getInputStream();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;while (numRead != -1) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;numRead = in.read(new byte[16]);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.println(&amp;quot;server read &amp;quot; + numRead + &amp;quot; bytes&amp;quot;);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&lt;br/&gt;
- The client end (the one which iniated the connection) of this socket, (intentionally) never writes out anything over the socket and instead it too goes into a read operation over the Socket InputStream:&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;try (final Socket socket = new Socket(serverAddr.getAddress(), serverAddr.getPort())) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.println(&amp;quot;client connection established &amp;quot; + socket);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;final InputStream in = socket.getInputStream();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;int numRead = 0;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;while ((numRead = in.read(new byte[16])) != -1) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.println(&amp;quot;client read &amp;quot; + numRead + &amp;quot; bytes&amp;quot;);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.println(&amp;quot;client received EOF when reading on &amp;quot; + socket);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&lt;br/&gt;
- So these two threads, one the client and other the server and both reading off the connected socket. In the meantime, a third thread calls a Socket.close() on the Socket instance that was handed out by the ServerSocketChannel.accept(). That close() call is expected to cause the server side thread blocked in the read operation to receive an java.nio.channels.AsynchronousCloseException, which it does. At the same time, the client thread which too was doing read() on a plain Socket instance is expected to receive a EOF (-1 from read()) and exit out of the while loop. That too happens fine on Java 8. However, in Java 11 (and even mainline JDK), the client side thread which is doing the read(), receives a &amp;quot;Connection reset&amp;quot; only on Windows:&lt;br/&gt;
&lt;br/&gt;
client received exception: java.net.SocketException: Connection reset&lt;br/&gt;
java.net.SocketException: Connection reset&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at java.base/sun.nio.ch.NioSocketImpl.implRead(NioSocketImpl.java:316)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at java.base/sun.nio.ch.NioSocketImpl.read(NioSocketImpl.java:354)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at java.base/sun.nio.ch.NioSocketImpl$1.read(NioSocketImpl.java:798)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at java.base/java.net.Socket$SocketInputStream.implRead(Socket.java:974)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at java.base/java.net.Socket$SocketInputStream.read(Socket.java:964)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at java.base/java.io.InputStream.read(InputStream.java:222)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at AcceptedSocketCloseTest$Client.run(AcceptedSocketCloseTest.java:133)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;at java.base/java.lang.Thread.run(Thread.java:1474)&lt;br/&gt;
&lt;br/&gt;
I had a look at how the close() is implemented for the Socket instance that&amp;#39;s handed out by the ServerSocketChannel. In implCloseBlockingMode() of sun.nio.ch.SocketChannelImpl there&amp;#39;s a call to tryClose(), whose goal as stated by the doc on that method is:&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;/**&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;* Closes the socket if there are no I/O operations in progress and the&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;* channel is not registered with a Selector.&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;*/&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;private boolean tryClose() throws IOException {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;assert Thread.holdsLock(stateLock) &amp;amp;&amp;amp; state == ST_CLOSING;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if ((readerThread == 0) &amp;amp;&amp;amp; (writerThread == 0) &amp;amp;&amp;amp; !isRegistered()) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;state = ST_CLOSED;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;nd.close(fd);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return true;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;} else {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return false;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;...&lt;br/&gt;
&lt;br/&gt;
If there&amp;#39;s a read or a write operation in progress (like in this test where a read operation is in progress), then we skip closing the file descriptor and instead first shutdown the write:&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if (!tryClose()) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// shutdown output when linger interval not set to 0&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if (connected) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;try {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;var SO_LINGER = StandardSocketOptions.SO_LINGER;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if ((int) Net.getSocketOption(fd, SO_LINGER) != 0) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Net.shutdown(fd, Net.SHUT_WR);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;} catch (IOException ignore) { }&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;...&lt;br/&gt;
&lt;br/&gt;
The issue on Windows appears to be that the &amp;quot;is there any read/write operation in progress&amp;quot; check in tryClose() returns an incorrect result and states that there are no read/write operations in progress. This is because the &amp;quot;readThread&amp;quot; value is 0. This field gets set when the read operation had begun, through a call to sun.nio.ch.NativeThread.current(). On Windows that current() method is implemented to return a value of 0 (for platform threads). So this results in the file descriptor being immediately closed in tryClose() and we skip the shutting down the write on the socket&amp;#39;s file descriptor.&lt;br/&gt;
</comment>
                            <comment id="14787305" author="alanb" created="Fri, 6 Jun 2025 04:19:38 -0700"  >I scanned the test case and I don&amp;#39;t see any writing or setting SO_LINGER to 0. So I don&amp;#39;t see anything that would result in an abortive close (hard reset). It might be that the reproducer needs more work in order to demonstrate the apparent behavior change.&lt;br/&gt;
&lt;br/&gt;
Note that there significant changes to the SocketChannel implementation in JDK 11, e.g. &lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8198692&quot; title=&quot;Release Note: Separate Blocking and Non-blocking Code Paths&quot; class=&quot;issue-link&quot; data-issue-key=&quot;JDK-8198692&quot;&gt;&lt;strike&gt;JDK-8198692&lt;/strike&gt;&lt;/a&gt; and &lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8203059&quot; title=&quot;(so) Closing a socket channel registered with Selector and with SO_LINGER set to 0 does not reset connection&quot; class=&quot;issue-link&quot; data-issue-key=&quot;JDK-8203059&quot;&gt;&lt;strike&gt;JDK-8203059&lt;/strike&gt;&lt;/a&gt;. JDK 11 was released in 2018 so if there was an issue then we would likely have a bug report by now.</comment>
                            <comment id="14787304" author="JIRAUSER19835" created="Fri, 6 Jun 2025 03:57:01 -0700"  >window output&lt;br/&gt;
jdk 11.0.28 &amp;gt;&amp;gt;&lt;br/&gt;
java com.webbugs.ji9078596.Main&lt;br/&gt;
Connected&lt;br/&gt;
Client accepted&lt;br/&gt;
Got exception in client: java.net.SocketException: Connection reset&lt;br/&gt;
Got exception in server thread: java.nio.channels.AsynchronousCloseException&lt;br/&gt;
Closing connection&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
jdk 8u451 &amp;gt;&amp;gt;&lt;br/&gt;
Connected&lt;br/&gt;
Client accepted&lt;br/&gt;
-1&lt;br/&gt;
Got exception in server thread: java.nio.channels.AsynchronousCloseException&lt;br/&gt;
Closing connection</comment>
                            <comment id="14787276" author="JIRAUSER19835" created="Fri, 6 Jun 2025 01:05:32 -0700"  >Email to submitter:&lt;br/&gt;
Good Day,&lt;br/&gt;
&amp;nbsp;&lt;br/&gt;
Thank you for reporting this bug. I&#8217;m not entirely clear on the expected outcome you are referencing. I have noticed a discrepancy in the stack trace&#8212;are you referring to this issue, or is there a different problem you&#8217;d like me to investigate?&lt;br/&gt;
&amp;nbsp;&lt;br/&gt;
If it&#8217;s not related to the stack trace, could you please provide more detailed steps to help me better understand and investigate the issue you&#8217;re experiencing?&lt;br/&gt;
&amp;nbsp;&lt;br/&gt;
Thank you for your assistance!&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
JDK 11 print exception as below:&lt;br/&gt;
&lt;br/&gt;
Connected&lt;br/&gt;
Client accepted&lt;br/&gt;
-1&lt;br/&gt;
Got exception in server thread: java.nio.channels.AsynchronousCloseException&lt;br/&gt;
java.nio.channels.AsynchronousCloseException&lt;br/&gt;
at java.base/java.nio.channels.spi.AbstractInterruptibleChannel.end(AbstractInterruptibleChannel.java:202)&lt;br/&gt;
at java.base/sun.nio.ch.SocketChannelImpl.endRead(SocketChannelImpl.java:334)&lt;br/&gt;
at java.base/sun.nio.ch.SocketChannelImpl.read(SocketChannelImpl.java:361)&lt;br/&gt;
at java.base/sun.nio.ch.SocketAdaptor$SocketInputStream.read(SocketAdaptor.java:203)&lt;br/&gt;
at java.base/sun.nio.ch.ChannelInputStream.read(ChannelInputStream.java:101)&lt;br/&gt;
at java.base/java.io.InputStream.read(InputStream.java:205)&lt;br/&gt;
at ServerThread.run(ServerThread.java:61)&lt;br/&gt;
Closing connection&lt;br/&gt;
&lt;br/&gt;
and JDK 8 :&lt;br/&gt;
&lt;br/&gt;
Connected&lt;br/&gt;
Client accepted&lt;br/&gt;
-1&lt;br/&gt;
Got exception in server thread: java.nio.channels.AsynchronousCloseException&lt;br/&gt;
java.nio.channels.AsynchronousCloseException&lt;br/&gt;
at java.nio.channels.spi.AbstractInterruptibleChannel.end(AbstractInterruptibleChannel.java:205)&lt;br/&gt;
at sun.nio.ch.SocketChannelImpl.read(SocketChannelImpl.java:405)&lt;br/&gt;
at sun.nio.ch.SocketAdaptor$SocketInputStream.read(SocketAdaptor.java:192)&lt;br/&gt;
at sun.nio.ch.ChannelInputStream.read(ChannelInputStream.java:103)&lt;br/&gt;
at java.io.InputStream.read(InputStream.java:101)&lt;br/&gt;
at ServerThread.run(ServerThread.java:61)&lt;br/&gt;
Closing connection</comment>
                            <comment id="14787109" author="JIRAUSER19835" created="Thu, 5 Jun 2025 08:48:48 -0700"  >ILW = Somewhere in-between the extremes , The defect is encountered in a common use case for the product, Technical errors in non-critical = MHL =&amp;gt; P3</comment>
                            <comment id="14787103" author="JIRAUSER19835" created="Thu, 5 Jun 2025 08:26:52 -0700"  >I was unable to reproduce the issue on JDK 8u441 and JDK 11.0.27. However, there appears to be a discrepancy in the stack trace, so further investigation will be necessary to pinpoint the cause.&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
JDK 11 print exception as below:&lt;br/&gt;
&lt;br/&gt;
Connected&lt;br/&gt;
Client accepted&lt;br/&gt;
-1&lt;br/&gt;
Got exception in server thread: java.nio.channels.AsynchronousCloseException&lt;br/&gt;
java.nio.channels.AsynchronousCloseException&lt;br/&gt;
	at java.base/java.nio.channels.spi.AbstractInterruptibleChannel.end(AbstractInterruptibleChannel.java:202)&lt;br/&gt;
	at java.base/sun.nio.ch.SocketChannelImpl.endRead(SocketChannelImpl.java:334)&lt;br/&gt;
	at java.base/sun.nio.ch.SocketChannelImpl.read(SocketChannelImpl.java:361)&lt;br/&gt;
	at java.base/sun.nio.ch.SocketAdaptor$SocketInputStream.read(SocketAdaptor.java:203)&lt;br/&gt;
	at java.base/sun.nio.ch.ChannelInputStream.read(ChannelInputStream.java:101)&lt;br/&gt;
	at java.base/java.io.InputStream.read(InputStream.java:205)&lt;br/&gt;
	at ServerThread.run(ServerThread.java:61)&lt;br/&gt;
Closing connection&lt;br/&gt;
&lt;br/&gt;
and JDK 8 :&lt;br/&gt;
&lt;br/&gt;
Connected&lt;br/&gt;
Client accepted&lt;br/&gt;
-1&lt;br/&gt;
Got exception in server thread: java.nio.channels.AsynchronousCloseException&lt;br/&gt;
java.nio.channels.AsynchronousCloseException&lt;br/&gt;
	at java.nio.channels.spi.AbstractInterruptibleChannel.end(AbstractInterruptibleChannel.java:205)&lt;br/&gt;
	at sun.nio.ch.SocketChannelImpl.read(SocketChannelImpl.java:405)&lt;br/&gt;
	at sun.nio.ch.SocketAdaptor$SocketInputStream.read(SocketAdaptor.java:192)&lt;br/&gt;
	at sun.nio.ch.ChannelInputStream.read(ChannelInputStream.java:103)&lt;br/&gt;
	at java.io.InputStream.read(InputStream.java:101)&lt;br/&gt;
	at ServerThread.run(ServerThread.java:61)&lt;br/&gt;
Closing connection</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10200">
                    <name>Backport</name>
                                            <outwardlinks description="backported by">
                                        <issuelink>
            <issuekey id="5161742">JDK-8359661</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="5163678">JDK-8361421</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="5163980">JDK-8361683</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="5164340">JDK-8362001</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="5167001">JDK-8364285</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="5167025">JDK-8364307</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="5170168">JDK-8367075</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="5165419">JDK-8362895</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                            <issuelinktype id="10000">
                    <name>Blocks</name>
                                            <outwardlinks description="blocks">
                                                        </outwardlinks>
                                                        </issuelinktype>
                            <issuelinktype id="10002">
                    <name>Duplicate</name>
                                            <outwardlinks description="duplicates">
                                                        </outwardlinks>
                                                        </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="114832" name="AcceptedSocketCloseTest.java" size="5706" author="jpai" created="Sat, 7 Jun 2025 01:08:49 -0700"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_10000" key="com.atlassian.jira.plugin.system.customfieldtypes:multiselect">
                        <customfieldname>CPU</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="19000"><![CDATA[x86_64]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_11700" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_10600" key="com.oracle.jira.javabugsystem-jira-plugin:jbs-fixedBackportedCustomfield">
                        <customfieldname>Fixed</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                            <customfield id="customfield_10005" key="com.atlassian.jira.plugin.system.customfieldtypes:multiselect">
                        <customfieldname>OS</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="17005"><![CDATA[windows]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                            <customfield id="customfield_11100" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i3bj2b:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_11004" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10006" key="com.atlassian.jira.plugin.system.customfieldtypes:select">
                        <customfieldname>Resolved In Build</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="17317"><![CDATA[b02]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10008" key="com.oracle.jira.jira-subcomponent-plugin:oracle-subComponentField">
                        <customfieldname>Subcomponent</customfieldname>
                        <customfieldvalues>
                             <customfieldvalue key="228"><![CDATA[java.nio]]></customfieldvalue> 
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_10601" key="com.oracle.jira.javabugsystem-jira-plugin:jbs-targetBackportedCustomfield">
                        <customfieldname>Targeted</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    </customfields>
    </item>
</channel>
</rss>