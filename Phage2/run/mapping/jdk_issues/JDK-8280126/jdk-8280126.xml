<!-- 
RSS generated by JIRA (9.12.27#9120027-sha1:edc4490121e366e9e7bd2213d532dbe7e028fc5d) at Tue Sep 30 13:50:37 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>Java Bug System</title>
    <link>https://bugs.openjdk.org</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-us</language>    <build-info>
        <version>9.12.27</version>
        <build-number>9120027</build-number>
        <build-date>02-09-2025</build-date>
    </build-info>


<item>
            <title>[JDK-8280126] C2: detect and remove dead irreducible loops</title>
                <link>https://bugs.openjdk.org/browse/JDK-8280126</link>
                <project id="10100" key="JDK">JDK</project>
                    <description>ADDITIONAL SYSTEM INFORMATION :&lt;br/&gt;
OS version:&lt;br/&gt;
Distributor ID: Ubuntu&lt;br/&gt;
Description:    Ubuntu 20.04.3 LTS&lt;br/&gt;
Release:        20.04&lt;br/&gt;
Codename:       focal&lt;br/&gt;
&lt;br/&gt;
We used the following version:&lt;br/&gt;
&lt;br/&gt;
java version &amp;quot;11.0.12&amp;quot; 2021-07-20 LTS&lt;br/&gt;
Java(TM) SE Runtime Environment 18.9 (build 11.0.12+8-LTS-237)&lt;br/&gt;
Java HotSpot(TM) 64-Bit Server VM 18.9 (build 11.0.12+8-LTS-237, mixed mode)&lt;br/&gt;
&lt;br/&gt;
java version &amp;quot;17.0.1&amp;quot; 2021-10-19 LTS&lt;br/&gt;
Java(TM) SE Runtime Environment (build 17.0.1+12-LTS-39)&lt;br/&gt;
Java HotSpot(TM) 64-Bit Server VM (build 17.0.1+12-LTS-39, mixed mode, sharing)&lt;br/&gt;
&lt;br/&gt;
openjdk version &amp;quot;11-internal&amp;quot; 2018-09-25&lt;br/&gt;
OpenJDK Runtime Environment (fastdebug build 11-internal+0-adhoc.minghai.jdk11)&lt;br/&gt;
OpenJDK 64-Bit Server VM (fastdebug build 11-internal+0-adhoc.minghai.jdk11, mixed mode)&lt;br/&gt;
&lt;br/&gt;
A DESCRIPTION OF THE PROBLEM :&lt;br/&gt;
The attached fuzzer test trapped in dead loop with &amp;quot;-Xcomp&amp;quot;(run in compiled mode), but it passed with &amp;quot;-Xint&amp;quot;(run in interpreted mode) or without JVM parameters(run in mixed mode)&lt;br/&gt;
&lt;br/&gt;
ERROR MESSAGES/STACK TRACES THAT OCCUR :&lt;br/&gt;
When we run the test in jdk17.0.1 and jdk11.0.12, both in compiled mode(with &amp;quot;-Xcomp&amp;quot;), it trapped in dead loop. But when  run the test in jdk17.0.1 and jdk11.0.12, both in mixed mode or interpreted mode(with &amp;quot;-Xint), it passed successfully.&lt;br/&gt;
&lt;br/&gt;
Besides, when run in jdk11-internal, mixed mode or interpreted mode, it passed successfully.&lt;br/&gt;
But when run in jdk11-internal, compiled mode, it crashes with the following messages:&lt;br/&gt;
933   ConI    ===  0  [[ 4764  1447  409  1486  3173  4798  4803  4805  4756  304  6451  4769  4795  4796  410  4797  4793  6188  4763  412  5535  305  6053  5642  6055  6469  4770  5005  5006  4403  413  7005  6008  4403  5777  412  4403  411  411  6188  380  6007  5780  5009  5052  5640  303  6046  1405  5589  412  461  303  305  3729  5531  7151  4732  411  6188  305  410  1450  6140  413  3027  4403  4699  6188  411  413  6769  3119  6726  5385  496  5772  5036  339  5638  6019  304  6147  5384  303  6427  1322  304  1836  411  362  410  1399  305  4403  411  412  5390  411  5533  6188  6142  6532  6470  6064  411  6472  6645  411  6188  336  6188  6188  6035  6188  6188  4743  3730  6723  6019  4403  334  6452  4747  5536  3054  5538  5522  412  341  5530  305  5383  413  5470  304  6188  5512  303  6019  5523  304  4403  305  335  412  303  4403  6188  4403  304  303  304  4403  303  6720  6625  6724  381  412  305  304  412  412  304  412  412  303  413  305  305  6639  5525  5637  305  413  303  304  303  305  303  304  4403  6026  337  338  7022  342  340  3076  7033 ]]  #int:1 !jvms: JSON::parseObject @ bci:477&lt;br/&gt;
&amp;nbsp;3054   AddI    === _  3054  933  [[ 6428  6026  7008  339  1415  342  335  335  336  336  6019  3054  334  334  340  3091  7033  341  5501  338  337  7022 ]]  !orig=[7007],... !jvms: JSON::parseObject @ bci:821&lt;br/&gt;
# To suppress the following error report, specify this argument&lt;br/&gt;
# after -XX: or in .hotspotrc:  SuppressErrorAt=/phaseX.cpp:885&lt;br/&gt;
#&lt;br/&gt;
# A fatal error has been detected by the Java Runtime Environment:&lt;br/&gt;
#&lt;br/&gt;
#  Internal Error (/home/minghai/jdk11/src/hotspot/share/opto/phaseX.cpp:885), pid=22769, tid=22780&lt;br/&gt;
#  assert(no_dead_loop) failed: dead loop detected&lt;br/&gt;
#&lt;br/&gt;
# JRE version: OpenJDK Runtime Environment (11.0) (fastdebug build 11-internal+0-adhoc.minghai.jdk11)&lt;br/&gt;
# Java VM: OpenJDK 64-Bit Server VM (fastdebug 11-internal+0-adhoc.minghai.jdk11, compiled mode, tiered, compressed oops, g1 gc, linux-amd64)&lt;br/&gt;
# Core dump will be written. Default location: core.22769 (may not exist)&lt;br/&gt;
#&lt;br/&gt;
# An error report file with more information is saved as:&lt;br/&gt;
# /mnt/c/Users/Minghai/hs_err_pid22769.log&lt;br/&gt;
#&lt;br/&gt;
# Compiler replay data is saved as:&lt;br/&gt;
# /mnt/c/Users/Minghai/replay_pid22769.log&lt;br/&gt;
#&lt;br/&gt;
# If you would like to submit a bug report, please visit:&lt;br/&gt;
#   &lt;a href=&quot;http://bugreport.java.com/bugreport/crash.jsp&quot;&gt;http://bugreport.java.com/bugreport/crash.jsp&lt;/a&gt;&lt;br/&gt;
#&lt;br/&gt;
Current thread is 22780&lt;br/&gt;
Dumping core ...&lt;br/&gt;
zsh: abort (core dumped)   -Xcomp -cp  org.junit.runner.JUnitCore&lt;br/&gt;
&lt;br/&gt;
the log files, hs_err_pid22769.log and replay_pid22769.log are also attached.&lt;br/&gt;
&lt;br/&gt;
STEPS TO FOLLOW TO REPRODUCE THE PROBLEM :&lt;br/&gt;
1. extract the bug.zip&lt;br/&gt;
2. in dictionary &amp;quot;bug&amp;quot;, run command:&lt;br/&gt;
java -cp ./bugFiles:./util:./junit.jar:./hamcrest.jar:./target/classes:./target/test-classes org.junit.runner.JUnitCore com.alibaba.fastjson.deserializer.issue1463.TestIssue1463&lt;br/&gt;
&lt;br/&gt;
you may add &amp;quot;-Xcomp&amp;quot; or &amp;quot;-Xint&amp;quot; to get different results.&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
---------- BEGIN SOURCE ----------&lt;br/&gt;
to be attached in bug.zip&lt;br/&gt;
---------- END SOURCE ----------&lt;br/&gt;
&lt;br/&gt;
</description>
                <environment></environment>
        <key id="5066201">JDK-8280126</key>
            <summary>C2: detect and remove dead irreducible loops</summary>
                <type id="1" iconUrl="https://bugs.openjdk.org/secure/viewavatar?size=xsmall&amp;avatarId=14703&amp;avatarType=issuetype">Bug</type>
                                            <priority id="3" iconUrl="https://bugs.openjdk.org/images/jbsImages/p3.png">P3</priority>
                        <status id="5" iconUrl="https://bugs.openjdk.org/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="success"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="epeter">Emanuel Peter</assignee>
                                    <reporter username="webbuggrp">Webbug Group</reporter>
                        <labels>
                            <label>additional-information-received</label>
                            <label>c2</label>
                            <label>dcsaw</label>
                            <label>irreducibility</label>
                            <label>oracle-triage-18</label>
                            <label>reproducer-yes</label>
                            <label>webbug</label>
                    </labels>
                <created>Wed, 12 Jan 2022 23:26:23 -0800</created>
                <updated>Tue, 9 Sep 2025 02:21:15 -0700</updated>
                            <resolved>Tue, 7 Feb 2023 23:47:23 -0800</resolved>
                                    <version>8</version>
                    <version>11</version>
                    <version>11.0.12-oracle</version>
                    <version>17</version>
                    <version>18</version>
                    <version>19</version>
                    <version>20</version>
                    <version>21</version>
                                    <fixVersion>21</fixVersion>
                                    <component>hotspot</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>8</watches>
                                                                                                                <comments>
                            <comment id="14558162" author="dukebot" created="Tue, 7 Feb 2023 23:47:21 -0800"  >Changeset: ac7119f0&lt;br/&gt;
Author:    Emanuel Peter &amp;lt;&lt;a href=&apos;mailto:epeter@openjdk.org&apos;&gt;epeter@openjdk.org&lt;/a&gt;&amp;gt;&lt;br/&gt;
Date:      2023-02-08 07:45:09 +0000&lt;br/&gt;
URL:       &lt;a href=&quot;https://git.openjdk.org/jdk/commit/ac7119f0d5319a3fb44dc67a938c3e1eb21b9202&quot;&gt;https://git.openjdk.org/jdk/commit/ac7119f0d5319a3fb44dc67a938c3e1eb21b9202&lt;/a&gt;&lt;br/&gt;
</comment>
                            <comment id="14547407" author="roboduke" created="Thu, 22 Dec 2022 04:00:18 -0800"  >A pull request was submitted for review.&lt;br/&gt;
URL: &lt;a href=&quot;https://git.openjdk.org/jdk/pull/11764&quot;&gt;https://git.openjdk.org/jdk/pull/11764&lt;/a&gt;&lt;br/&gt;
Date: 2022-12-22 08:40:48 +0000</comment>
                            <comment id="14536288" author="JIRAUSER19821" created="Thu, 10 Nov 2022 05:20:41 -0800"  >I found a T.java that produces an irreducible loop, which is then later cut off, and the data internally collapses in a bad way, such that we create a data-dead-loop -&amp;gt; assert. In production, this leads to a SIGSEGV.&lt;br/&gt;
&lt;br/&gt;
See T.jasm, and image series in zip.&lt;br/&gt;
&lt;br/&gt;
Analysis:&lt;br/&gt;
I have a &amp;quot;killswitch&amp;quot; (red), the &amp;quot;if (x == 0)&amp;quot;. This cuts the backedge from before the OSR.&lt;br/&gt;
I wanted a &amp;quot;empty_loop&amp;quot; to collapse during OSR-compilation. Since it contains a backedge, I have to make sure it is visited once before OSR compilation, hence LOOP3 (triggers OSR, green) is in an extra if-statement. There, we also set x=1, which activates the &amp;quot;killswitch&amp;quot;.&lt;br/&gt;
It then takes a while until the &amp;quot;empty_loop&amp;quot; properly falls apart - eventually during IGVN it does, rips away the entries to the irreducible loop (always have y==0, return directly).&lt;br/&gt;
We have the data for &amp;quot;i&amp;quot; -&amp;gt; it quickly collapses when the control flow collapses (pink). We can see that the control flow of the LOOP1 is already very close to dying too -&amp;gt; 252 SafePoint will soon disappear, and remove 357 Loop, eventually the whole code would be deleted - except we process &amp;quot;310 LShiftI&amp;quot; (i *= 2) first, which is already a self-loop.&lt;br/&gt;
Solution: we have to make sure to detect when the irreducible loop is disconnected, and aggressively remove control-flow.&lt;br/&gt;
&lt;br/&gt;
What this shows: it is possible to create difficult irreducible loops with just pure Java, with OSR.&lt;br/&gt;
Unfortunately, I still need to restrict the trap-limit, will need to investigate if that is really necessary.&lt;br/&gt;
It seems to take a lot to trigger such a scenario - but it is possible.&lt;br/&gt;
&lt;br/&gt;
Reproduce it like this:&lt;br/&gt;
java -XX:CompileCommand=compileonly,T::test -XX:-TieredCompilation -XX:PerMethodTrapLimit=0 T.java&lt;br/&gt;
&lt;br/&gt;
I usually run it like this:&lt;br/&gt;
java -XX:+UnlockExperimentalVMOptions -XX:+UseG1GC -XX:CompileCommand=compileonly,T::test -XX:-TieredCompilation -XX:-RenumberLiveNodes -XX:PerMethodTrapLimit=0 -XX:+TraceLoopOpts -Xbatch T.java&lt;br/&gt;
&lt;br/&gt;
Results:&lt;br/&gt;
&lt;br/&gt;
(product)&lt;br/&gt;
openjdk 17.0.4 2022-07-19&lt;br/&gt;
OpenJDK Runtime Environment (build 17.0.4+8-Ubuntu-120.04)&lt;br/&gt;
OpenJDK 64-Bit Server VM (build 17.0.4+8-Ubuntu-120.04, mixed mode, sharing)&lt;br/&gt;
#  SIGSEGV (0xb) at pc=0x00007fb7d02ab8fa, pid=1412770, tid=1412783&lt;br/&gt;
&lt;br/&gt;
(debug)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;0  Root  === 0 316  [[ 0 1 3 249 21 182 26 238 30 212 34 209 38 67 81 83 87 88 91 92 206 139 142 153 164 370 425 503 538 571 573 575 609 ]] &lt;br/&gt;
&amp;nbsp;&amp;nbsp;91  ConI  === 0  [[ 311 167 166 310 252 179 ]]  #int:1&lt;br/&gt;
&amp;nbsp;310  LShiftI  === _ 310 91  [[ 311 310 252 289 167 293 273 302 ]]  !orig=[251],263 !jvms: T::test @ bci:151 (line 10)&lt;br/&gt;
#  Internal Error (/home/emanuel/Documents/fork6-jdk/open/src/hotspot/share/opto/phaseX.cpp:943), pid=1413030, tid=1413043&lt;br/&gt;
#  assert(no_dead_loop) failed: dead loop detected&lt;br/&gt;
#&lt;br/&gt;
# JRE version: Java(TM) SE Runtime Environment (20.0) (slowdebug build 20-internal-2022-11-09-0613525.emanuel...)&lt;br/&gt;
# Java VM: Java HotSpot(TM) 64-Bit Server VM (slowdebug 20-internal-2022-11-09-0613525.emanuel..., mixed mode, compressed oops, compressed class ptrs, g1 gc, linux-amd64)&lt;br/&gt;
# Problematic frame:&lt;br/&gt;
# V  [libjvm.so+0x115478c]  PhaseGVN::dead_loop_check(Node*)+0x180&lt;br/&gt;
&lt;br/&gt;
Edit:&lt;br/&gt;
The trap-limit is necessary here, else we get an uncommon_trap at the loop-exit of LOOP3, since the loop-exit was never taken before OSR:&lt;br/&gt;
122  CallStaticJava  === 117 98 119 8 9 (121 1 1 101 1 102 103 104 1 109 ) [[ 123 ]] # Static uncommon_trap(reason=&amp;#39;unstable_if&amp;#39; action=&amp;#39;reinterpret&amp;#39; debug_id=&amp;#39;0&amp;#39;)  void ( int ) C=0.000100 T::test @ bci:65 (line 19) reexecute !jvms: T::test @ bci:65 (line 19)&lt;br/&gt;
&lt;br/&gt;
Maybe we can somehow avoid hitting any of the profiling unc_traps.&lt;br/&gt;
But I think it is quite difficult.&lt;br/&gt;
An easier, but probably contrived way is to exhaust the traps.&lt;br/&gt;
&lt;br/&gt;
Edit2:&lt;br/&gt;
T2.java&lt;br/&gt;
We can exhaust the unc_traps. But it is a bit contrived.&lt;br/&gt;
java -XX:CompileCommand=compileonly,T::test -XX:-TieredCompilation -XX:PerMethodTrapLimit=5 T.java&lt;br/&gt;
I have 5 &amp;quot;decoy&amp;quot; for loops. Each one triggers OSR, and sets a &amp;quot;unstable_if&amp;quot; at the loop-exit. Once the OSR execution exits the respective loop, the unc_trap is triggered, we decompile. Then the next for-loop OSR compiles. Until we exhaust the unc_trap limit for &amp;quot;unstable_if&amp;quot;.&lt;br/&gt;
Default trap limit is 100, and given this example we could extend it easily by copying the for-loops 100 times. Maybe there is another solution, but I did not get simple if / switch to work for that.&lt;br/&gt;
&lt;br/&gt;
Edit3:&lt;br/&gt;
T3.java&lt;br/&gt;
java -XX:PerMethodTrapLimit=10 T3.java&lt;br/&gt;
We can exhaust the trap limit, and do not need the number of &amp;quot;decoy&amp;quot; loops to be exactly equal to the trap limit, the trap limit just needs to be lower than the number of &amp;quot;decoy&amp;quot; loops. Xcomp seems required, but that can probably also be circumvented. -Xbatch may be required if the &amp;quot;decoy&amp;quot; loops do not perform enough iterations.&lt;br/&gt;
Note: we can easily duplicate the &amp;quot;decoy&amp;quot; loops more, and exhaust the default trap limit of 100.</comment>
                            <comment id="14535593" author="JIRAUSER19821" created="Tue, 8 Nov 2022 09:07:12 -0800"  >Update:&lt;br/&gt;
I am now working on a test-collection: TestIrreducibleLoops.jasm&lt;br/&gt;
test_001: Q3.jasm - relatively simple irreducible loop&lt;br/&gt;
test_002: Q1.jasm - triggers split_fall_in&lt;br/&gt;
test_003: N.jasm - cut off both entries at the same time, would trigger CFG assert&lt;br/&gt;
test_004: A2.jasm - triggers PhiNode::merge_through_phi &amp;quot;sanity&amp;quot; assert because of dead Phi-loop&lt;br/&gt;
test_005: K.jasm - infinite irreducible loop -&amp;gt; bailout&lt;br/&gt;
test_006: D2.jasm - triggers data dead-loop assert with self-referencing AddI node - StressIGVN can make it intermittent, as the order of decay matters&lt;br/&gt;
test_007: old entries lose &amp;quot;backedge&amp;quot; controls, and are collapsed. Internal nodes take over as irreducible loop entry.&lt;br/&gt;
test_008: same, but collapse happens already during parsing, not loop-opts like test_007.&lt;br/&gt;
test_009: same as test_007, except that there are additional if-statements that are no longer in loop when old entries lose &amp;quot;backedge&amp;quot; control. New entries are below the if-section.&lt;br/&gt;
&lt;br/&gt;
Update (Nov 15):&lt;br/&gt;
test_010: reducible loop in irreducible loop, with same loop head.&lt;br/&gt;
test_011: irreducible loop entry detection is not consistent, depends on DF traversal order.&lt;br/&gt;
test_012: WIP</comment>
                            <comment id="14535457" author="JIRAUSER19821" created="Tue, 8 Nov 2022 01:02:37 -0800"  >Not all irreducible loop heads are necessarily &amp;quot;irreducible loop entry&amp;quot;.&lt;br/&gt;
See Q3.jasm as example.&lt;br/&gt;
&amp;nbsp;43  Region  === 43 _ 39  [[ 43 41 ]]  #irreducible-entry !jvms: Q3::test @ bci:14&lt;br/&gt;
&amp;nbsp;44  Region  === 44 _ 38  [[ 44 24 ]]  #irreducible-entry !jvms: Q3::test @ bci:22&lt;br/&gt;
&amp;nbsp;60  Region  === 60 _ 56  [[ 60 58 ]]  #irreducible !jvms: Q3::test @ bci:25</comment>
                            <comment id="14534918" author="JIRAUSER19821" created="Fri, 4 Nov 2022 09:44:19 -0700"  >Update to previous Work Status report:&lt;br/&gt;
&lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8280126?focusedCommentId=14532876&amp;page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-14532876&quot;&gt;https://bugs.openjdk.org/browse/JDK-8280126?focusedCommentId=14532876&amp;amp;page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-14532876&lt;/a&gt;&lt;br/&gt;
&lt;br/&gt;
Fuzzing found more of the same 3 asserts:&lt;br/&gt;
CFG          -&amp;gt; assert(!in-&amp;gt;is_CFG()) failed: CFG Node with no controlling input?&lt;br/&gt;
sanity       -&amp;gt; assert(cached_vbox != __null) failed: sanity&lt;br/&gt;
dead-loop -&amp;gt; assert(no_dead_loop) failed: dead loop detected&lt;br/&gt;
&lt;br/&gt;
All of these seem to have to do with dead irreducible loops. However, the sanity assert is somewhat less related, as it seems to be an optimization that makes assumptions that are not really given.&lt;br/&gt;
The CFG and the dead-loop assert can be prevented if we track the irreducible regions properly, and do connectivity check every time we lose a control input.&lt;br/&gt;
&lt;br/&gt;
In addition, fuzzing seems to hit my own assert, if I do not track the irreducible regions correctly (eg. Q1.jasm).&lt;br/&gt;
&lt;br/&gt;
Fuzzing also found 3 unrelated asserts, bugs reported in:&lt;br/&gt;
&lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8296412&quot; title=&quot;Special case infinite loops with unmerged backedges in IdealLoopTree::check_safepts&quot; class=&quot;issue-link&quot; data-issue-key=&quot;JDK-8296412&quot;&gt;&lt;strike&gt;JDK-8296412&lt;/strike&gt;&lt;/a&gt;, &lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8296389&quot; title=&quot;C2: PhaseCFG::convert_NeverBranch_to_Goto must handle both orders of successors&quot; class=&quot;issue-link&quot; data-issue-key=&quot;JDK-8296389&quot;&gt;&lt;strike&gt;JDK-8296389&lt;/strike&gt;&lt;/a&gt;, &lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8296318&quot; title=&quot;use-def assert: special case undetected loops nested in infinite loops&quot; class=&quot;issue-link&quot; data-issue-key=&quot;JDK-8296318&quot;&gt;&lt;strike&gt;JDK-8296318&lt;/strike&gt;&lt;/a&gt;&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
Good test candidates:&lt;br/&gt;
N.jasm - triggers CFG assert, with simple irreducible loop prepended by empty loop, in PhaseIdealLoop::verify&lt;br/&gt;
A2.jasm - triggers merge_through_phi sanity assert, with irreducible loop in loop, right after parsing&lt;br/&gt;
K.jasm - bailout bad CFG. K3 infinite irreducible loop, under loop with modulo condition that collapses during loop-opts.&lt;br/&gt;
D2.jasm - trigger &amp;quot;dead loop detected&amp;quot;. Not as simple as maybe hoped for, but maybe hard to do simpler. empty loop plus irreducible loop with nested loop. Irreducible loop dies from inside via data to control to data.&lt;br/&gt;
Q1.jasm - trigger assert that checks that we do not find irreducible regions that we did not reviously mark. This Q1.jasm creates a new Region in split_fall_in that must be marked as irreducible if the previous region was marked irreducible.&lt;br/&gt;
&lt;br/&gt;
What I still wish:&lt;br/&gt;
maype: dead_loop assert in a simpler way - maybe with StressIGVN?&lt;br/&gt;
(really not so important - but I need to run with StressIGVN during fuzzing)&lt;br/&gt;
&lt;br/&gt;
Edit done:&lt;br/&gt;
infinite irreducible loop&lt;br/&gt;
maybe: OSR irreducible graph case - but probably not relevant&lt;br/&gt;
&lt;br/&gt;
Edit most likely not possible:&lt;br/&gt;
irreducible loop where one entry falls quick, the other only later&lt;br/&gt;
irreducible loop that gets converted into a int-counted loop, maybe then becomes dead also&lt;br/&gt;
(the previous two ideas could be done with the empty_loop and the unrolling template)&lt;br/&gt;
(why it is not possible: once we lose all but one entry, the graph becomes reducible -&amp;gt; collapses normally)&lt;br/&gt;
maybe: trigger merge_through_phi outside an irreducible loop - probably not possible</comment>
                            <comment id="14534915" author="JIRAUSER19821" created="Fri, 4 Nov 2022 09:31:21 -0700"  >FYI:&lt;br/&gt;
Fuzzing found another assert triggered. Looks like a separate bug. Filed it as &lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8296412&quot; title=&quot;Special case infinite loops with unmerged backedges in IdealLoopTree::check_safepts&quot; class=&quot;issue-link&quot; data-issue-key=&quot;JDK-8296412&quot;&gt;&lt;strike&gt;JDK-8296412&lt;/strike&gt;&lt;/a&gt;.</comment>
                            <comment id="14534133" author="JIRAUSER19821" created="Wed, 2 Nov 2022 07:15:10 -0700"  >R.jasm (see file and pictures,  including series in zip file)&lt;br/&gt;
&lt;br/&gt;
#  Internal Error (/home/emanuel/Documents/fork2-jdk/open/src/hotspot/share/opto/node.cpp:830), pid=1965983, tid=1965996&lt;br/&gt;
#  assert(idx &amp;lt; _cnt) failed: oob&lt;br/&gt;
# V  [libjvm.so+0x1095f68]  Node::del_req(unsigned int)+0x26&lt;br/&gt;
&lt;br/&gt;
Happens in PhaseCFG::convert_NeverBranch_to_Goto&lt;br/&gt;
&lt;br/&gt;
Context:&lt;br/&gt;
Normal case: &amp;quot;live&amp;quot;/&amp;quot;succ&amp;quot; projection is added as output of NeverBranch before the &amp;quot;dead&amp;quot; projection leading to Halt.&lt;br/&gt;
Details: During DFS, usually we go from Halt to NeverBranch. Then via Region/Loop, take backedge, and find the &amp;quot;live&amp;quot;/&amp;quot;succ&amp;quot; edge. We already have its inputs (NeverBranch), thus we can now post-visit the live edge, and attach it to the NeverBranch first. Later, once we have processed the whole infinite loop, we post-visit out of NeverBranch to the &amp;quot;dead&amp;quot; projection edge, which we attach second.&lt;br/&gt;
&lt;br/&gt;
In R.jasm:&lt;br/&gt;
Abnormal order: &amp;quot;dead&amp;quot; projection is first attached to NeverBranch, and &amp;quot;live&amp;quot;/&amp;quot;succ&amp;quot; projection is added second.&lt;br/&gt;
Details: In our pathological case, we go in through the shared 122 Halt, and first visit the 166 NeverBranch of the peeled iteration, and visit all of what is above. But there is no backedge, so we will not find the &amp;quot;live&amp;quot; edge, and we post-visit the &amp;quot;dead&amp;quot; edge first (171 CProj). Then, we take the second branch of the Halt, and visit the peeled loop. From there, we finally find the &amp;quot;live&amp;quot; projection (167 CProj) of the peeled iterations NeverBranch, and attach it second.&lt;br/&gt;
A further detail: 159 Halt is visited even later, which is somewhat relevant, because if it was visited before 122 Halt, then we would first attach the &amp;quot;live&amp;quot; 167CProj, and avoid the bug.&lt;br/&gt;
&lt;br/&gt;
Why is the order of &amp;quot;live&amp;quot;/&amp;quot;succ&amp;quot; Projection vs the &amp;quot;dead&amp;quot; one relevant?&lt;br/&gt;
It predicts in what order we later DFS traverse the nodes for scheduling the nodes into blocks, and also matters the order of successor blocks.&lt;br/&gt;
It seems that the code in PhaseCFG::convert_NeverBranch_to_Goto expects the &amp;quot;succ&amp;quot; projection and block to have idx=0. On first appearance the code looks like it should also handle the inverted case where &amp;quot;succ&amp;quot; has idx=1, but the code has a bug, where we overwrite the _succs array where the &amp;quot;dead&amp;quot; block reference is stored before we read it off.&lt;br/&gt;
&lt;br/&gt;
This looks somewhat related to irreducible loops, but maybe this bug is reproducible without irreducible loops. In this case, the decaying irreducible loop creates a situation with multiple NeverBranch nodes in a subgraph, and a special order of creation which seems relevant for the specific DFS traversal during matching, which leads to the inversion, and the eventual assert in the DFS traversial during scheduling.&lt;br/&gt;
&lt;br/&gt;
Update: I found a case without irreducible loops! Bug filed under &lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8296389&quot; title=&quot;C2: PhaseCFG::convert_NeverBranch_to_Goto must handle both orders of successors&quot; class=&quot;issue-link&quot; data-issue-key=&quot;JDK-8296389&quot;&gt;&lt;strike&gt;JDK-8296389&lt;/strike&gt;&lt;/a&gt;</comment>
                            <comment id="14533711" author="JIRAUSER19821" created="Tue, 1 Nov 2022 23:16:04 -0700"  >I am working on a fix, that tags the Regions &amp;quot;irreducible&amp;quot; if we find out at some point (during parsing in ciTypeFlow) that they are either the head or a &amp;quot;secondary entry&amp;quot; to an irreducible loop. Whenever such a tagged node loses any control input, we must check if the region is still connected to Root.&lt;br/&gt;
&lt;br/&gt;
This solution assumes that we can also detect new Region nodes that are created &amp;quot;irreducible&amp;quot;, and we must tag them too.&lt;br/&gt;
&lt;br/&gt;
I found a Q1.jasm (attached, with 2 pictures). We see that in split_fall_in, we have a loop-head Region node that is tagged &amp;quot;irreducible&amp;quot;, and we multiple of its fall-in controls away into a separate region. It is now possible that this new separate region takes over as the entry to the irreducible loop. In Q1.jasm, this is the case.&lt;br/&gt;
&lt;br/&gt;
TODO: There may be more such cases, I need to investigate.</comment>
                            <comment id="14533433" author="JIRAUSER19821" created="Mon, 31 Oct 2022 08:34:27 -0700"  >I have started a jasm-byte-code-fuzzer project. It spat out some jasm files that trigger some asserts that are already reported here. But I found a new case.&lt;br/&gt;
&lt;br/&gt;
P.jasm&lt;br/&gt;
(see attached, plus pictures)&lt;br/&gt;
#  assert(is_loop || block-&amp;gt;find_node(def) &amp;lt; j) failed: uses must follow definitions&lt;br/&gt;
&lt;br/&gt;
Analysis:&lt;br/&gt;
The assert checks that if both use and def are in the same block, we have def &amp;lt; use (before).&lt;br/&gt;
There are some exceptions where we do not check this.&lt;br/&gt;
First, we do not check this if we have a LoopNode as the block head, since the backedge might cause def/use to be in a loop (def-use-....-def).&lt;br/&gt;
There is another special case &amp;quot;tight loop with no LoopNode&amp;quot;. I am currently not sure what exactly this could be. Maybe it can even be removed.&lt;br/&gt;
&lt;br/&gt;
In this specific example, the block-region can be traced back to a irreducible-loop-entry/head.&lt;br/&gt;
Possibly this is a new case we have not handled, and may have to fix / special case in the assert.&lt;br/&gt;
More info: We only run PhaseIdealLoop::build_loop_tree once, and find the NeverBranch case (no loop exit). Thus, in this run, the found loops are not attached to the loop tree, and the Regions are not transformed to LoopNodes.&lt;br/&gt;
Q: is this really infinite loop specific?&lt;br/&gt;
&lt;br/&gt;
Found non-irreducible case for this: &lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8296318&quot; title=&quot;use-def assert: special case undetected loops nested in infinite loops&quot; class=&quot;issue-link&quot; data-issue-key=&quot;JDK-8296318&quot;&gt;&lt;strike&gt;JDK-8296318&lt;/strike&gt;&lt;/a&gt;</comment>
                            <comment id="14533038" author="JIRAUSER19821" created="Fri, 28 Oct 2022 04:23:19 -0700"  >I attached D2.jasm, and pictures (see zip for the 10 interesting steps)&lt;br/&gt;
#  assert(no_dead_loop) failed: dead loop detected&lt;br/&gt;
For a self-referencing AddI node&lt;br/&gt;
&lt;br/&gt;
Code:&lt;br/&gt;
LOOP_Y: empty_loop (violet)&lt;br/&gt;
Condition that turns out to be false after LOOP_Y collapses -&amp;gt; LOOP_3 is cut off&lt;br/&gt;
LOOP_3: irreducible loop, with an inner loop&lt;br/&gt;
&lt;br/&gt;
Analysis:&lt;br/&gt;
LOOP_Y collapses and cuts off LOOP_3 in PhaseIdealLoop.&lt;br/&gt;
During IGVN, we see that LOOP_3 dies from the inside out, which leads to some bad states.&lt;br/&gt;
For one, we have an AddI that references itself, but also an 140 If has no IfTrue anymore.&lt;br/&gt;
This happens because the data-nodes for register 0 eventually collapse, as they realize that they have no inputs. 106 Phi finds that its unique input is TOP. As the inner loop of LOOP_3 has a condition depending on register 0, the dying data-flow makes the control-flow die as well. Eventually, 192 Region dies, which then also removes 193 Phi from register 12, and 159 Phi realizes that 175 AddI is its unique input and subsumes itself with that 175 AddI. Now we have a self-reverencing AddI, which leads to the dead-loop assert next time the AddI is processed on the worklist. (edited) </comment>
                            <comment id="14532876" author="JIRAUSER19821" created="Thu, 27 Oct 2022 09:23:53 -0700"  >Good test candidates:&lt;br/&gt;
N.jasm - triggers CFG assert, with simple irreducible loop prepended by empty loop, in PhaseIdealLoop::verify&lt;br/&gt;
A2.jasm - triggers merge_through_phi sanity assert, with irreducible loop in loop, right after parsing&lt;br/&gt;
K.jasm - bailout bad CFG. K3 infinite irreducible loop, under loop with modulo condition that collapses during loop-opts.&lt;br/&gt;
D2.jasm - trigger &amp;quot;dead loop detected&amp;quot;. Not as simple as maybe hoped for, but maybe hard to do simpler. empty loop plus irreducible loop with nested loop. Irreducible loop dies from inside via data to control to data.&lt;br/&gt;
&lt;br/&gt;
What I still need/want:&lt;br/&gt;
infinite irreducible loop&lt;br/&gt;
irreducible loop where one entry falls quick, the other only later&lt;br/&gt;
irreducible loop that gets converted into a int-counted loop, maybe then becomes dead also&lt;br/&gt;
maype: dead_loop assert in a simpler way&lt;br/&gt;
maybe: trigger merge_through_phi outside an irreducible loop - probably not possible&lt;br/&gt;
maybe: OSR irreducible graph case - but probably not relevant</comment>
                            <comment id="14532604" author="JIRAUSER19821" created="Wed, 26 Oct 2022 07:33:10 -0700"  >Just found &lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-6742111&quot; title=&quot;split_flow_path can create irreducible loops&quot; class=&quot;issue-link&quot; data-issue-key=&quot;JDK-6742111&quot;&gt;&lt;strike&gt;JDK-6742111&lt;/strike&gt;&lt;/a&gt;, a case where we seem to generate irreducible loops during an optimization. Not sure if it is still true. And there is a comment in the code:&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;// disable assert until issue with split_flow_path is resolved (6742111)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;// assert(!_has_irreducible_loops || C-&amp;gt;parsed_irreducible_loop() || C-&amp;gt;is_osr_compilation(),&lt;br/&gt;
&amp;nbsp;&amp;nbsp;//        &amp;quot;shouldn&amp;#39;t introduce irreducible loops&amp;quot;);&lt;br/&gt;
&lt;br/&gt;
it seems to be the only use of parsed_irreducible_loop&lt;br/&gt;
&lt;br/&gt;
Problem with this:&lt;br/&gt;
If we have no irreducilbe loop in the graph, and then suddenly an optimization creates irreducibility, we might not realize until PhaseIdealLoop build_loop_tree. And then who knows if we might not end up with dead code.</comment>
                            <comment id="14532577" author="JIRAUSER19821" created="Wed, 26 Oct 2022 05:11:00 -0700"  >A2.jasm&lt;br/&gt;
(see file and 2 attached pictures)&lt;br/&gt;
&lt;br/&gt;
We seem to be generating some sort of loop/irreducible subgraph, that is still connected at PHASE_AFTER_PARSING.&lt;br/&gt;
But during IGVN (PHASE_ITER_GVN1), we lose control, and the graph disconnects, without collapsing.&lt;br/&gt;
We trigger this assert because we have a dead-phi-loop:&lt;br/&gt;
#  assert(cached_vbox != __null) failed: sanity&lt;br/&gt;
&lt;br/&gt;
Interesting about this assert is that it triggers so early, right after parsing.&lt;br/&gt;
The question is if this really depends on the irreducibility in the graph.&lt;br/&gt;
I think it has to do something with us inserting more Phi nodes if there is an irreducible loop.</comment>
                            <comment id="14532517" author="JIRAUSER19821" created="Wed, 26 Oct 2022 00:35:47 -0700"  >N.jasm&lt;br/&gt;
(see file attached and 2 graph pictures)&lt;br/&gt;
&lt;br/&gt;
LOOP_Y (orange) collapses during PhaseIdealLoop, as an empty_loop. This makes that 87 If always is False, so during IGVN of PhaseIdealLoop, LOOP_3 (green) loses control. But LOOP_3 does not collapse, and in PhaseIdealLoop::verify we detect it as dead-code:&lt;br/&gt;
# assert(!in-&amp;gt;is_CFG()) failed: CFG Node with no controlling input?&lt;br/&gt;
&lt;br/&gt;
Why does LOOP_3 (green) not collapse?&lt;br/&gt;
We have an irreducible loop (head at 104 Region, second entry at 103 Region). Thus, we have no LoopNode, and when one of those region loses control, we decide that there is no &amp;quot;unsafe case&amp;quot;. As far as we understand, the definition of &amp;quot;safe dead loops&amp;quot; depends on having only reducible loops.&lt;br/&gt;
&lt;br/&gt;
Result of conversation:&lt;br/&gt;
We need to know if we detect all irreducible loops. If yes, we could try one of these solutions:&lt;br/&gt;
1) have global flag &amp;quot;have any irreducible loops&amp;quot;. If true, we always do reachability check if any Region loses any control input. Simple solution, but may be expensive, even for regions that are not part of irreducible loops.&lt;br/&gt;
2) Find a way to mark all Regions that are implicated by the irreducible loop, and only do reachability there.&lt;br/&gt;
3) Bailout would not be very desirable.&lt;br/&gt;
4) An eventual goal should be to elliminate irreducibility from C2.&lt;br/&gt;
&lt;br/&gt;
One task worth investing in: See if we can reproduce dead-loop asserts elsewhere (outside PhaseIdealLoop) with similar code.</comment>
                            <comment id="14531031" author="JIRAUSER19821" created="Wed, 19 Oct 2022 08:26:47 -0700"  >I am currently playing around to get more examples. And make them more readable.&lt;br/&gt;
My working hypothesis was that we do not handle irreducible loops well during PhaseIdealLoop and its IGVN runs.&lt;br/&gt;
Now I found a K.jasm where we bailout with reason &amp;quot;unhandled CFG detected during loop optimization&amp;quot;.&lt;br/&gt;
The comments around that location tell me that PhaseIdealLoop::build_loop_tree_impl is not happy that it found a second loop entry.&lt;br/&gt;
&lt;br/&gt;
I attached the K.jasm, plus a CFG snapshot in picture form.&lt;br/&gt;
&lt;br/&gt;
Now I need to find out for which irreducible loops we bailout, and why, and why we do not bailout in the other cases I found.&lt;br/&gt;
&lt;br/&gt;
Update: we indeed first enter the &amp;quot;green loop&amp;quot; via 116, and later also via the second entry 108. We have already post-traversed the whole &amp;quot;green loop&amp;quot; from 116, so when we look at it again from 108, we detect that we were have a second entry -&amp;gt; bailout. I wonder if this bailout is necessary? Could we not just &amp;quot;undo&amp;quot; the loops here?</comment>
                            <comment id="14529403" author="JIRAUSER19821" created="Wed, 12 Oct 2022 04:17:41 -0700"  >Summary:&lt;br/&gt;
&lt;br/&gt;
1.&lt;br/&gt;
I think we have two bugs. I have a H.jasm where we do not hit the &amp;quot;sanity&amp;quot; assert because we never generate a dead-loop that is only Phi&amp;#39;s.&lt;br/&gt;
&lt;br/&gt;
2.&lt;br/&gt;
I have multiple examples now, where we can see that if we produce a data-dead-loop during IGVN, and the dead-loop is not removed:&lt;br/&gt;
&lt;br/&gt;
2a)&lt;br/&gt;
This can trigger asserts during IGVN, like if we are left with a singular AddI node that references itself.&lt;br/&gt;
&lt;br/&gt;
2b)&lt;br/&gt;
I can also extend it to 3-hop cycles of for example MulF,ConvF2I,ConvI2F. This is not cought by the dead-loop assert, because we only catch 2-hop cycles at most.&lt;br/&gt;
&lt;br/&gt;
2c)&lt;br/&gt;
Further, there are cases where we are left with a Phi node that has a AddI as left input and AddI as right input, but both of those have the Phi node as input -&amp;gt; we have a :infinity:  shaped double-dead-loop. This is not detected.&lt;br/&gt;
&lt;br/&gt;
2d)&lt;br/&gt;
I can create a more complex loop with multiple Phi&amp;#39;s and AddI, which is also a dead-loop.&lt;br/&gt;
&lt;br/&gt;
Cases 2 b-d are all not detected during IGVN, and run into dead-code detection in PhaseIdealLoop::verify.&lt;br/&gt;
# assert(!in-&amp;gt;is_CFG()) failed: CFG Node with no controlling input?&lt;br/&gt;
The problem is that we assume that there is no dead code after IGVN.&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
---&lt;br/&gt;
I think in &amp;quot;normal&amp;quot; cases (the ones where we do not have some ugly irreducible loop), we do not have Phi nodes that dead-loop in this way (e.g. :infinity: shape). Normally, the dead-loop is expected to collapse. If the loop has no dependency on the data-dead-loop (e.g. and If in the loop depends on that data), we have no problem, the data has no use and it is removed (not sure yet how the control is also removed, but that seems to happen somehow I guess). If we do have some If that depends on that data-dead-loop, it seems we do need the data-dead-loop to collapse / be replaced with TOP. This causes the control also to collapse. If the control does not collapse, we eventually have some control connection down to Root, and PhaseIdealLoop::verify will find that connection and assert because it sees that this is dead code.</comment>
                            <comment id="14529401" author="JIRAUSER19821" created="Wed, 12 Oct 2022 04:04:18 -0700"  >H.jasm&lt;br/&gt;
-&amp;gt; similar to D.jasm, but I can avoid hitting the &amp;quot;sanity&amp;quot; assert. This shows that we most likely do have two separate bugs here.&lt;br/&gt;
&lt;br/&gt;
java -jar ~/Documents/asmtools-7.0-build/release/lib/asmtools.jar jasm H.jasm&lt;br/&gt;
&lt;br/&gt;
./java -XX:+UnlockExperimentalVMOptions -XX:+UseG1GC -XX:+PrintOptoAssembly -XX:-UseLoopPredicate -XX:-UseProfiledLoopPredicate -XX:+TraceLoopOpts -XX:+PrintInlining -Xcomp -XX:CompileCommand=compileonly,H::test -XX:-TieredCompilation -XX:-LoopUnswitching  H&lt;br/&gt;
&lt;br/&gt;
Loop: N0/N0  has_sfpt&lt;br/&gt;
&amp;nbsp;&amp;nbsp;Loop: N167/N175  IRREDUCIBLE sfpts={ 175 }&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Loop: N260/N258  limit_check sfpts={ 232 239 }&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;0  Root  === 0 251 209  [[ 0 1 3 22 23 48 55 98 99 116 237 ]] &lt;br/&gt;
&amp;nbsp;237  ConI  === 0  [[ 238 ]]  #int:2&lt;br/&gt;
&amp;nbsp;238  AddI  === _ 238 237  [[ 244 239 175 238 205 205 ]]  !orig=172,[191],216 !jvms: H::test @ bci:64&lt;br/&gt;
...&lt;br/&gt;
#  Internal Error (/home/emanuel/Documents/fork2-jdk/open/src/hotspot/share/opto/phaseX.cpp:943), pid=1847547, tid=1847560&lt;br/&gt;
#  assert(no_dead_loop) failed: dead loop detected</comment>
                            <comment id="14529397" author="JIRAUSER19821" created="Wed, 12 Oct 2022 03:45:31 -0700"  >G.jasm&lt;br/&gt;
-&amp;gt; IGVN leaves dead-loop with multiple Phi and Addi nodes -&amp;gt; PhaseIdealLoop::verify finds dead code, asserts&lt;br/&gt;
&lt;br/&gt;
java -jar ~/Documents/asmtools-7.0-build/release/lib/asmtools.jar jasm G.jasm&lt;br/&gt;
&lt;br/&gt;
./java -XX:+UnlockExperimentalVMOptions -XX:+UseG1GC -XX:+PrintOptoAssembly -XX:-UseLoopPredicate -XX:-UseProfiledLoopPredicate -XX:+TraceLoopOpts -XX:+PrintInlining -Xcomp -XX:CompileCommand=compileonly,G::test -XX:-TieredCompilation -XX:-LoopUnswitching  G&lt;br/&gt;
&lt;br/&gt;
#  Internal Error (/home/emanuel/Documents/fork2-jdk/open/src/hotspot/share/opto/loopnode.cpp:5284), pid=1840533, tid=1840546&lt;br/&gt;
#  assert(!in-&amp;gt;is_CFG()) failed: CFG Node with no controlling input?&lt;br/&gt;
&lt;br/&gt;
&lt;a href=&quot;https://bugs.openjdk.org/secure/attachment/101053/G.jasm.crash.graph.png&quot;&gt;https://bugs.openjdk.org/secure/attachment/101053/G.jasm.crash.graph.png&lt;/a&gt;</comment>
                            <comment id="14528656" author="JIRAUSER19821" created="Sun, 9 Oct 2022 23:18:22 -0700"  >Summary so far:&lt;br/&gt;
&lt;br/&gt;
A.jasm&lt;br/&gt;
&amp;nbsp;-&amp;gt; Phi loop -&amp;gt; bad assumption in PhiNode::merge_through_phi (Phi nodes are dead_loop_safe, so phi-dead-loops are allowed, the sanity assert is incorrect)&lt;br/&gt;
D.jasm&lt;br/&gt;
&amp;nbsp;-&amp;gt; last Phi with a unique input of an AddI, that collapses to a self-looping AddI -&amp;gt; dead-loop assert&lt;br/&gt;
E.jasm&lt;br/&gt;
&amp;nbsp;-&amp;gt; Phi with left-loop and right-loop (2 AddI that loop back to Phi). -&amp;gt; dead-loop not detected -&amp;gt; fail in PhaseIdealLoop::verify&lt;br/&gt;
F.jasm&lt;br/&gt;
&amp;nbsp;-&amp;gt; last Phi with unique input of 3-hop Loop (MulF -&amp;gt; ConvF2I -&amp;gt; ConvI2F -&amp;gt; MulI). dead-loop assert does not trigger because cycle too long, but PhaseIdealLoop::verify finds dead code, asserts</comment>
                            <comment id="14528654" author="JIRAUSER19821" created="Sun, 9 Oct 2022 23:08:52 -0700"  >I just added an F.jasm, where the optimization finally leads to a 3-hop data-deadloop.&lt;br/&gt;
&lt;br/&gt;
See the relevant subgraph here:&lt;br/&gt;
&lt;a href=&quot;https://bugs.openjdk.org/secure/attachment/101004/F.jasm.crash.graph.png&quot;&gt;https://bugs.openjdk.org/secure/attachment/101004/F.jasm.crash.graph.png&lt;/a&gt;&lt;br/&gt;
&lt;br/&gt;
We do not hit the&lt;br/&gt;
# assert(no_dead_loop) failed: dead loop detected&lt;br/&gt;
because that assert only detects 1-hop and 2-hop cycles. So like in E.jasm, after PhaseIdealLoop (incl IGVN) we have not removed the HaltNode with the dead-loop above, which leads to the assert&lt;br/&gt;
# assert(!in-&amp;gt;is_CFG()) failed: CFG Node with no controlling input?</comment>
                            <comment id="14528589" author="JIRAUSER19821" created="Sun, 9 Oct 2022 08:42:35 -0700"  >It seems to me, that the issue with E.jasm is that we have two AddI nodes in the dead data-loop at the end, so the Phi node thinks we have a valid entry / backedge loop, but both are &amp;quot;backedges&amp;quot;, so we still have a dead-loop.&lt;br/&gt;
&lt;br/&gt;
Please see &lt;a href=&quot;https://bugs.openjdk.org/secure/attachment/101001/E.jasm.crash.graph.png&quot;&gt;https://bugs.openjdk.org/secure/attachment/101001/E.jasm.crash.graph.png&lt;/a&gt;&lt;br/&gt;
&lt;br/&gt;
After PhaseIdealLoop (we only ran PHASE_PHASEIDEALLOOP1), where we also run IGVN, we leave behind this dead-loop (both data and control are deadloop - in this case we also have an endless loop [NeverBranch], but that is irrelevant).&lt;br/&gt;
Then, we run&lt;br/&gt;
PhaseIdealLoop::verify(igvn);&lt;br/&gt;
and find a HaltNode for which has_node(n) is false. This is because in&lt;br/&gt;
PhaseIdealLoop::build_loop_tree&lt;br/&gt;
we do a traversal from Root down the outputs, so we never find this dead-loop. And in verify, we assume that every control node has been visited (i.e. we cannot have dead-loop code).</comment>
                            <comment id="14528428" author="JIRAUSER19821" created="Fri, 7 Oct 2022 07:59:32 -0700"  >In search for other (simpler or more general) cases, I have found a very similar jasm code, that triggers a different assert, and does not even ever visit the PhiNode::is_data_loop function.&lt;br/&gt;
&lt;br/&gt;
java -jar ~/Documents/asmtools-7.0-build/release/lib/asmtools.jar jasm E.jasm&lt;br/&gt;
./java -XX:+UnlockExperimentalVMOptions -XX:+UseG1GC -XX:-UseLoopPredicate -XX:-UseProfiledLoopPredicate -XX:+TraceLoopOpts -XX:+PrintInlining -Xcomp -XX:CompileCommand=compileonly,E::test -XX:-TieredCompilation -XX:-LoopUnswitching E&lt;br/&gt;
&lt;br/&gt;
#  Internal Error (/home/emanuel/Documents/fork2-jdk/open/src/hotspot/share/opto/loopnode.cpp:5281), pid=1643825, tid=1643838&lt;br/&gt;
#  assert(!in-&amp;gt;is_CFG()) failed: CFG Node with no controlling input?&lt;br/&gt;
&lt;br/&gt;
I wonder if this is the same or a different bug?&lt;br/&gt;
Note, that also this E.jasm would first trigger the assert in PhiNode::merge_through_phi. So I simply use the bailout code from above, that returns nullptr instead of asserting &amp;quot;sanity&amp;quot;.</comment>
                            <comment id="14528426" author="JIRAUSER19821" created="Fri, 7 Oct 2022 07:55:21 -0700"  >It seems that the issue is that in PhiNode::is_data_loop (better name: is_dead_data_loop), we check if we have a Loop, and if we have a Loop, there is the possibility that we have a unique input because entry is TOP, and the backedge holds the now unique data input. We have a dead data loop.&lt;br/&gt;
&lt;br/&gt;
But in our case, we have a unique input because both entry and loopback data are this AddI node. Basically, we have a double loop (loop inside loop), but in total it is all dead. The difficulty is that there are legitimate ways that the Phi node can have two identical inputs for entry and loopback, for example if the loop-modification to this &amp;quot;varialbe&amp;quot; collpases to &amp;quot;identity function&amp;quot;.&lt;br/&gt;
&lt;br/&gt;
Currently, we decide that since we do not have different values for entry and loopback, this is not dead, and allow the Phi node to be replaced with the Add node, leaving this Add node to self-reference, and trigger the dead-loop assert.&lt;br/&gt;
&lt;br/&gt;
We need to find a better condition for dead-loops. As far as I understand, it is bad if a Phi node is removed last in a loop. Maybe what is really bad is if we leave a data-node loop without any Phi node. So a loop with only &amp;quot;unsafe&amp;quot; nodes. Maybe we cannot avoid a bigger traversal?</comment>
                            <comment id="14527930" author="JIRAUSER19821" created="Wed, 5 Oct 2022 04:14:53 -0700"  >I added the following change to avoid that &amp;quot;sanity&amp;quot; assert:&lt;br/&gt;
&lt;br/&gt;
@@ -2536,6 +2536,10 @@ Node* PhiNode::merge_through_phi(Node* root_phi, PhaseIterGVN* igvn) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;stack.pop();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
+  if (cached_vbox == nullptr) {&lt;br/&gt;
+    // Found dead-loop of Phi nodes. Phi nodes are called dead-loop-safe, so this is expected.&lt;br/&gt;
+    return nullptr; // no optimization - TODO: do we remove the dead-loop ???&lt;br/&gt;
+  }&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;assert(cached_vbox != NULL, &amp;quot;sanity&amp;quot;);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;const TypeInstPtr* btype = cached_vbox-&amp;gt;box_type();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;const TypeVect*    vtype = cached_vbox-&amp;gt;vec_type();&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
With that change, I found a D.jasm, such that I get that second assert:&lt;br/&gt;
# assert(no_dead_loop) failed: dead loop detected&lt;br/&gt;
&lt;br/&gt;
Assemble:&lt;br/&gt;
java -jar ~/Documents/asmtools-7.0-build/release/lib/asmtools.jar jasm D.jasm&lt;br/&gt;
&lt;br/&gt;
Run:&lt;br/&gt;
java -XX:+UnlockExperimentalVMOptions -XX:+UseG1GC -XX:-UseLoopPredicate -XX:-UseProfiledLoopPredicate -XX:+TraceLoopOpts -XX:+PrintInlining -Xcomp -XX:CompileCommand=compileonly,D::test -XX:-TieredCompilation -XX:-LoopUnswitching  D&lt;br/&gt;
&lt;br/&gt;
Note: without the VM code change, we would still first hit the &amp;quot;sanity&amp;quot; assert.</comment>
                            <comment id="14526903" author="JIRAUSER19821" created="Thu, 29 Sep 2022 01:33:56 -0700"  >I found A.jasm, a reduction of the class file, which triggers a different assert:&lt;br/&gt;
&lt;br/&gt;
#  Internal Error (/home/emanuel/Documents/fork2-jdk/open/src/hotspot/share/opto/cfgnode.cpp:2539), pid=16034, tid=16048&lt;br/&gt;
#  assert(cached_vbox != __null) failed: sanity&lt;br/&gt;
#&lt;br/&gt;
# JRE version: Java(TM) SE Runtime Environment (20.0) (slowdebug build 20-internal-2022-09-21-0845014.emanuel...)&lt;br/&gt;
# Java VM: Java HotSpot(TM) 64-Bit Server VM (slowdebug 20-internal-2022-09-21-0845014.emanuel..., compiled mode, compressed oops, compressed class ptrs, g1 gc, linux-amd64)&lt;br/&gt;
# Problematic frame:&lt;br/&gt;
# V  [libjvm.so+0x7b9687]  PhiNode::merge_through_phi(Node*, PhaseIterGVN*)+0x31d&lt;br/&gt;
&lt;br/&gt;
Assemble it to class file like this:&lt;br/&gt;
./java -jar ~/Documents/asmtools-7.0-build/release/lib/asmtools.jar jasm A.jasm&lt;br/&gt;
&lt;br/&gt;
And run like that:&lt;br/&gt;
./java -XX:+UnlockExperimentalVMOptions -XX:+UseG1GC -XX:-UseLoopPredicate -XX:-UseProfiledLoopPredicate -XX:+TraceLoopOpts -XX:+PrintInlining -Xcomp -XX:+TraceOptoParse -XX:CompileCommand=compileonly,A::test -Xcomp -XX:-TieredCompilation A&lt;br/&gt;
&lt;br/&gt;
The problem seems this:&lt;br/&gt;
During IGVN, a dead loop is generated. We have a dead-loop of 3 phi&amp;#39;s, that only reference each other in the inputs. But Phi nodes are considered is_dead_loop_safe.&lt;br/&gt;
For unsafe dead-loops, we decide to remove them immediately, but safe dead-loops remain in the graph. This seems mostly an optimization so that we do not always have to traverse the graph with is_unreachable_from_root.&lt;br/&gt;
The PhiNode::merge_through_phi assumes there cannot be a dead-loop with phi&amp;#39;s, but here I have an example.&lt;br/&gt;
We will probably have to discuss this, but maybe we can bail out of the optimization in PhiNode::merge_through_phi instead of the assert. Since it is a dead loop, further optimizations would be useless anyway. Maybe we could even call a cleanup of the graph in this case.&lt;br/&gt;
&lt;br/&gt;
I will now reduce the class file for the original assert:&lt;br/&gt;
# assert(no_dead_loop) failed: dead loop detected&lt;br/&gt;
&lt;br/&gt;
Note: I have struggled with the jasm decompiler because it uses class file version &amp;quot;64:0&amp;quot;. The bug here I could reproduce with a smaller version number &amp;quot;49:0&amp;quot;.</comment>
                            <comment id="14496765" author="thartmann" created="Tue, 17 May 2022 23:54:20 -0700"  >Deferring this to JDK 20 for now because it&amp;#39;s a long standing issue and we are getting closer to the fork. If the fix is ready in time for JDK 19, the fix version needs to be reset.</comment>
                            <comment id="14493076" author="JIRAUSER19821" created="Tue, 3 May 2022 08:23:42 -0700"  >I have enough other work for now. If nobody takes it, I might take it back at a later point.</comment>
                            <comment id="14484131" author="JIRAUSER19821" created="Wed, 23 Mar 2022 03:34:11 -0700"  >I investigated why 3330 gets ctrl input TOP.&lt;br/&gt;
We find a dominating If with the identical test. Then, we realize that after that dominating if, we took&lt;br/&gt;
3259  IfTrue  ===  3258  [[ 3314 ]]&lt;br/&gt;
but right now we just used&lt;br/&gt;
3316  IfFalse  ===  3314  [[ 3330 ]]&lt;br/&gt;
which means 3330 is not reachable. Hence, it seems that this is a good move to disconnect.&lt;br/&gt;
&lt;br/&gt;
The difficulty with this bug is that we have many paths that get eliminated, finding the real source of the issue feels like searching for a needle in a haystack.</comment>
                            <comment id="14483960" author="JIRAUSER19821" created="Tue, 22 Mar 2022 09:13:31 -0700"  >Another possibility: the ctrl flow should erode (TOP propagated down) before the phi&amp;#39;s become a dead loop.</comment>
                            <comment id="14483954" author="JIRAUSER19821" created="Tue, 22 Mar 2022 08:50:24 -0700"  >What I have found so far:&lt;br/&gt;
We crash in PhiNode::merge_through_phi , because there is a phi-spaghetti ball which has no data input (6 phi nodes). This triggers the sanity check assert.&lt;br/&gt;
Then, I implemented a crawler that goes recursively visit all ctrl nodes (where is_CFG()  is true). About 40-50 ctrl nodes up (If, ProjFalse etc), I find one that has the control input TOP.&lt;br/&gt;
3330  If  ===  1  3329&lt;br/&gt;
It could well be valid that this is TOP.&lt;br/&gt;
The node 3330 is also put on the work list, but it is not processed before we run into the assert.&lt;br/&gt;
My hypothesis: we should only do PhiNode::merge_through_phi  if we know that not somewhere up in the control flow we still have nodes that are on the worklist and may collapse. Because the whole Phi-spaghetti ball may die from TOP inputs that should propagate down eventually..</comment>
                            <comment id="14483953" author="JIRAUSER19821" created="Tue, 22 Mar 2022 08:48:38 -0700"  >I implemented some helper functions to analyze the Phi structure and the ctrl structure:&lt;br/&gt;
&lt;br/&gt;
// Call this from debugger:&lt;br/&gt;
// Starting at a phi node, traverse inputs (not control)&lt;br/&gt;
// Traverse phi nodes recursively&lt;br/&gt;
// Print and count all non-phi, non-NULL inputs&lt;br/&gt;
int traverse_phi(const int idx, bool printNonPhi) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;Node* root_phi = find_node(idx);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;if( root_phi == NULL ) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;tty-&amp;gt;print(&amp;quot;traverse_phi: node idx not found: %d\n&amp;quot;,idx);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return 0;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;if( !root_phi-&amp;gt;isa_Phi() ) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;tty-&amp;gt;print(&amp;quot;traverse_phi: input is not a phi node:\n&amp;quot;);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;root_phi-&amp;gt;dump();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return 0;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;Node_Stack stack(1);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;VectorSet  visited;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;int cnt = 0;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;stack.push(root_phi, 1); // ignore control&lt;br/&gt;
&amp;nbsp;&amp;nbsp;visited.set(root_phi-&amp;gt;_idx);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;while (stack.is_nonempty()) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Node* n   = stack.node();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;uint  idx = stack.index();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if (idx &amp;lt; n-&amp;gt;req()) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;stack.set_index(idx + 1);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Node* in = n-&amp;gt;in(idx);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if (in == NULL) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;continue; // ignore dead path&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;} else if (in-&amp;gt;isa_Phi()) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if (!visited.test_set(in-&amp;gt;_idx)) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;stack.push(in, 1); // ignore control&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;tty-&amp;gt;print(&amp;quot;# phi found:\n&amp;quot;);&lt;br/&gt;
	  in-&amp;gt;dump();&lt;br/&gt;
	}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;} else {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if (!visited.test_set(in-&amp;gt;_idx) &amp;amp;&amp;amp; printNonPhi) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;tty-&amp;gt;print(&amp;quot;# %d: interesting input found in node %d _in[%d]\n&amp;quot;,cnt++,n-&amp;gt;_idx,idx);&lt;br/&gt;
	  in-&amp;gt;dump();&lt;br/&gt;
	}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;} else {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;stack.pop();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return cnt;&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
// Call this from debugger:&lt;br/&gt;
// Starting at a region node, traverse inputs (only control)&lt;br/&gt;
// Traverse region nodes recursively&lt;br/&gt;
int traverse_cfg(const int idx, bool printNonCfg = false) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;Node* root_cfg = find_node(idx);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;if( root_cfg == NULL ) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;tty-&amp;gt;print(&amp;quot;traverse_cfg: node idx not found: %d\n&amp;quot;,idx);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return 0;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;if( !root_cfg-&amp;gt;is_CFG() ) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;tty-&amp;gt;print(&amp;quot;traverse_cfg: input is not a cfg node:\n&amp;quot;);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;root_cfg-&amp;gt;dump();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return 0;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;Node_Stack stack(1);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;VectorSet  visited;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;int cnt = 0;&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;stack.push(root_cfg, 0); // also take control&lt;br/&gt;
&amp;nbsp;&amp;nbsp;visited.set(root_cfg-&amp;gt;_idx);&lt;br/&gt;
&lt;br/&gt;
&amp;nbsp;&amp;nbsp;while (stack.is_nonempty()) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Node* n   = stack.node();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;uint  idx = stack.index();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if (idx &amp;lt; n-&amp;gt;req()) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;stack.set_index(idx + 1);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Node* in = n-&amp;gt;in(idx);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if (in == NULL) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;continue; // ignore dead path&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;} else if (in-&amp;gt;is_CFG() ) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if (!visited.test_set(in-&amp;gt;_idx)) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;stack.push(in, 0); // also take control&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;tty-&amp;gt;print(&amp;quot;# cfg found:\n&amp;quot;);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;in-&amp;gt;dump();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;} else {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if (!visited.test_set(in-&amp;gt;_idx) &amp;amp;&amp;amp; printNonCfg) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;tty-&amp;gt;print(&amp;quot;# %d: interesting input found in node %d _in[%d]\n&amp;quot;,cnt++,n-&amp;gt;_idx,idx);&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;in-&amp;gt;dump();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;} else {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;stack.pop();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return cnt;&lt;br/&gt;
}</comment>
                            <comment id="14476253" author="JIRAUSER19821" created="Thu, 10 Feb 2022 07:36:18 -0800"  >What I tried so far:&lt;br/&gt;
I disassembled the JSON.class with jdis, and immediately reassembled it with jasm. Unfortunately, this process is not reflexive, and it does not produce an identical file (only about 3/4 the size). If put in that new class file, I get this error instead:&lt;br/&gt;
&lt;br/&gt;
--------------------------&lt;br/&gt;
Time: 0.067&lt;br/&gt;
There was 1 failure:&lt;br/&gt;
1) testIssue1463(com.alibaba.fastjson.deserializer.issue1463.TestIssue1463)&lt;br/&gt;
java.lang.NoClassDefFoundError: serializer/SerializeWriter&lt;br/&gt;
	at com.alibaba.fastjson.deserializer.issue1463.TestIssue1463.doubleDeserialization(TestIssue1463.java:37)&lt;br/&gt;
	at com.alibaba.fastjson.deserializer.issue1463.TestIssue1463.testIssue1463(TestIssue1463.java:28)&lt;br/&gt;
	... 31 trimmed&lt;br/&gt;
Caused by: java.lang.ClassNotFoundException: serializer.SerializeWriter&lt;br/&gt;
	at java.base/jdk.internal.loader.BuiltinClassLoader.loadClass(BuiltinClassLoader.java:641)&lt;br/&gt;
	at java.base/jdk.internal.loader.ClassLoaders$AppClassLoader.loadClass(ClassLoaders.java:188)&lt;br/&gt;
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:521)&lt;br/&gt;
	... 34 more&lt;br/&gt;
&lt;br/&gt;
FAILURES!!!&lt;br/&gt;
Tests run: 1,  Failures: 1&lt;br/&gt;
--------------------&lt;br/&gt;
&lt;br/&gt;
However, if I disassemble it with jdec, and reassemble it with jcoder the files are identical. Unfortunately, the jdec output is not humanly readable, The byte-code is displayed in hex format only.&lt;br/&gt;
&lt;br/&gt;
I tried to jdis - jasm - jdec the class file. This also produced hex format byte-code. However, it is not identical (though similar), and if pasted into the other file this leads to issues (I assume some symbols or offsets have changed).&lt;br/&gt;
&lt;br/&gt;
It is thus not clear how to reduce the class file. We may have to pain-stakingly debug the graph of the given class-file.</comment>
                            <comment id="14476113" author="tongwan" created="Wed, 9 Feb 2022 18:27:17 -0800"  >Additional information from the submitter that may be useful:&lt;br/&gt;
&lt;br/&gt;
This fuzzer is specially designed to test the JIT compilers in JVM, it mutates(change some codes inside a file) class files, run the mutated files and expects different behaviors of JVM under interpret mode and compiled mode.&lt;br/&gt;
&lt;br/&gt;
This fuzzer is based on byte code. That is, the fuzzer reads in the byte code and mutate it directly, so I cannot provide the source code that is mutated since the fuzzer generates byte code instead of source code. Maybe decompilation tools are helpful.&lt;br/&gt;
&lt;br/&gt;
The original source code is from Alibaba&amp;#39;s fastjson: &lt;a href=&quot;https://github.com/alibaba/fastjson&quot;&gt;https://github.com/alibaba/fastjson&lt;/a&gt;. In the fuzz test, only one function in one specific class is mutated: com/alibaba/fastjson/JSON.parseObject(String ,Type, ParserConfig, ParseProcess, int, Feature...)&lt;br/&gt;
The mutated file that is generated by the fuzzer is: bug/bugFiles/com/alibaba/fastjson/JSON.class. It&amp;#39;s sure that this function causes the bug.&lt;br/&gt;
&lt;br/&gt;
To produce the bug, just replace the original com/alibaba/fastjson/JSON.class with this mutated one, then run the test: com.alibaba.fastjson.deserializer.issue1463.TestIssue1463 through JUnit. You could run this command in bug/:&lt;br/&gt;
java -Xcomp -cp ./bugFiles:./util:./junit.jar:./hamcrest.jar:./target/classes:./target/test-classes org.junit.runner.JUnitCore com.alibaba.fastjson.deserializer.issue1463.TestIssue1463&lt;br/&gt;
You can see that in this command, ./bugFiles is the first in cp, in order to replace original file with the mutated one.&lt;br/&gt;
To remove the &amp;#39;-Xcomp&amp;#39; or replace it with &amp;#39;-Xint&amp;#39; leads to different results, as indicated in the report.&lt;br/&gt;
</comment>
                            <comment id="14475788" author="fmatte" created="Wed, 9 Feb 2022 02:21:47 -0800"  >This issue is reproducible in jdk8 also</comment>
                            <comment id="14475321" author="fmatte" created="Tue, 8 Feb 2022 02:51:40 -0800"  >I just ran with -Xcomp and hit the assert, I have jdk19 b04 (slightly older version)&lt;br/&gt;
&lt;br/&gt;
/tank/fmatte/JAVA/jdk19/jdk-19-ea+04/fastdebug/bin/java -Xcomp -cp ./bugFiles:./util:./junit.jar:./hamcrest.jar:./target/classes:./target/test-classes org.junit.runner.JUnitCore com.alibaba.fastjson.deserializer.issue1463.TestIssue1463&lt;br/&gt;
JUnit version 4.13.2&lt;br/&gt;
. 341  ConI  ===  0  [[ 1339  1163  5194  1159  1153  7033  7034  7021  7022  111  110  7023  7024  7025  5195  7026  7077  153  118  110  110  2998  7135  117  7136  6849  7018  7094  7098  152  146  7089  2952  603  153  2951  814  1910  110  5196  2953  633  153  6830  7099  7100  5196  3055  153  427  2747  3193  110  7117  2953  152  153  2952  1152  3136  2996  3049  110  7123  7041  2952  2951  111  5231  2951  5196  153  5196  2952  7040  391  109  2919  3000  153  797  2917  2952  2997  634  7116  2999  5196  2753  5195  2524  111  4378  2953  5232  2952  5196  111  5195  462  153  7124  6821  6833  108  111  6834  160  7075  111  2953  7076  2916  111  111  111  403  1904  7115  6906  2951  5196  6935  2951  2953  7035  2951  111  7114  7728  2952  5196  152  111  2951  153  153  2953  153  2953  7754  7229  7000  2952  7118  165  2951  2952  2953  5260  110  2951  6812  153  2951  2953  5196  6810  358  6990  2918  111  153  2953  2952  2951  7039  6811  2953  2952  110  106  6934  2915  2753  2968  6934  2914 ]]  #int:1 !jvms: JSON::parseObject @ bci:240 (line 368)&lt;br/&gt;
&amp;nbsp;2524  AddI  === _  2524  341  [[ 2996  160  7509  2919  4408  2916  2997  2997  2998  2998  152  2524  2996  2763  2918  2917  1920  2999  3000 ]]  !orig=[7508],... !jvms: JSON::parseObject @ bci:748 (line 368)&lt;br/&gt;
# To suppress the following error report, specify this argument&lt;br/&gt;
# after -XX: or in .hotspotrc:  SuppressErrorAt=/phaseX.cpp:943&lt;br/&gt;
#&lt;br/&gt;
# A fatal error has been detected by the Java Runtime Environment:&lt;br/&gt;
#&lt;br/&gt;
#  Internal Error (/opt/mach5/mesos/work_dir/slaves/a2dc162d-743b-4800-9e92-31f85abb45b1-S136873/frameworks/1735e8a2-a1db-478c-8104-60c8b0af87dd-0196/executors/1a465b75-bc3e-436d-8ce8-843258d7f72f/runs/4c2d264d-5066-447e-8e7e-d0ab59cf74c8/workspace/open/src/hotspot/share/opto/phaseX.cpp:943), pid=11039, tid=11052&lt;br/&gt;
#  assert(no_dead_loop) failed: dead loop detected&lt;br/&gt;
#&lt;br/&gt;
# JRE version: Java(TM) SE Runtime Environment (19.0+4) (fastdebug build 19-ea+4-144)&lt;br/&gt;
# Java VM: Java HotSpot(TM) 64-Bit Server VM (fastdebug 19-ea+4-144, compiled mode, sharing, tiered, compressed oops, compressed class ptrs, g1 gc, linux-amd64)&lt;br/&gt;
# Problematic frame:&lt;br/&gt;
# V  [libjvm.so+0x16935e6]  PhaseGVN::dead_loop_check(Node*) [clone .part.0]+0x156&lt;br/&gt;
#&lt;br/&gt;
# Core dump will be written. Default location: Core dumps may be processed with &amp;quot;/usr/share/apport/apport %p %s %c %d %P %E&amp;quot; (or dumping to /tank/fmatte/bugs/8280126/bug/core.11039)&lt;br/&gt;
#&lt;br/&gt;
# An error report file with more information is saved as:&lt;br/&gt;
# /tank/fmatte/bugs/8280126/bug/hs_err_pid11039.log&lt;br/&gt;
#&lt;br/&gt;
# Compiler replay data is saved as:&lt;br/&gt;
# /tank/fmatte/bugs/8280126/bug/replay_pid11039.log&lt;br/&gt;
#&lt;br/&gt;
# If you would like to submit a bug report, please visit:&lt;br/&gt;
#   &lt;a href=&quot;https://bugreport.java.com/bugreport/crash.jsp&quot;&gt;https://bugreport.java.com/bugreport/crash.jsp&lt;/a&gt;&lt;br/&gt;
#&lt;br/&gt;
</comment>
                            <comment id="14472278" author="chagedorn" created="Wed, 26 Jan 2022 03:52:11 -0800"  >I can also reproduce this with latest JDK when using -XX:+UnlockExperimentalVMOptions -XX:-EnableVectorReboxing. Otherwise, I hit the assert which [~dlong] posted above. It is probably the same issue and we just fail earlier because the graph is already broken.</comment>
                            <comment id="14471121" author="dlong" created="Fri, 21 Jan 2022 15:47:52 -0800"  >The builds at &lt;a href=&quot;https://jdk.java.net/18/&quot;&gt;https://jdk.java.net/18/&lt;/a&gt; are not debug builds, which explains why I didn&amp;#39;t see an assert.  I do get the assert with this build:&lt;br/&gt;
&lt;br/&gt;
# JRE version: Java(TM) SE Runtime Environment (18.0+32) (fastdebug build 18-ea+32-2068)&lt;br/&gt;
</comment>
                            <comment id="14471118" author="dlong" created="Fri, 21 Jan 2022 15:30:13 -0800"  >With jdk19 I get:&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;assert(cached_vbox != __null) failed: sanity&lt;br/&gt;
called from PhiNode::merge_through_phi&lt;br/&gt;
&lt;br/&gt;
I haven&amp;#39;t been able to reproduce it in jdk18 b31</comment>
                            <comment id="14470857" author="dlong" created="Thu, 20 Jan 2022 15:44:52 -0800"  >ILW = same as &lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8275326&quot; title=&quot;C2: assert(no_dead_loop) failed: dead loop detected&quot; class=&quot;issue-link&quot; data-issue-key=&quot;JDK-8275326&quot;&gt;&lt;strike&gt;JDK-8275326&lt;/strike&gt;&lt;/a&gt; = P3</comment>
                            <comment id="14470707" author="dcubed" created="Thu, 20 Jan 2022 07:19:16 -0800"  >Moving from hotspot/runtime -&amp;gt; hotspot/compiler for initial triage.</comment>
                            <comment id="14470643" author="tongwan" created="Thu, 20 Jan 2022 02:29:52 -0800"  >Requested the bug.zip file from the submitter.</comment>
                            <comment id="14470623" author="fmatte" created="Thu, 20 Jan 2022 00:14:12 -0800"  >Please ask for bug.zip file mentioned in the bug report</comment>
                            <comment id="14470605" author="tongwan" created="Wed, 19 Jan 2022 23:02:58 -0800"  >Additional information from the submitter:&lt;br/&gt;
I have tried the JDK18 of the following version:&lt;br/&gt;
&lt;br/&gt;
openjdk version &amp;quot;18-ea&amp;quot; 2022-03-22&lt;br/&gt;
OpenJDK Runtime Environment (build 18-ea+31-2049)&lt;br/&gt;
OpenJDK 64-Bit Server VM (build 18-ea+31-2049, mixed mode, sharing)&lt;br/&gt;
&lt;br/&gt;
However, it seems that the problem still exists. It ran correctly in mixed mode and interpreted mode, but trapped in dead loop in compiled mode.&lt;br/&gt;
</comment>
                            <comment id="14469786" author="tongwan" created="Mon, 17 Jan 2022 23:21:26 -0800"  >Requested the submitter verify the fix by downloading the latest version JDK 18 at &lt;a href=&quot;https://jdk.java.net/18/&quot;&gt;https://jdk.java.net/18/&lt;/a&gt;&lt;br/&gt;
If the issue still exists, requested the bug.zip mentioned in the reproducing steps.</comment>
                            <comment id="14469248" author="fmatte" created="Thu, 13 Jan 2022 19:51:54 -0800"  >This looks exactly similar to &lt;a href=&quot;https://bugs.openjdk.org/browse/JDK-8275326&quot; title=&quot;C2: assert(no_dead_loop) failed: dead loop detected&quot; class=&quot;issue-link&quot; data-issue-key=&quot;JDK-8275326&quot;&gt;&lt;strike&gt;JDK-8275326&lt;/strike&gt;&lt;/a&gt;. There is no source to validate.&lt;br/&gt;
Could you please check with jdk18 latest version to confirm the fix?</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10600">
                    <name>Causes</name>
                                            <outwardlinks description="causes">
                                        <issuelink>
            <issuekey id="5170353">JDK-8367243</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                            <issuelinktype id="10002">
                    <name>Duplicate</name>
                                            <outwardlinks description="duplicates">
                                        <issuelink>
            <issuekey id="4296726">JDK-6742111</issuekey>
        </issuelink>
                            </outwardlinks>
                                                                <inwardlinks description="duplicates">
                                        <issuelink>
            <issuekey id="5097758">JDK-8305797</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                            <issuelinktype id="10003">
                    <name>Relates</name>
                                            <outwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="5060448">JDK-8275326</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="5088330">JDK-8297642</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="5090238">JDK-8299214</issuekey>
        </issuelink>
                            </outwardlinks>
                                                                <inwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="5101597">JDK-8308675</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="5086737">JDK-8296318</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="5086811">JDK-8296389</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="5086838">JDK-8296412</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="5149031">JDK-8348572</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="5094812">JDK-8303045</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="5090238">JDK-8299214</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="100887" name="A.jasm" size="1484" author="epeter" created="Thu, 29 Sep 2022 01:34:09 -0700"/>
                            <attachment id="101197" name="A2.jasm" size="954" author="epeter" created="Wed, 26 Oct 2022 05:06:18 -0700"/>
                            <attachment id="101198" name="A2.jasm.graph.crash.png" size="49462" author="epeter" created="Wed, 26 Oct 2022 05:06:18 -0700"/>
                            <attachment id="101199" name="A2.jasm.graph.png" size="69127" author="epeter" created="Wed, 26 Oct 2022 05:06:18 -0700"/>
                            <attachment id="100949" name="D.jasm" size="1599" author="epeter" created="Wed, 5 Oct 2022 04:14:52 -0700"/>
                            <attachment id="101005" name="D.jasm.crash.graph.png" size="95870" author="epeter" created="Mon, 10 Oct 2022 01:26:34 -0700"/>
                            <attachment id="101237" name="D2.jasm" size="1594" author="epeter" created="Fri, 28 Oct 2022 04:21:45 -0700"/>
                            <attachment id="101238" name="D2.jasm.graph.crash.png" size="76935" author="epeter" created="Fri, 28 Oct 2022 04:21:45 -0700"/>
                            <attachment id="101239" name="D2.jasm.graph.png" size="145136" author="epeter" created="Fri, 28 Oct 2022 04:21:45 -0700"/>
                            <attachment id="101240" name="D2.jasm.images.zip" size="1072213" author="epeter" created="Fri, 28 Oct 2022 04:21:47 -0700"/>
                            <attachment id="100980" name="E.jasm" size="1445" author="epeter" created="Fri, 7 Oct 2022 07:56:57 -0700"/>
                            <attachment id="101001" name="E.jasm.crash.graph.png" size="83604" author="epeter" created="Sun, 9 Oct 2022 08:18:31 -0700"/>
                            <attachment id="101002" name="F.jasm" size="1705" author="epeter" created="Sun, 9 Oct 2022 08:45:18 -0700"/>
                            <attachment id="101004" name="F.jasm.crash.graph.png" size="84323" author="epeter" created="Sun, 9 Oct 2022 23:05:45 -0700"/>
                            <attachment id="101052" name="G.jasm" size="1758" author="epeter" created="Wed, 12 Oct 2022 03:44:48 -0700"/>
                            <attachment id="101053" name="G.jasm.crash.graph.png" size="45585" author="epeter" created="Wed, 12 Oct 2022 03:45:14 -0700"/>
                            <attachment id="101055" name="H.jasm" size="1701" author="epeter" created="Wed, 12 Oct 2022 04:04:22 -0700"/>
                            <attachment id="101135" name="K.jasm" size="1966" author="epeter" created="Wed, 19 Oct 2022 08:27:41 -0700"/>
                            <attachment id="101134" name="K.jasm.bailout.graph.png" size="77735" author="epeter" created="Wed, 19 Oct 2022 08:27:33 -0700"/>
                            <attachment id="101190" name="N.jasm" size="1716" author="epeter" created="Tue, 25 Oct 2022 23:53:04 -0700"/>
                            <attachment id="101191" name="N.jasm.graph.crash.png" size="56283" author="epeter" created="Tue, 25 Oct 2022 23:53:04 -0700"/>
                            <attachment id="101192" name="N.jasm.graph.png" size="90259" author="epeter" created="Tue, 25 Oct 2022 23:53:04 -0700"/>
                            <attachment id="101262" name="P.jasm" size="757" author="epeter" created="Mon, 31 Oct 2022 08:25:45 -0700"/>
                            <attachment id="101263" name="P.jasm.0.after_parsing.png" size="110889" author="epeter" created="Mon, 31 Oct 2022 08:25:46 -0700"/>
                            <attachment id="101264" name="P.jasm.1.before_codegen.png" size="59781" author="epeter" created="Mon, 31 Oct 2022 08:25:46 -0700"/>
                            <attachment id="101265" name="P.jasm.2.at_crash.png" size="82657" author="epeter" created="Mon, 31 Oct 2022 08:25:45 -0700"/>
                            <attachment id="101291" name="Q1.jasm" size="919" author="epeter" created="Tue, 1 Nov 2022 23:09:51 -0700"/>
                            <attachment id="101292" name="Q1.jasm.0.before.png" size="110146" author="epeter" created="Tue, 1 Nov 2022 23:09:51 -0700"/>
                            <attachment id="101293" name="Q1.jasm.1.crash.png" size="118296" author="epeter" created="Tue, 1 Nov 2022 23:09:51 -0700"/>
                            <attachment id="101478" name="Q3.jasm" size="1132" author="epeter" created="Tue, 8 Nov 2022 01:04:11 -0800"/>
                            <attachment id="101479" name="Q3.jasm.graph.png" size="32686" author="epeter" created="Tue, 8 Nov 2022 01:04:12 -0800"/>
                            <attachment id="101296" name="R.jasm" size="908" author="epeter" created="Wed, 2 Nov 2022 07:13:23 -0700"/>
                            <attachment id="101297" name="R.jasm.5.crash.png" size="113097" author="epeter" created="Wed, 2 Nov 2022 07:13:23 -0700"/>
                            <attachment id="101298" name="R.jasm.graph.zip" size="582230" author="epeter" created="Wed, 2 Nov 2022 07:13:24 -0700"/>
                            <attachment id="101536" name="T.java" size="1968" author="epeter" created="Thu, 10 Nov 2022 05:23:09 -0800"/>
                            <attachment id="101537" name="T.java.images.zip" size="785276" author="epeter" created="Thu, 10 Nov 2022 05:23:10 -0800"/>
                            <attachment id="101545" name="T2.java" size="2533" author="epeter" created="Thu, 10 Nov 2022 11:02:16 -0800"/>
                            <attachment id="101560" name="T3.java" size="4066" author="epeter" created="Fri, 11 Nov 2022 00:54:08 -0800"/>
                            <attachment id="101603" name="TestIrreducibleLoops.jasm" size="21079" author="epeter" created="Tue, 15 Nov 2022 02:55:04 -0800"/>
                            <attachment id="101494" name="test_007.0.png" size="77157" author="epeter" created="Tue, 8 Nov 2022 09:10:46 -0800"/>
                            <attachment id="101495" name="test_007.1.png" size="45945" author="epeter" created="Tue, 8 Nov 2022 09:10:46 -0800"/>
                            <attachment id="101496" name="test_007.2.png" size="35194" author="epeter" created="Tue, 8 Nov 2022 09:10:46 -0800"/>
                            <attachment id="101502" name="test_009.0.png" size="97213" author="epeter" created="Tue, 8 Nov 2022 10:28:31 -0800"/>
                            <attachment id="101503" name="test_009.1.png" size="65330" author="epeter" created="Tue, 8 Nov 2022 10:28:30 -0800"/>
                            <attachment id="101504" name="test_009.2.png" size="51923" author="epeter" created="Tue, 8 Nov 2022 10:28:31 -0800"/>
                            <attachment id="101604" name="test_011.png" size="1726575" author="epeter" created="Tue, 15 Nov 2022 02:55:35 -0800"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_11700" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_10600" key="com.oracle.jira.javabugsystem-jira-plugin:jbs-fixedBackportedCustomfield">
                        <customfieldname>Fixed</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_11100" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i2vniz:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_11004" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10006" key="com.atlassian.jira.plugin.system.customfieldtypes:select">
                        <customfieldname>Resolved In Build</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="17336"><![CDATA[b09]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10008" key="com.oracle.jira.jira-subcomponent-plugin:oracle-subComponentField">
                        <customfieldname>Subcomponent</customfieldname>
                        <customfieldvalues>
                             <customfieldvalue key="208"><![CDATA[compiler]]></customfieldvalue> 
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_10601" key="com.oracle.jira.javabugsystem-jira-plugin:jbs-targetBackportedCustomfield">
                        <customfieldname>Targeted</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    </customfields>
    </item>
</channel>
</rss>